testcases/valid
calling the reference compiler on testcases/valid/advanced/binarySortTree.wacc
-- Test: binarySortTree.wacc

-- Uploaded file: 
---------------------------------------------------------------
# The program reads n (number of integers), then n integers. After each input, 
# it insert the integer into a binary search tree. At the end, it prints out 
# the content in the binary search tree so that we have a sorted list of 
# integer.
# 
# We represent a node in the binary search tree using two pair elements. The 
# first element has a type <int, pair>, the int is the integer stored in the 
# node, the pair is the pointer to the second pair element. The second pair 
# element has a type <pair, pair> which is the pointer to the two children 
# nodes in the binary search tree.

begin

  # Create a new node of a binary search tree having the given integer value 
  # and points to the two given pairs.
  pair(int, pair) createNewNode(int value, pair(int, pair) left, pair(int, pair) right) is
    pair(pair, pair) p = newpair(left, right) ;
    pair(int, pair) q = newpair(value, p) ;
    return q
  end

  # Given a root of a binary search tree and an integer to insert, the function 
  # inserts the integer into the tree and returns the new root of the tree.
  pair(int, pair) insert(pair(int, pair) root, int n) is
    if root == null then
      root = call createNewNode(n, null, null)
    else
      pair(pair, pair) p = snd root ;
      int current = fst root ;
      pair(int, pair) q = null ;
      if n < current then
      	q = fst p ;
        fst p = call insert(q, n)
      else 
      	q = snd p ;
        snd p = call insert(q, n)
      fi 
    fi ;
    return root
  end

  # Print the integers in the binary search tree in the increasing order.
  int printTree(pair(int, pair) root) is
    if root == null then
      return 0 
    else
      pair(pair, pair) body = snd root ;
      pair(int, pair) p = fst body ;
      int temp = call printTree(p) ;
      temp = fst root ; 
      print temp ;
      print ' ' ;
      p = snd body ;
      temp = call printTree(p) ;
      return 0
    fi
  end

  # The main function
  int n = 0 ;
  print "Please enter the number of integers to insert: " ;
  read n ;
  print "There are " ;
  print n ;
  println " integers." ;
  int i = 0 ;
  pair(int, pair) root = null ;
  while i < n do
    int x = 0 ;
    print "Please enter the number at position " ; 
    print i + 1 ;
    print " : " ;
    read x ;
    root = call insert(root, x) ;
    i = i + 1
  done ;
  print "Here are the numbers sorted: " ;
  i = call printTree(root) ;
  println ""
end



---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
binarySortTree.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 47
4		.ascii	"Please enter the number of integers to insert: "
5	msg_1:
6		.word 10
7		.ascii	"There are "
8	msg_2:
9		.word 10
10		.ascii	" integers."
11	msg_3:
12		.word 36
13		.ascii	"Please enter the number at position "
14	msg_4:
15		.word 3
16		.ascii	" : "
17	msg_5:
18		.word 29
19		.ascii	"Here are the numbers sorted: "
20	msg_6:
21		.word 0
22		.ascii	""
23	msg_7:
24		.word 50
25		.ascii	"NullReferenceError: dereference a null reference\n\0"
26	msg_8:
27		.word 3
28		.ascii	"%d\0"
29	msg_9:
30		.word 5
31		.ascii	"%.*s\0"
32	msg_10:
33		.word 3
34		.ascii	"%d\0"
35	msg_11:
36		.word 1
37		.ascii	"\0"
38	msg_12:
39		.word 82
40		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
41	
42	.text
43	
44	.global main
45	f_createNewNode:
46		PUSH {lr}
47		SUB sp, sp, #8
48		LDR r0, =8
49		BL malloc
50		MOV r4, r0
51		LDR r5, [sp, #16]
52		LDR r0, =4
53		BL malloc
54		STR r5, [r0]
55		STR r0, [r4]
56		LDR r5, [sp, #20]
57		LDR r0, =4
58		BL malloc
59		STR r5, [r0]
60		STR r0, [r4, #4]
61		STR r4, [sp, #4]
62		LDR r0, =8
63		BL malloc
64		MOV r4, r0
65		LDR r5, [sp, #12]
66		LDR r0, =4
67		BL malloc
68		STR r5, [r0]
69		STR r0, [r4]
70		LDR r5, [sp, #4]
71		LDR r0, =4
72		BL malloc
73		STR r5, [r0]
74		STR r0, [r4, #4]
75		STR r4, [sp]
76		LDR r4, [sp]
77		MOV r0, r4
78		ADD sp, sp, #8
79		POP {pc}
80		POP {pc}
81		.ltorg
82	f_insert:
83		PUSH {lr}
84		LDR r4, [sp, #4]
85		LDR r5, =0
86		CMP r4, r5
87		MOVEQ r4, #1
88		MOVNE r4, #0
89		CMP r4, #0
90		BEQ L0
91		LDR r4, =0
92		STR r4, [sp, #-4]!
93		LDR r4, =0
94		STR r4, [sp, #-4]!
95		LDR r4, [sp, #16]
96		STR r4, [sp, #-4]!
97		BL f_createNewNode
98		ADD sp, sp, #12
99		MOV r4, r0
100		STR r4, [sp, #4]
101		B L1
102	L0:
103		SUB sp, sp, #12
104		LDR r4, [sp, #16]
105		MOV r0, r4
106		BL p_check_null_pointer
107		LDR r4, [r4, #4]
108		LDR r4, [r4]
109		STR r4, [sp, #8]
110		LDR r4, [sp, #16]
111		MOV r0, r4
112		BL p_check_null_pointer
113		LDR r4, [r4]
114		LDR r4, [r4]
115		STR r4, [sp, #4]
116		LDR r4, =0
117		STR r4, [sp]
118		LDR r4, [sp, #20]
119		LDR r5, [sp, #4]
120		CMP r4, r5
121		MOVLT r4, #1
122		MOVGE r4, #0
123		CMP r4, #0
124		BEQ L2
125		LDR r4, [sp, #8]
126		MOV r0, r4
127		BL p_check_null_pointer
128		LDR r4, [r4]
129		LDR r4, [r4]
130		STR r4, [sp]
131		LDR r4, [sp, #20]
132		STR r4, [sp, #-4]!
133		LDR r4, [sp, #4]
134		STR r4, [sp, #-4]!
135		BL f_insert
136		ADD sp, sp, #8
137		MOV r4, r0
138		LDR r5, [sp, #8]
139		MOV r0, r5
140		BL p_check_null_pointer
141		LDR r5, [r5]
142		STR r4, [r5]
143		B L3
144	L2:
145		LDR r4, [sp, #8]
146		MOV r0, r4
147		BL p_check_null_pointer
148		LDR r4, [r4, #4]
149		LDR r4, [r4]
150		STR r4, [sp]
151		LDR r4, [sp, #20]
152		STR r4, [sp, #-4]!
153		LDR r4, [sp, #4]
154		STR r4, [sp, #-4]!
155		BL f_insert
156		ADD sp, sp, #8
157		MOV r4, r0
158		LDR r5, [sp, #8]
159		MOV r0, r5
160		BL p_check_null_pointer
161		LDR r5, [r5, #4]
162		STR r4, [r5]
163	L3:
164		ADD sp, sp, #12
165	L1:
166		LDR r4, [sp, #4]
167		MOV r0, r4
168		POP {pc}
169		POP {pc}
170		.ltorg
171	f_printTree:
172		PUSH {lr}
173		LDR r4, [sp, #4]
174		LDR r5, =0
175		CMP r4, r5
176		MOVEQ r4, #1
177		MOVNE r4, #0
178		CMP r4, #0
179		BEQ L4
180		LDR r4, =0
181		MOV r0, r4
182		POP {pc}
183		B L5
184	L4:
185		SUB sp, sp, #12
186		LDR r4, [sp, #16]
187		MOV r0, r4
188		BL p_check_null_pointer
189		LDR r4, [r4, #4]
190		LDR r4, [r4]
191		STR r4, [sp, #8]
192		LDR r4, [sp, #8]
193		MOV r0, r4
194		BL p_check_null_pointer
195		LDR r4, [r4]
196		LDR r4, [r4]
197		STR r4, [sp, #4]
198		LDR r4, [sp, #4]
199		STR r4, [sp, #-4]!
200		BL f_printTree
201		ADD sp, sp, #4
202		MOV r4, r0
203		STR r4, [sp]
204		LDR r4, [sp, #16]
205		MOV r0, r4
206		BL p_check_null_pointer
207		LDR r4, [r4]
208		LDR r4, [r4]
209		STR r4, [sp]
210		LDR r4, [sp]
211		MOV r0, r4
212		BL p_print_int
213		MOV r4, #' '
214		MOV r0, r4
215		BL putchar
216		LDR r4, [sp, #8]
217		MOV r0, r4
218		BL p_check_null_pointer
219		LDR r4, [r4, #4]
220		LDR r4, [r4]
221		STR r4, [sp, #4]
222		LDR r4, [sp, #4]
223		STR r4, [sp, #-4]!
224		BL f_printTree
225		ADD sp, sp, #4
226		MOV r4, r0
227		STR r4, [sp]
228		LDR r4, =0
229		MOV r0, r4
230		ADD sp, sp, #12
231		POP {pc}
232		ADD sp, sp, #12
233	L5:
234		POP {pc}
235		.ltorg
236	main:
237		PUSH {lr}
238		SUB sp, sp, #12
239		LDR r4, =0
240		STR r4, [sp, #8]
241		LDR r4, =msg_0
242		MOV r0, r4
243		BL p_print_string
244		ADD r4, sp, #8
245		MOV r0, r4
246		BL p_read_int
247		LDR r4, =msg_1
248		MOV r0, r4
249		BL p_print_string
250		LDR r4, [sp, #8]
251		MOV r0, r4
252		BL p_print_int
253		LDR r4, =msg_2
254		MOV r0, r4
255		BL p_print_string
256		BL p_print_ln
257		LDR r4, =0
258		STR r4, [sp, #4]
259		LDR r4, =0
260		STR r4, [sp]
261		B L6
262	L7:
263		SUB sp, sp, #4
264		LDR r4, =0
265		STR r4, [sp]
266		LDR r4, =msg_3
267		MOV r0, r4
268		BL p_print_string
269		LDR r4, [sp, #8]
270		LDR r5, =1
271		ADDS r4, r4, r5
272		BLVS p_throw_overflow_error
273		MOV r0, r4
274		BL p_print_int
275		LDR r4, =msg_4
276		MOV r0, r4
277		BL p_print_string
278		ADD r4, sp, #0
279		MOV r0, r4
280		BL p_read_int
281		LDR r4, [sp]
282		STR r4, [sp, #-4]!
283		LDR r4, [sp, #8]
284		STR r4, [sp, #-4]!
285		BL f_insert
286		ADD sp, sp, #8
287		MOV r4, r0
288		STR r4, [sp, #4]
289		LDR r4, [sp, #8]
290		LDR r5, =1
291		ADDS r4, r4, r5
292		BLVS p_throw_overflow_error
293		STR r4, [sp, #8]
294		ADD sp, sp, #4
295	L6:
296		LDR r4, [sp, #4]
297		LDR r5, [sp, #8]
298		CMP r4, r5
299		MOVLT r4, #1
300		MOVGE r4, #0
301		CMP r4, #1
302		BEQ L7
303		LDR r4, =msg_5
304		MOV r0, r4
305		BL p_print_string
306		LDR r4, [sp]
307		STR r4, [sp, #-4]!
308		BL f_printTree
309		ADD sp, sp, #4
310		MOV r4, r0
311		STR r4, [sp, #4]
312		LDR r4, =msg_6
313		MOV r0, r4
314		BL p_print_string
315		BL p_print_ln
316		ADD sp, sp, #12
317		LDR r0, =0
318		POP {pc}
319		.ltorg
320	p_check_null_pointer:
321		PUSH {lr}
322		CMP r0, #0
323		LDREQ r0, =msg_7
324		BLEQ p_throw_runtime_error
325		POP {pc}
326	p_print_int:
327		PUSH {lr}
328		MOV r1, r0
329		LDR r0, =msg_8
330		ADD r0, r0, #4
331		BL printf
332		MOV r0, #0
333		BL fflush
334		POP {pc}
335	p_print_string:
336		PUSH {lr}
337		LDR r1, [r0]
338		ADD r2, r0, #4
339		LDR r0, =msg_9
340		ADD r0, r0, #4
341		BL printf
342		MOV r0, #0
343		BL fflush
344		POP {pc}
345	p_read_int:
346		PUSH {lr}
347		MOV r1, r0
348		LDR r0, =msg_10
349		ADD r0, r0, #4
350		BL scanf
351		POP {pc}
352	p_print_ln:
353		PUSH {lr}
354		LDR r0, =msg_11
355		ADD r0, r0, #4
356		BL puts
357		MOV r0, #0
358		BL fflush
359		POP {pc}
360	p_throw_overflow_error:
361		LDR r0, =msg_12
362		BL p_throw_runtime_error
363	p_throw_runtime_error:
364		BL p_print_string
365		MOV r0, #-1
366		BL exit
367	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/advanced/hashTable.wacc
-- Test: hashTable.wacc

-- Uploaded file: 
---------------------------------------------------------------
# This program is interactive. We implement a hash table containing integers and we play with it.
# 
# A hash table is represented by an array of node lists. Each node in a node list is represented 
# by pair(int, pair). The first element of the pair is the integer at that node, the second element 
# is the pointer to the next node (or null if no more node). 
# 
# Integers those mapped to the same index are stored on the list (in any order) in that index.

begin

	######################### Functions for Hash Table Interface ###############################
	
	# Given a hash table, initialise it. Return true.
	bool init(pair(int, pair)[] table) is
		int length = len table ;
		int i = 0 ;
		while i < length do
			table[i] = null ; 
			i = i + 1
		done ;
		return true
	end

	# Returns true if and only if the given hash table contains x.
	bool contain(pair(int, pair)[] table, int x) is
		int index = call calculateIndex(table, x) ;
		pair(int, pair) node = call findNode(table[index], x) ;
		return node != null
	end
	
	# Insert the given x into the hash table if it does not already contain x.
	# Returns true if and only if the table does not already contain x.
	bool insertIfNotContain(pair(int, pair)[] table, int x) is
		int index = call calculateIndex(table, x) ;
		pair(int, pair) node = call findNode(table[index], x) ;
		if node != null then
			# Already contain it. Do nothing.
			return false
		else
			# Insert in the front of the list.
			pair(int, pair) p = newpair(x, table[index]) ;
			table[index] = p ;
			return true 
		fi
	end
	
	# Remove the given x from the hash table. Returns true if an only if the table contains x. 
	# Otherwise, do nothing and returns false.
	bool remove(pair(int, pair)[] table, int x) is
		int index = call calculateIndex(table, x) ;
		pair(int, pair) node = call findNode(table[index], x) ;
		if node == null then
			# Not found x. Just return false.
			return false
		else
			# Found x, have to remove the node.
			table[index] = call removeNode(table[index], node) ;
			return true
		fi
	end
	
	# Remove all nodes from the table. Returns true.
	bool removeAll(pair(int, pair)[] table) is
		int length = len table ;
		int i = 0 ;
		while i < length do
			pair(int, pair) p = table[i] ;
			while p != null do
				pair(int, pair) p2 = snd p ;
				free p ;
				p = p2
			done ;
			table[i] = null ;
			i = i + 1
		done ; 
		return true
	end
	
	# Count the number of integers in the table and return it.
	int count(pair(int, pair)[] table) is
		int length = len table ;
		int sum = 0 ;
		int i = 0 ;
		while i < length do
			int subSum = call countNodes(table[i]) ;
			sum = sum + subSum ;
			i = i + 1
		done ;
		return sum
	end
	
	# Print all the integers inside the table, separated by a space and ended with a newline. Returns true.
	bool printAll(pair(int, pair)[] table) is
		int length = len table ;
		int i = 0 ;
		while i < length do
      bool result = call printAllNodes(table[i]) ;
			i = i + 1
		done ;
		println "" ;
		return true
	end
		
	# A helper function.
	# Given a hash table and an integer, calculate the index of the integer in the table.
	int calculateIndex(pair(int, pair)[] table, int x) is
		int length = len table ;
		return x % length
	end
	
	# A helper function.
	# Given a head of a chain of nodes, returns the first node containing the value x.
	# Returns null if no such node.
	pair(int, pair) findNode(pair(int, pair) head, int x) is
		while head != null do
			int y = fst head ;
			if y == x then
				return head
			else
				head = snd head
			fi 
		done ;
		return null
	end

	# A helper function.
	# Given a list of nodes and a node to remove, remove that node from the 
	# list and return the new list.
	pair(int, pair) removeNode(pair(int, pair) head, pair(int, pair) toRemove) is
		if head == null then
			# Should not happen actually.
			return null
		else
			if head == toRemove then
				# Save the new head.
				head = snd head ;
				
				# Deallocate the memory of the old node.
				free toRemove ;
				
				# Return the new head.
				return head
			else
				# Not this node, recursive.
				pair(int, pair) tail = snd head ;
				snd head = call removeNode(tail, toRemove) ;
				return head
			fi
		fi
	end

	# A helper function.
	# Given a list of nodes, count how many nodes there are.
	int countNodes(pair(int, pair) head) is 
		int sum = 0 ;
		while head != null do
			sum = sum + 1 ;
			head = snd head
		done ;
		return sum
	end

	# A helper function.
	# Given a list of nodes, print each integer in the node followed by a space. Returns true.
	bool printAllNodes(pair(int, pair) head) is
    while head != null do
			int x = fst head ;
			print x ;
			print ' ' ;
			head = snd head
		done ;
		return true
	end

	######################### Functions for Command Line Interface ###############################
	
	# Print the menu and ask to choose. Returns a valid decision.
	char printMenu() is
		println "===========================================" ;
		println "========== Hash Table Program =============" ;
		println "===========================================" ;
		println "=                                         =" ;
		println "= Please choose the following options:    =" ;
		println "=                                         =" ;
		println "= a: insert an integer                    =" ;
		println "= b: find an integer                      =" ;
		println "= c: count the integers                   =" ;
		println "= d: print all integers                   =" ;
		println "= e: remove an integer                    =" ;
		println "= f: remove all integers                  =" ;
		println "= g: exit                                 =" ;
		println "=                                         =" ;
		println "===========================================" ;
		
		int minChoice = ord 'a' ;
		int maxChoice = ord 'g' ;
		
		while true do
			print   "Your decision: " ;
			char d = '\0' ;
			read d ;
			int dInt = ord d ;
			if minChoice <= dInt && dInt <= maxChoice then
				return d
			else 
				print "You have entered: " ;
				print d ;
				println " which is invalid, please try again."
			fi
		done ;
		# The compiler is not smart enough to know that this never reaches. 
		# We have to add a return statement here.
		return '\0'
	end
	
	# Print out the question, and then read an integer. After that print the integer back and return it.
	int askForInt(string message) is
		print message ;
		int x = 0 ;
		read x ;
		print "You have entered: " ;
		println x ;
		return x
	end
	
	# Handle menu insert. Returns true.
	bool handleMenuInsert(pair(int, pair)[] table) is
		int x = call askForInt("Please enter an integer to insert: ") ;
		bool notContain = call insertIfNotContain(table, x) ;
		if notContain then
			println "Successfully insert it. The integer is new." 
		else 
			println "The integer is already there. No insertion is made."
		fi ;
		return true		
	end
	
	# Handle menu find. Returns true.
	bool handleMenuFind(pair(int, pair)[] table) is
		int x = call askForInt("Please enter an integer to find: ") ;
		bool find = call contain(table, x) ;
		if find then
			println "Find the integer." 
		else 
			println "The integer is not found."
		fi ;
		return true		
	end
	
	# Handle menu count. Returns true.
	bool handleMenuCount(pair(int, pair)[] table) is
		int size = call count(table) ;
		if size == 1 then
			println "There is only 1 integer."
		else
			print "There are " ;
			print size ;
			println " integers."
		fi ; 
		return true
	end
	
	# Handle menu print. Returns true.
	bool handleMenuPrint(pair(int, pair)[] table) is
		print "Here are the integers: " ;
		bool junk = call printAll(table) ;
		return true
	end
	
	# Handle menu remove. Returns true.
	bool handleMenuRemove(pair(int, pair)[] table) is
		int x = call askForInt("Please enter an integer to remove: ") ;
		bool find = call remove(table, x) ;
		if find then
			println "The integer has been removed." 
		else 
			println "The integer is not found."
		fi ;
		return true		
	end
	
	# Handle menu remove all. Returns true.
	bool handleMenuRemoveAll(pair(int, pair)[] table) is
		bool junk = call removeAll(table) ; 
		println "All integers have been removed." ; 
		return true
	end
	
	################################# The main function ########################################
	# Our hash table of size 13.
	pair(int, pair)[] table = [null, null, null, null, null, null, null, null, null, null, null, null, null] ;
	bool junk = call init(table) ;
	
	bool continue = true ;
	while continue do
		char choice = call printMenu() ;
		if choice == 'a' then
			bool result = call handleMenuInsert(table)
		else if choice == 'b' then
			bool result = call handleMenuFind(table)
		else if choice == 'c' then
			bool result = call handleMenuCount(table)
		else if choice == 'd' then
			bool result = call handleMenuPrint(table)
		else if choice == 'e' then
			bool result = call handleMenuRemove(table)
		else if choice == 'f' then
			bool result = call handleMenuRemoveAll(table)
		else if choice == 'g' then
			println "Goodbye Human" ;
			continue = false
		else
			# Should not happen.
			print "Error: unknown choice (" ;
			print choice ;
			println ")" ;
			exit -1
		fi fi fi fi fi fi fi
	done
	
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
hashTable.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 0
4		.ascii	""
5	msg_1:
6		.word 43
7		.ascii	"==========================================="
8	msg_2:
9		.word 43
10		.ascii	"========== Hash Table Program ============="
11	msg_3:
12		.word 43
13		.ascii	"==========================================="
14	msg_4:
15		.word 43
16		.ascii	"=                                         ="
17	msg_5:
18		.word 43
19		.ascii	"= Please choose the following options:    ="
20	msg_6:
21		.word 43
22		.ascii	"=                                         ="
23	msg_7:
24		.word 43
25		.ascii	"= a: insert an integer                    ="
26	msg_8:
27		.word 43
28		.ascii	"= b: find an integer                      ="
29	msg_9:
30		.word 43
31		.ascii	"= c: count the integers                   ="
32	msg_10:
33		.word 43
34		.ascii	"= d: print all integers                   ="
35	msg_11:
36		.word 43
37		.ascii	"= e: remove an integer                    ="
38	msg_12:
39		.word 43
40		.ascii	"= f: remove all integers                  ="
41	msg_13:
42		.word 43
43		.ascii	"= g: exit                                 ="
44	msg_14:
45		.word 43
46		.ascii	"=                                         ="
47	msg_15:
48		.word 43
49		.ascii	"==========================================="
50	msg_16:
51		.word 15
52		.ascii	"Your decision: "
53	msg_17:
54		.word 18
55		.ascii	"You have entered: "
56	msg_18:
57		.word 36
58		.ascii	" which is invalid, please try again."
59	msg_19:
60		.word 18
61		.ascii	"You have entered: "
62	msg_20:
63		.word 35
64		.ascii	"Please enter an integer to insert: "
65	msg_21:
66		.word 43
67		.ascii	"Successfully insert it. The integer is new."
68	msg_22:
69		.word 51
70		.ascii	"The integer is already there. No insertion is made."
71	msg_23:
72		.word 33
73		.ascii	"Please enter an integer to find: "
74	msg_24:
75		.word 17
76		.ascii	"Find the integer."
77	msg_25:
78		.word 25
79		.ascii	"The integer is not found."
80	msg_26:
81		.word 24
82		.ascii	"There is only 1 integer."
83	msg_27:
84		.word 10
85		.ascii	"There are "
86	msg_28:
87		.word 10
88		.ascii	" integers."
89	msg_29:
90		.word 23
91		.ascii	"Here are the integers: "
92	msg_30:
93		.word 35
94		.ascii	"Please enter an integer to remove: "
95	msg_31:
96		.word 29
97		.ascii	"The integer has been removed."
98	msg_32:
99		.word 25
100		.ascii	"The integer is not found."
101	msg_33:
102		.word 31
103		.ascii	"All integers have been removed."
104	msg_34:
105		.word 13
106		.ascii	"Goodbye Human"
107	msg_35:
108		.word 23
109		.ascii	"Error: unknown choice ("
110	msg_36:
111		.word 1
112		.ascii	")"
113	msg_37:
114		.word 44
115		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
116	msg_38:
117		.word 45
118		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
119	msg_39:
120		.word 82
121		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
122	msg_40:
123		.word 50
124		.ascii	"NullReferenceError: dereference a null reference\n\0"
125	msg_41:
126		.word 50
127		.ascii	"NullReferenceError: dereference a null reference\n\0"
128	msg_42:
129		.word 5
130		.ascii	"%.*s\0"
131	msg_43:
132		.word 1
133		.ascii	"\0"
134	msg_44:
135		.word 45
136		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
137	msg_45:
138		.word 3
139		.ascii	"%d\0"
140	msg_46:
141		.word 4
142		.ascii	" %c\0"
143	msg_47:
144		.word 3
145		.ascii	"%d\0"
146	
147	.text
148	
149	.global main
150	f_init:
151		PUSH {lr}
152		SUB sp, sp, #8
153		LDR r4, [sp, #12]
154		LDR r4, [r4]
155		STR r4, [sp, #4]
156		LDR r4, =0
157		STR r4, [sp]
158		B L0
159	L1:
160		LDR r4, =0
161		ADD r5, sp, #12
162		LDR r6, [sp]
163		LDR r5, [r5]
164		MOV r0, r6
165		MOV r1, r5
166		BL p_check_array_bounds
167		ADD r5, r5, #4
168		ADD r5, r5, r6, LSL #2
169		STR r4, [r5]
170		LDR r4, [sp]
171		LDR r6, =1
172		ADDS r4, r4, r6
173		BLVS p_throw_overflow_error
174		STR r4, [sp]
175	L0:
176		LDR r4, [sp]
177		LDR r6, [sp, #4]
178		CMP r4, r6
179		MOVLT r4, #1
180		MOVGE r4, #0
181		CMP r4, #1
182		BEQ L1
183		MOV r4, #1
184		MOV r0, r4
185		ADD sp, sp, #8
186		POP {pc}
187		POP {pc}
188		.ltorg
189	f_contain:
190		PUSH {lr}
191		SUB sp, sp, #8
192		LDR r4, [sp, #16]
193		STR r4, [sp, #-4]!
194		LDR r4, [sp, #16]
195		STR r4, [sp, #-4]!
196		BL f_calculateIndex
197		ADD sp, sp, #8
198		MOV r4, r0
199		STR r4, [sp, #4]
200		LDR r4, [sp, #16]
201		STR r4, [sp, #-4]!
202		ADD r4, sp, #16
203		LDR r5, [sp, #8]
204		LDR r4, [r4]
205		MOV r0, r5
206		MOV r1, r4
207		BL p_check_array_bounds
208		ADD r4, r4, #4
209		ADD r4, r4, r5, LSL #2
210		LDR r4, [r4]
211		STR r4, [sp, #-4]!
212		BL f_findNode
213		ADD sp, sp, #8
214		MOV r4, r0
215		STR r4, [sp]
216		LDR r4, [sp]
217		LDR r5, =0
218		CMP r4, r5
219		MOVNE r4, #1
220		MOVEQ r4, #0
221		MOV r0, r4
222		ADD sp, sp, #8
223		POP {pc}
224		POP {pc}
225		.ltorg
226	f_insertIfNotContain:
227		PUSH {lr}
228		SUB sp, sp, #8
229		LDR r4, [sp, #16]
230		STR r4, [sp, #-4]!
231		LDR r4, [sp, #16]
232		STR r4, [sp, #-4]!
233		BL f_calculateIndex
234		ADD sp, sp, #8
235		MOV r4, r0
236		STR r4, [sp, #4]
237		LDR r4, [sp, #16]
238		STR r4, [sp, #-4]!
239		ADD r4, sp, #16
240		LDR r5, [sp, #8]
241		LDR r4, [r4]
242		MOV r0, r5
243		MOV r1, r4
244		BL p_check_array_bounds
245		ADD r4, r4, #4
246		ADD r4, r4, r5, LSL #2
247		LDR r4, [r4]
248		STR r4, [sp, #-4]!
249		BL f_findNode
250		ADD sp, sp, #8
251		MOV r4, r0
252		STR r4, [sp]
253		LDR r4, [sp]
254		LDR r5, =0
255		CMP r4, r5
256		MOVNE r4, #1
257		MOVEQ r4, #0
258		CMP r4, #0
259		BEQ L2
260		MOV r4, #0
261		MOV r0, r4
262		ADD sp, sp, #8
263		POP {pc}
264		B L3
265	L2:
266		SUB sp, sp, #4
267		LDR r0, =8
268		BL malloc
269		MOV r4, r0
270		LDR r5, [sp, #20]
271		LDR r0, =4
272		BL malloc
273		STR r5, [r0]
274		STR r0, [r4]
275		ADD r5, sp, #16
276		LDR r6, [sp, #8]
277		LDR r5, [r5]
278		MOV r0, r6
279		MOV r1, r5
280		BL p_check_array_bounds
281		ADD r5, r5, #4
282		ADD r5, r5, r6, LSL #2
283		LDR r5, [r5]
284		LDR r0, =4
285		BL malloc
286		STR r5, [r0]
287		STR r0, [r4, #4]
288		STR r4, [sp]
289		LDR r4, [sp]
290		ADD r5, sp, #16
291		LDR r6, [sp, #8]
292		LDR r5, [r5]
293		MOV r0, r6
294		MOV r1, r5
295		BL p_check_array_bounds
296		ADD r5, r5, #4
297		ADD r5, r5, r6, LSL #2
298		STR r4, [r5]
299		MOV r4, #1
300		MOV r0, r4
301		ADD sp, sp, #12
302		POP {pc}
303		ADD sp, sp, #4
304	L3:
305		POP {pc}
306		.ltorg
307	f_remove:
308		PUSH {lr}
309		SUB sp, sp, #8
310		LDR r4, [sp, #16]
311		STR r4, [sp, #-4]!
312		LDR r4, [sp, #16]
313		STR r4, [sp, #-4]!
314		BL f_calculateIndex
315		ADD sp, sp, #8
316		MOV r4, r0
317		STR r4, [sp, #4]
318		LDR r4, [sp, #16]
319		STR r4, [sp, #-4]!
320		ADD r4, sp, #16
321		LDR r5, [sp, #8]
322		LDR r4, [r4]
323		MOV r0, r5
324		MOV r1, r4
325		BL p_check_array_bounds
326		ADD r4, r4, #4
327		ADD r4, r4, r5, LSL #2
328		LDR r4, [r4]
329		STR r4, [sp, #-4]!
330		BL f_findNode
331		ADD sp, sp, #8
332		MOV r4, r0
333		STR r4, [sp]
334		LDR r4, [sp]
335		LDR r5, =0
336		CMP r4, r5
337		MOVEQ r4, #1
338		MOVNE r4, #0
339		CMP r4, #0
340		BEQ L4
341		MOV r4, #0
342		MOV r0, r4
343		ADD sp, sp, #8
344		POP {pc}
345		B L5
346	L4:
347		LDR r4, [sp]
348		STR r4, [sp, #-4]!
349		ADD r4, sp, #16
350		LDR r5, [sp, #8]
351		LDR r4, [r4]
352		MOV r0, r5
353		MOV r1, r4
354		BL p_check_array_bounds
355		ADD r4, r4, #4
356		ADD r4, r4, r5, LSL #2
357		LDR r4, [r4]
358		STR r4, [sp, #-4]!
359		BL f_removeNode
360		ADD sp, sp, #8
361		MOV r4, r0
362		ADD r5, sp, #12
363		LDR r6, [sp, #4]
364		LDR r5, [r5]
365		MOV r0, r6
366		MOV r1, r5
367		BL p_check_array_bounds
368		ADD r5, r5, #4
369		ADD r5, r5, r6, LSL #2
370		STR r4, [r5]
371		MOV r4, #1
372		MOV r0, r4
373		ADD sp, sp, #8
374		POP {pc}
375	L5:
376		POP {pc}
377		.ltorg
378	f_removeAll:
379		PUSH {lr}
380		SUB sp, sp, #8
381		LDR r4, [sp, #12]
382		LDR r4, [r4]
383		STR r4, [sp, #4]
384		LDR r4, =0
385		STR r4, [sp]
386		B L6
387	L7:
388		SUB sp, sp, #4
389		ADD r4, sp, #16
390		LDR r5, [sp, #4]
391		LDR r4, [r4]
392		MOV r0, r5
393		MOV r1, r4
394		BL p_check_array_bounds
395		ADD r4, r4, #4
396		ADD r4, r4, r5, LSL #2
397		LDR r4, [r4]
398		STR r4, [sp]
399		B L8
400	L9:
401		SUB sp, sp, #4
402		LDR r4, [sp, #4]
403		MOV r0, r4
404		BL p_check_null_pointer
405		LDR r4, [r4, #4]
406		LDR r4, [r4]
407		STR r4, [sp]
408		LDR r4, [sp, #4]
409		MOV r0, r4
410		BL p_free_pair
411		LDR r4, [sp]
412		STR r4, [sp, #4]
413		ADD sp, sp, #4
414	L8:
415		LDR r4, [sp]
416		LDR r5, =0
417		CMP r4, r5
418		MOVNE r4, #1
419		MOVEQ r4, #0
420		CMP r4, #1
421		BEQ L9
422		LDR r4, =0
423		ADD r5, sp, #16
424		LDR r6, [sp, #4]
425		LDR r5, [r5]
426		MOV r0, r6
427		MOV r1, r5
428		BL p_check_array_bounds
429		ADD r5, r5, #4
430		ADD r5, r5, r6, LSL #2
431		STR r4, [r5]
432		LDR r4, [sp, #4]
433		LDR r6, =1
434		ADDS r4, r4, r6
435		BLVS p_throw_overflow_error
436		STR r4, [sp, #4]
437		ADD sp, sp, #4
438	L6:
439		LDR r4, [sp]
440		LDR r6, [sp, #4]
441		CMP r4, r6
442		MOVLT r4, #1
443		MOVGE r4, #0
444		CMP r4, #1
445		BEQ L7
446		MOV r4, #1
447		MOV r0, r4
448		ADD sp, sp, #8
449		POP {pc}
450		POP {pc}
451		.ltorg
452	f_count:
453		PUSH {lr}
454		SUB sp, sp, #12
455		LDR r4, [sp, #16]
456		LDR r4, [r4]
457		STR r4, [sp, #8]
458		LDR r4, =0
459		STR r4, [sp, #4]
460		LDR r4, =0
461		STR r4, [sp]
462		B L10
463	L11:
464		SUB sp, sp, #4
465		ADD r4, sp, #20
466		LDR r5, [sp, #4]
467		LDR r4, [r4]
468		MOV r0, r5
469		MOV r1, r4
470		BL p_check_array_bounds
471		ADD r4, r4, #4
472		ADD r4, r4, r5, LSL #2
473		LDR r4, [r4]
474		STR r4, [sp, #-4]!
475		BL f_countNodes
476		ADD sp, sp, #4
477		MOV r4, r0
478		STR r4, [sp]
479		LDR r4, [sp, #8]
480		LDR r5, [sp]
481		ADDS r4, r4, r5
482		BLVS p_throw_overflow_error
483		STR r4, [sp, #8]
484		LDR r4, [sp, #4]
485		LDR r5, =1
486		ADDS r4, r4, r5
487		BLVS p_throw_overflow_error
488		STR r4, [sp, #4]
489		ADD sp, sp, #4
490	L10:
491		LDR r4, [sp]
492		LDR r5, [sp, #8]
493		CMP r4, r5
494		MOVLT r4, #1
495		MOVGE r4, #0
496		CMP r4, #1
497		BEQ L11
498		LDR r4, [sp, #4]
499		MOV r0, r4
500		ADD sp, sp, #12
501		POP {pc}
502		POP {pc}
503		.ltorg
504	f_printAll:
505		PUSH {lr}
506		SUB sp, sp, #8
507		LDR r4, [sp, #12]
508		LDR r4, [r4]
509		STR r4, [sp, #4]
510		LDR r4, =0
511		STR r4, [sp]
512		B L12
513	L13:
514		SUB sp, sp, #1
515		ADD r4, sp, #13
516		LDR r5, [sp, #1]
517		LDR r4, [r4]
518		MOV r0, r5
519		MOV r1, r4
520		BL p_check_array_bounds
521		ADD r4, r4, #4
522		ADD r4, r4, r5, LSL #2
523		LDR r4, [r4]
524		STR r4, [sp, #-4]!
525		BL f_printAllNodes
526		ADD sp, sp, #4
527		MOV r4, r0
528		STRB r4, [sp]
529		LDR r4, [sp, #1]
530		LDR r5, =1
531		ADDS r4, r4, r5
532		BLVS p_throw_overflow_error
533		STR r4, [sp, #1]
534		ADD sp, sp, #1
535	L12:
536		LDR r4, [sp]
537		LDR r5, [sp, #4]
538		CMP r4, r5
539		MOVLT r4, #1
540		MOVGE r4, #0
541		CMP r4, #1
542		BEQ L13
543		LDR r4, =msg_0
544		MOV r0, r4
545		BL p_print_string
546		BL p_print_ln
547		MOV r4, #1
548		MOV r0, r4
549		ADD sp, sp, #8
550		POP {pc}
551		POP {pc}
552		.ltorg
553	f_calculateIndex:
554		PUSH {lr}
555		SUB sp, sp, #4
556		LDR r4, [sp, #8]
557		LDR r4, [r4]
558		STR r4, [sp]
559		LDR r4, [sp, #12]
560		LDR r5, [sp]
561		MOV r0, r4
562		MOV r1, r5
563		BL p_check_divide_by_zero
564		BL __aeabi_idivmod
565		MOV r4, r1
566		MOV r0, r4
567		ADD sp, sp, #4
568		POP {pc}
569		POP {pc}
570		.ltorg
571	f_findNode:
572		PUSH {lr}
573		B L14
574	L15:
575		SUB sp, sp, #4
576		LDR r4, [sp, #8]
577		MOV r0, r4
578		BL p_check_null_pointer
579		LDR r4, [r4]
580		LDR r4, [r4]
581		STR r4, [sp]
582		LDR r4, [sp]
583		LDR r5, [sp, #12]
584		CMP r4, r5
585		MOVEQ r4, #1
586		MOVNE r4, #0
587		CMP r4, #0
588		BEQ L16
589		LDR r4, [sp, #8]
590		MOV r0, r4
591		ADD sp, sp, #4
592		POP {pc}
593		B L17
594	L16:
595		LDR r4, [sp, #8]
596		MOV r0, r4
597		BL p_check_null_pointer
598		LDR r4, [r4, #4]
599		LDR r4, [r4]
600		STR r4, [sp, #8]
601	L17:
602		ADD sp, sp, #4
603	L14:
604		LDR r4, [sp, #4]
605		LDR r5, =0
606		CMP r4, r5
607		MOVNE r4, #1
608		MOVEQ r4, #0
609		CMP r4, #1
610		BEQ L15
611		LDR r4, =0
612		MOV r0, r4
613		POP {pc}
614		POP {pc}
615		.ltorg
616	f_removeNode:
617		PUSH {lr}
618		LDR r4, [sp, #4]
619		LDR r5, =0
620		CMP r4, r5
621		MOVEQ r4, #1
622		MOVNE r4, #0
623		CMP r4, #0
624		BEQ L18
625		LDR r4, =0
626		MOV r0, r4
627		POP {pc}
628		B L19
629	L18:
630		LDR r4, [sp, #4]
631		LDR r5, [sp, #8]
632		CMP r4, r5
633		MOVEQ r4, #1
634		MOVNE r4, #0
635		CMP r4, #0
636		BEQ L20
637		LDR r4, [sp, #4]
638		MOV r0, r4
639		BL p_check_null_pointer
640		LDR r4, [r4, #4]
641		LDR r4, [r4]
642		STR r4, [sp, #4]
643		LDR r4, [sp, #8]
644		MOV r0, r4
645		BL p_free_pair
646		LDR r4, [sp, #4]
647		MOV r0, r4
648		POP {pc}
649		B L21
650	L20:
651		SUB sp, sp, #4
652		LDR r4, [sp, #8]
653		MOV r0, r4
654		BL p_check_null_pointer
655		LDR r4, [r4, #4]
656		LDR r4, [r4]
657		STR r4, [sp]
658		LDR r4, [sp, #12]
659		STR r4, [sp, #-4]!
660		LDR r4, [sp, #4]
661		STR r4, [sp, #-4]!
662		BL f_removeNode
663		ADD sp, sp, #8
664		MOV r4, r0
665		LDR r5, [sp, #8]
666		MOV r0, r5
667		BL p_check_null_pointer
668		LDR r5, [r5, #4]
669		STR r4, [r5]
670		LDR r4, [sp, #8]
671		MOV r0, r4
672		ADD sp, sp, #4
673		POP {pc}
674		ADD sp, sp, #4
675	L21:
676	L19:
677		POP {pc}
678		.ltorg
679	f_countNodes:
680		PUSH {lr}
681		SUB sp, sp, #4
682		LDR r4, =0
683		STR r4, [sp]
684		B L22
685	L23:
686		LDR r4, [sp]
687		LDR r5, =1
688		ADDS r4, r4, r5
689		BLVS p_throw_overflow_error
690		STR r4, [sp]
691		LDR r4, [sp, #8]
692		MOV r0, r4
693		BL p_check_null_pointer
694		LDR r4, [r4, #4]
695		LDR r4, [r4]
696		STR r4, [sp, #8]
697	L22:
698		LDR r4, [sp, #8]
699		LDR r5, =0
700		CMP r4, r5
701		MOVNE r4, #1
702		MOVEQ r4, #0
703		CMP r4, #1
704		BEQ L23
705		LDR r4, [sp]
706		MOV r0, r4
707		ADD sp, sp, #4
708		POP {pc}
709		POP {pc}
710		.ltorg
711	f_printAllNodes:
712		PUSH {lr}
713		B L24
714	L25:
715		SUB sp, sp, #4
716		LDR r4, [sp, #8]
717		MOV r0, r4
718		BL p_check_null_pointer
719		LDR r4, [r4]
720		LDR r4, [r4]
721		STR r4, [sp]
722		LDR r4, [sp]
723		MOV r0, r4
724		BL p_print_int
725		MOV r4, #' '
726		MOV r0, r4
727		BL putchar
728		LDR r4, [sp, #8]
729		MOV r0, r4
730		BL p_check_null_pointer
731		LDR r4, [r4, #4]
732		LDR r4, [r4]
733		STR r4, [sp, #8]
734		ADD sp, sp, #4
735	L24:
736		LDR r4, [sp, #4]
737		LDR r5, =0
738		CMP r4, r5
739		MOVNE r4, #1
740		MOVEQ r4, #0
741		CMP r4, #1
742		BEQ L25
743		MOV r4, #1
744		MOV r0, r4
745		POP {pc}
746		POP {pc}
747		.ltorg
748	f_printMenu:
749		PUSH {lr}
750		SUB sp, sp, #8
751		LDR r4, =msg_1
752		MOV r0, r4
753		BL p_print_string
754		BL p_print_ln
755		LDR r4, =msg_2
756		MOV r0, r4
757		BL p_print_string
758		BL p_print_ln
759		LDR r4, =msg_3
760		MOV r0, r4
761		BL p_print_string
762		BL p_print_ln
763		LDR r4, =msg_4
764		MOV r0, r4
765		BL p_print_string
766		BL p_print_ln
767		LDR r4, =msg_5
768		MOV r0, r4
769		BL p_print_string
770		BL p_print_ln
771		LDR r4, =msg_6
772		MOV r0, r4
773		BL p_print_string
774		BL p_print_ln
775		LDR r4, =msg_7
776		MOV r0, r4
777		BL p_print_string
778		BL p_print_ln
779		LDR r4, =msg_8
780		MOV r0, r4
781		BL p_print_string
782		BL p_print_ln
783		LDR r4, =msg_9
784		MOV r0, r4
785		BL p_print_string
786		BL p_print_ln
787		LDR r4, =msg_10
788		MOV r0, r4
789		BL p_print_string
790		BL p_print_ln
791		LDR r4, =msg_11
792		MOV r0, r4
793		BL p_print_string
794		BL p_print_ln
795		LDR r4, =msg_12
796		MOV r0, r4
797		BL p_print_string
798		BL p_print_ln
799		LDR r4, =msg_13
800		MOV r0, r4
801		BL p_print_string
802		BL p_print_ln
803		LDR r4, =msg_14
804		MOV r0, r4
805		BL p_print_string
806		BL p_print_ln
807		LDR r4, =msg_15
808		MOV r0, r4
809		BL p_print_string
810		BL p_print_ln
811		MOV r4, #'a'
812		STR r4, [sp, #4]
813		MOV r4, #'g'
814		STR r4, [sp]
815		B L26
816	L27:
817		SUB sp, sp, #5
818		LDR r4, =msg_16
819		MOV r0, r4
820		BL p_print_string
821		MOV r4, #0
822		STRB r4, [sp, #4]
823		ADD r4, sp, #4
824		MOV r0, r4
825		BL p_read_char
826		LDRSB r4, [sp, #4]
827		STR r4, [sp]
828		LDR r4, [sp, #9]
829		LDR r5, [sp]
830		CMP r4, r5
831		MOVLE r4, #1
832		MOVGT r4, #0
833		LDR r5, [sp]
834		LDR r6, [sp, #5]
835		CMP r5, r6
836		MOVLE r5, #1
837		MOVGT r5, #0
838		AND r4, r4, r5
839		CMP r4, #0
840		BEQ L28
841		LDRSB r4, [sp, #4]
842		MOV r0, r4
843		ADD sp, sp, #13
844		POP {pc}
845		B L29
846	L28:
847		LDR r4, =msg_17
848		MOV r0, r4
849		BL p_print_string
850		LDRSB r4, [sp, #4]
851		MOV r0, r4
852		BL putchar
853		LDR r4, =msg_18
854		MOV r0, r4
855		BL p_print_string
856		BL p_print_ln
857	L29:
858		ADD sp, sp, #5
859	L26:
860		MOV r4, #1
861		CMP r4, #1
862		BEQ L27
863		MOV r4, #0
864		MOV r0, r4
865		ADD sp, sp, #8
866		POP {pc}
867		POP {pc}
868		.ltorg
869	f_askForInt:
870		PUSH {lr}
871		SUB sp, sp, #4
872		LDR r4, [sp, #8]
873		MOV r0, r4
874		BL p_print_string
875		LDR r4, =0
876		STR r4, [sp]
877		ADD r4, sp, #0
878		MOV r0, r4
879		BL p_read_int
880		LDR r4, =msg_19
881		MOV r0, r4
882		BL p_print_string
883		LDR r4, [sp]
884		MOV r0, r4
885		BL p_print_int
886		BL p_print_ln
887		LDR r4, [sp]
888		MOV r0, r4
889		ADD sp, sp, #4
890		POP {pc}
891		POP {pc}
892		.ltorg
893	f_handleMenuInsert:
894		PUSH {lr}
895		SUB sp, sp, #5
896		LDR r4, =msg_20
897		STR r4, [sp, #-4]!
898		BL f_askForInt
899		ADD sp, sp, #4
900		MOV r4, r0
901		STR r4, [sp, #1]
902		LDR r4, [sp, #1]
903		STR r4, [sp, #-4]!
904		LDR r4, [sp, #13]
905		STR r4, [sp, #-4]!
906		BL f_insertIfNotContain
907		ADD sp, sp, #8
908		MOV r4, r0
909		STRB r4, [sp]
910		LDRSB r4, [sp]
911		CMP r4, #0
912		BEQ L30
913		LDR r4, =msg_21
914		MOV r0, r4
915		BL p_print_string
916		BL p_print_ln
917		B L31
918	L30:
919		LDR r4, =msg_22
920		MOV r0, r4
921		BL p_print_string
922		BL p_print_ln
923	L31:
924		MOV r4, #1
925		MOV r0, r4
926		ADD sp, sp, #5
927		POP {pc}
928		POP {pc}
929		.ltorg
930	f_handleMenuFind:
931		PUSH {lr}
932		SUB sp, sp, #5
933		LDR r4, =msg_23
934		STR r4, [sp, #-4]!
935		BL f_askForInt
936		ADD sp, sp, #4
937		MOV r4, r0
938		STR r4, [sp, #1]
939		LDR r4, [sp, #1]
940		STR r4, [sp, #-4]!
941		LDR r4, [sp, #13]
942		STR r4, [sp, #-4]!
943		BL f_contain
944		ADD sp, sp, #8
945		MOV r4, r0
946		STRB r4, [sp]
947		LDRSB r4, [sp]
948		CMP r4, #0
949		BEQ L32
950		LDR r4, =msg_24
951		MOV r0, r4
952		BL p_print_string
953		BL p_print_ln
954		B L33
955	L32:
956		LDR r4, =msg_25
957		MOV r0, r4
958		BL p_print_string
959		BL p_print_ln
960	L33:
961		MOV r4, #1
962		MOV r0, r4
963		ADD sp, sp, #5
964		POP {pc}
965		POP {pc}
966		.ltorg
967	f_handleMenuCount:
968		PUSH {lr}
969		SUB sp, sp, #4
970		LDR r4, [sp, #8]
971		STR r4, [sp, #-4]!
972		BL f_count
973		ADD sp, sp, #4
974		MOV r4, r0
975		STR r4, [sp]
976		LDR r4, [sp]
977		LDR r5, =1
978		CMP r4, r5
979		MOVEQ r4, #1
980		MOVNE r4, #0
981		CMP r4, #0
982		BEQ L34
983		LDR r4, =msg_26
984		MOV r0, r4
985		BL p_print_string
986		BL p_print_ln
987		B L35
988	L34:
989		LDR r4, =msg_27
990		MOV r0, r4
991		BL p_print_string
992		LDR r4, [sp]
993		MOV r0, r4
994		BL p_print_int
995		LDR r4, =msg_28
996		MOV r0, r4
997		BL p_print_string
998		BL p_print_ln
999	L35:
1000		MOV r4, #1
1001		MOV r0, r4
1002		ADD sp, sp, #4
1003		POP {pc}
1004		POP {pc}
1005		.ltorg
1006	f_handleMenuPrint:
1007		PUSH {lr}
1008		SUB sp, sp, #1
1009		LDR r4, =msg_29
1010		MOV r0, r4
1011		BL p_print_string
1012		LDR r4, [sp, #5]
1013		STR r4, [sp, #-4]!
1014		BL f_printAll
1015		ADD sp, sp, #4
1016		MOV r4, r0
1017		STRB r4, [sp]
1018		MOV r4, #1
1019		MOV r0, r4
1020		ADD sp, sp, #1
1021		POP {pc}
1022		POP {pc}
1023		.ltorg
1024	f_handleMenuRemove:
1025		PUSH {lr}
1026		SUB sp, sp, #5
1027		LDR r4, =msg_30
1028		STR r4, [sp, #-4]!
1029		BL f_askForInt
1030		ADD sp, sp, #4
1031		MOV r4, r0
1032		STR r4, [sp, #1]
1033		LDR r4, [sp, #1]
1034		STR r4, [sp, #-4]!
1035		LDR r4, [sp, #13]
1036		STR r4, [sp, #-4]!
1037		BL f_remove
1038		ADD sp, sp, #8
1039		MOV r4, r0
1040		STRB r4, [sp]
1041		LDRSB r4, [sp]
1042		CMP r4, #0
1043		BEQ L36
1044		LDR r4, =msg_31
1045		MOV r0, r4
1046		BL p_print_string
1047		BL p_print_ln
1048		B L37
1049	L36:
1050		LDR r4, =msg_32
1051		MOV r0, r4
1052		BL p_print_string
1053		BL p_print_ln
1054	L37:
1055		MOV r4, #1
1056		MOV r0, r4
1057		ADD sp, sp, #5
1058		POP {pc}
1059		POP {pc}
1060		.ltorg
1061	f_handleMenuRemoveAll:
1062		PUSH {lr}
1063		SUB sp, sp, #1
1064		LDR r4, [sp, #5]
1065		STR r4, [sp, #-4]!
1066		BL f_removeAll
1067		ADD sp, sp, #4
1068		MOV r4, r0
1069		STRB r4, [sp]
1070		LDR r4, =msg_33
1071		MOV r0, r4
1072		BL p_print_string
1073		BL p_print_ln
1074		MOV r4, #1
1075		MOV r0, r4
1076		ADD sp, sp, #1
1077		POP {pc}
1078		POP {pc}
1079		.ltorg
1080	main:
1081		PUSH {lr}
1082		SUB sp, sp, #6
1083		LDR r0, =56
1084		BL malloc
1085		MOV r4, r0
1086		LDR r5, =0
1087		STR r5, [r4, #4]
1088		LDR r5, =0
1089		STR r5, [r4, #8]
1090		LDR r5, =0
1091		STR r5, [r4, #12]
1092		LDR r5, =0
1093		STR r5, [r4, #16]
1094		LDR r5, =0
1095		STR r5, [r4, #20]
1096		LDR r5, =0
1097		STR r5, [r4, #24]
1098		LDR r5, =0
1099		STR r5, [r4, #28]
1100		LDR r5, =0
1101		STR r5, [r4, #32]
1102		LDR r5, =0
1103		STR r5, [r4, #36]
1104		LDR r5, =0
1105		STR r5, [r4, #40]
1106		LDR r5, =0
1107		STR r5, [r4, #44]
1108		LDR r5, =0
1109		STR r5, [r4, #48]
1110		LDR r5, =0
1111		STR r5, [r4, #52]
1112		LDR r5, =13
1113		STR r5, [r4]
1114		STR r4, [sp, #2]
1115		LDR r4, [sp, #2]
1116		STR r4, [sp, #-4]!
1117		BL f_init
1118		ADD sp, sp, #4
1119		MOV r4, r0
1120		STRB r4, [sp, #1]
1121		MOV r4, #1
1122		STRB r4, [sp]
1123		B L38
1124	L39:
1125		SUB sp, sp, #1
1126		BL f_printMenu
1127		MOV r4, r0
1128		STRB r4, [sp]
1129		LDRSB r4, [sp]
1130		MOV r5, #'a'
1131		CMP r4, r5
1132		MOVEQ r4, #1
1133		MOVNE r4, #0
1134		CMP r4, #0
1135		BEQ L40
1136		SUB sp, sp, #1
1137		LDR r4, [sp, #4]
1138		STR r4, [sp, #-4]!
1139		BL f_handleMenuInsert
1140		ADD sp, sp, #4
1141		MOV r4, r0
1142		STRB r4, [sp]
1143		ADD sp, sp, #1
1144		B L41
1145	L40:
1146		LDRSB r4, [sp]
1147		MOV r5, #'b'
1148		CMP r4, r5
1149		MOVEQ r4, #1
1150		MOVNE r4, #0
1151		CMP r4, #0
1152		BEQ L42
1153		SUB sp, sp, #1
1154		LDR r4, [sp, #4]
1155		STR r4, [sp, #-4]!
1156		BL f_handleMenuFind
1157		ADD sp, sp, #4
1158		MOV r4, r0
1159		STRB r4, [sp]
1160		ADD sp, sp, #1
1161		B L43
1162	L42:
1163		LDRSB r4, [sp]
1164		MOV r5, #'c'
1165		CMP r4, r5
1166		MOVEQ r4, #1
1167		MOVNE r4, #0
1168		CMP r4, #0
1169		BEQ L44
1170		SUB sp, sp, #1
1171		LDR r4, [sp, #4]
1172		STR r4, [sp, #-4]!
1173		BL f_handleMenuCount
1174		ADD sp, sp, #4
1175		MOV r4, r0
1176		STRB r4, [sp]
1177		ADD sp, sp, #1
1178		B L45
1179	L44:
1180		LDRSB r4, [sp]
1181		MOV r5, #'d'
1182		CMP r4, r5
1183		MOVEQ r4, #1
1184		MOVNE r4, #0
1185		CMP r4, #0
1186		BEQ L46
1187		SUB sp, sp, #1
1188		LDR r4, [sp, #4]
1189		STR r4, [sp, #-4]!
1190		BL f_handleMenuPrint
1191		ADD sp, sp, #4
1192		MOV r4, r0
1193		STRB r4, [sp]
1194		ADD sp, sp, #1
1195		B L47
1196	L46:
1197		LDRSB r4, [sp]
1198		MOV r5, #'e'
1199		CMP r4, r5
1200		MOVEQ r4, #1
1201		MOVNE r4, #0
1202		CMP r4, #0
1203		BEQ L48
1204		SUB sp, sp, #1
1205		LDR r4, [sp, #4]
1206		STR r4, [sp, #-4]!
1207		BL f_handleMenuRemove
1208		ADD sp, sp, #4
1209		MOV r4, r0
1210		STRB r4, [sp]
1211		ADD sp, sp, #1
1212		B L49
1213	L48:
1214		LDRSB r4, [sp]
1215		MOV r5, #'f'
1216		CMP r4, r5
1217		MOVEQ r4, #1
1218		MOVNE r4, #0
1219		CMP r4, #0
1220		BEQ L50
1221		SUB sp, sp, #1
1222		LDR r4, [sp, #4]
1223		STR r4, [sp, #-4]!
1224		BL f_handleMenuRemoveAll
1225		ADD sp, sp, #4
1226		MOV r4, r0
1227		STRB r4, [sp]
1228		ADD sp, sp, #1
1229		B L51
1230	L50:
1231		LDRSB r4, [sp]
1232		MOV r5, #'g'
1233		CMP r4, r5
1234		MOVEQ r4, #1
1235		MOVNE r4, #0
1236		CMP r4, #0
1237		BEQ L52
1238		LDR r4, =msg_34
1239		MOV r0, r4
1240		BL p_print_string
1241		BL p_print_ln
1242		MOV r4, #0
1243		STRB r4, [sp, #1]
1244		B L53
1245	L52:
1246		LDR r4, =msg_35
1247		MOV r0, r4
1248		BL p_print_string
1249		LDRSB r4, [sp]
1250		MOV r0, r4
1251		BL putchar
1252		LDR r4, =msg_36
1253		MOV r0, r4
1254		BL p_print_string
1255		BL p_print_ln
1256		LDR r4, =-1
1257		MOV r0, r4
1258		BL exit
1259	L53:
1260	L51:
1261	L49:
1262	L47:
1263	L45:
1264	L43:
1265	L41:
1266		ADD sp, sp, #1
1267	L38:
1268		LDRSB r4, [sp]
1269		CMP r4, #1
1270		BEQ L39
1271		ADD sp, sp, #6
1272		LDR r0, =0
1273		POP {pc}
1274		.ltorg
1275	p_check_array_bounds:
1276		PUSH {lr}
1277		CMP r0, #0
1278		LDRLT r0, =msg_37
1279		BLLT p_throw_runtime_error
1280		LDR r1, [r1]
1281		CMP r0, r1
1282		LDRCS r0, =msg_38
1283		BLCS p_throw_runtime_error
1284		POP {pc}
1285	p_throw_overflow_error:
1286		LDR r0, =msg_39
1287		BL p_throw_runtime_error
1288	p_check_null_pointer:
1289		PUSH {lr}
1290		CMP r0, #0
1291		LDREQ r0, =msg_40
1292		BLEQ p_throw_runtime_error
1293		POP {pc}
1294	p_free_pair:
1295		PUSH {lr}
1296		CMP r0, #0
1297		LDREQ r0, =msg_41
1298		BEQ p_throw_runtime_error
1299		PUSH {r0}
1300		LDR r0, [r0]
1301		BL free
1302		LDR r0, [sp]
1303		LDR r0, [r0, #4]
1304		BL free
1305		POP {r0}
1306		BL free
1307		POP {pc}
1308	p_print_string:
1309		PUSH {lr}
1310		LDR r1, [r0]
1311		ADD r2, r0, #4
1312		LDR r0, =msg_42
1313		ADD r0, r0, #4
1314		BL printf
1315		MOV r0, #0
1316		BL fflush
1317		POP {pc}
1318	p_print_ln:
1319		PUSH {lr}
1320		LDR r0, =msg_43
1321		ADD r0, r0, #4
1322		BL puts
1323		MOV r0, #0
1324		BL fflush
1325		POP {pc}
1326	p_check_divide_by_zero:
1327		PUSH {lr}
1328		CMP r1, #0
1329		LDREQ r0, =msg_44
1330		BLEQ p_throw_runtime_error
1331		POP {pc}
1332	p_print_int:
1333		PUSH {lr}
1334		MOV r1, r0
1335		LDR r0, =msg_45
1336		ADD r0, r0, #4
1337		BL printf
1338		MOV r0, #0
1339		BL fflush
1340		POP {pc}
1341	p_read_char:
1342		PUSH {lr}
1343		MOV r1, r0
1344		LDR r0, =msg_46
1345		ADD r0, r0, #4
1346		BL scanf
1347		POP {pc}
1348	p_read_int:
1349		PUSH {lr}
1350		MOV r1, r0
1351		LDR r0, =msg_47
1352		ADD r0, r0, #4
1353		BL scanf
1354		POP {pc}
1355	p_throw_runtime_error:
1356		BL p_print_string
1357		MOV r0, #-1
1358		BL exit
1359	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/advanced/ticTacToe.wacc
-- Test: ticTacToe.wacc

-- Uploaded file: 
---------------------------------------------------------------
# This is a program that allows a human to play Tic Tac Toe with a smart AI. 
# The AI is implemented using minimax approach. The AI is a perfect one, meaning 
# that it will never lose and if there is an immediate win, it will play that. 
#
# It takes quite a long time to initialise and free up the memory for the AI. 
# All observed bugs have been fixed.
#
# In this program, we are very often need the memory from the heap. 
# But because a pair is the only data type allocated on the heap, 
# we have to use it. We very often need a data structure to store 
# a set of 3 objects. We will use the format below. 
# 
#  root --\
#         |
#        \|/
#          
#  +----------+----------+
#  |          |          |
#  |  front   | object 3 |
#  |          |          |
#  +----------+----------+ 
#       |
#       |
#      \|/
#          
#  +----------+----------+
#  |          |          |
#  | object 1 | object 2 |
#  |          |          |
#  +----------+----------+ 
# 
# We call this structure Pair4Three.

# Program:

begin
	
	############################## Interface Functions ######################
	
	# Print greeting message and ask the player to choose their symbol.
	# Return either 'x' or 'o'. 'x' plays first.
	char chooseSymbol() is
		println "========= Tic Tac Toe ================" ;
		println "=  Because we know you want to win   =" ;
		println "======================================" ;
		println "=                                    =" ;
		println "= Who would you like to be?          =" ;
		println "=   x  (play first)                  =" ;
		println "=   o  (play second)                 =" ;
		println "=   q  (quit)                        =" ;
		println "=                                    =" ;
		println "======================================" ;
		
		char chosen = '\0' ;
		while chosen == '\0' do 
			print "Which symbol you would like to choose: " ;
			char c = '\0' ;
			read c ;
			if c == 'x' || c == 'X' then
				chosen = 'x'
			else
				if c == 'o' || c == 'O' then
					chosen = 'o'
				else
					if c == 'q' || c == 'Q' then
						println "Goodbye safety." ;
						exit 0
					else
						print "Invalid symbol: " ;
						println c ;
						println "Please try again."
					fi 
				fi
			fi
		done ;
		print "You have chosen: " ;
		println chosen ;
		return chosen
	end
	
	# Print the board out to the screen.
	bool printBoard(pair(pair, pair) board) is
		pair(pair, pair) front = fst board ;
		pair(pair, char) row1 = fst front ;
		pair(pair, char) row2 = snd front ;
		pair(pair, char) row3 = snd board ;
	
    println " 1 2 3";
    print "1";	
		bool _ = call printRow(row1) ;
		println " -+-+-" ;
    print "2";	
		_ = call printRow(row2) ;
		println " -+-+-" ;
    print "3";	
		_ = call printRow(row3) ;
		println "";
		return true 
	end
	
	# Print a row with a newline to the screen.
	bool printRow(pair(pair, char) row) is
		pair(char, char) front = fst row ;
		
		char cell1 = fst front ;
		char cell2 = snd front ;
		char cell3 = snd row ;
		
		bool _ = call printCell(cell1) ;
		print '|' ;
		_ = call printCell(cell2) ;
		print '|' ;
		_ = call printCell(cell3) ;
		println "" ;
		return true
	end 
	
	# Print a given cell. Print an empty space if it is empty. Return true.
	bool printCell(char cell) is
		if cell == '\0' then
			print ' ' 
		else
			print cell 
		fi ;
		return true
	end
	
	# Ask for a move from the human player. The valid move is then stored in the given move array. 
	# The row number is stored at move[0], the column number is stored at move[1]. Return true.
	bool askForAMoveHuman(pair(pair, pair) board, int[] move) is
		bool success = false ;
		int row = 0 ;
		int column = 0 ;
			
		while !success do
			println "What is your next move?" ;
			print " row (1-3): " ;
			read row ;
			print " column (1-3): " ;
			read column ; 
			success = call validateMove(board, row, column) ;
			
			if success then
				println "" ; # Just print out an empty line
				move[0] = row ;
				move[1] = column ;
				return true
			else
				println "Your move is invalid. Please try again."
			fi			
		done ; 
		# Should not reach here
		return true
	end
	
	# Validate that the give move is valid. Returns true iff it is valid.
	bool validateMove(pair(pair, pair) board, int moveRow, int moveColumn) is
		if 1 <= moveRow && moveRow <= 3 && 1 <= moveColumn && moveColumn <= 3 then
			char sym = call symbolAt(board, moveRow, moveColumn) ;
			# Make sure that the cell is empty
			return sym == '\0'
		else
			return false
		fi
	end
	
	# Print out to the screen about a recent move maid by the AI. Return true.
	bool notifyMoveHuman(pair(pair, pair) board, char currentTurn, char playerSymbol, int moveRow, int moveColumn) is
		print "The AI played at row " ;
		print moveRow ;
		print " column " ;
		println moveColumn ;
		return true
	end
	
	############################### AI Functions #########################################
	
	# Initialise an AI data.
	pair(pair, pair) initAI(char aiSymbol) is
		
		pair(char, pair) info = newpair(aiSymbol, null) ; # Don't know yet how to use the second element.
 		pair(pair, int) stateTree = call generateAllPossibleStates(aiSymbol) ;
		int value = call setValuesForAllStates(stateTree, aiSymbol, 'x') ;
		
		pair(pair, pair) aiData = newpair(info, stateTree) ;
		return aiData
	end
	
	# Generate the whole tree of all states. Then return the tree.
	pair(pair, int) generateAllPossibleStates(char aiSymbol) is
		pair(pair, pair) board = call allocateNewBoard() ;
		pair(pair, int) rootState = call convertFromBoardToState(board) ;
		rootState = call generateNextStates(rootState, 'x') ;
		return rootState
	end
	
	# Convert from a board to a state.
	# A state consists of 3 objects: the board, the pointers to the next states, and the value for this state (int).
	# Therefore, we use the Pair4Three structure.
	pair(pair, int) convertFromBoardToState(pair(pair, pair) board) is
		
		pair(pair, pair) pointers = call generateEmptyPointerBoard() ;
		pair(pair, pair) front = newpair(board, pointers) ;
		pair(pair, int) state = newpair(front, 0) ; # The initial value of 0 will be replaced.
		
		return state
	end
	
	# Allocate memory for the pointers to the next state.
	# It looks like a board, but contains pointers (pairs) instead of chars.
	pair(pair, pair) generateEmptyPointerBoard() is
		
		pair(pair, pair) row1 = call generateEmptyPointerRow() ;
		pair(pair, pair) row2 = call generateEmptyPointerRow() ;
		pair(pair, pair) row3 = call generateEmptyPointerRow() ;
		
		pair(pair, pair) front = newpair(row1, row2) ;
		pair(pair, pair) root = newpair(front, row3) ;
		return root
		
	end
	
	# Allocate memory for the 3 pointers to the next state of a row.
	pair(pair, pair) generateEmptyPointerRow() is
		pair(pair, pair) front = newpair(null, null) ;
		pair(pair, pair) root = newpair(front, null) ;
		return root 
	end
	
	# Generate next states recursively. Returns the state.
	pair(pair, int) generateNextStates(pair(pair, int) state, char currentPlayer) is
		pair(pair, pair) front = fst state ;
		
		pair(pair, pair) board = fst front ;
		pair(pair, pair) pointers = snd front ;
		
		char previousPlayer = call oppositeSymbol(currentPlayer) ;
		
		bool won = call hasWon(board, previousPlayer) ;
		
		if won then
			# The game ends. The winner is known.
			return state 
		else
			bool _ = call generateNextStatesBoard(board, pointers, currentPlayer) ;
			return state
		fi
		
	end
	
	# Generate Just the next states for every possible point on the board. Update the pointers accordingly. Return true.
	bool generateNextStatesBoard(pair(pair, pair) board, pair(pair, pair) pointers, char currentPlayer) is
		pair(pair, pair) front = fst board ;
		
		pair(pair, char) row1 = fst front ;
		pair(pair, char) row2 = snd front ;
		pair(pair, char) row3 = snd board ;
		
		pair(pair, pair) frontP = fst pointers ;
		
		pair(pair, pair) row1P = fst frontP ;
		pair(pair, pair) row2P = snd frontP ;
		pair(pair, pair) row3P = snd pointers ;
		
		bool _ = call generateNextStatesRow(board, row1, row1P, currentPlayer, 1) ;
		_ = call generateNextStatesRow(board, row2, row2P, currentPlayer, 2) ;
		_ = call generateNextStatesRow(board, row3, row3P, currentPlayer, 3) ;
		
		return true
	end
	
	# Generate Just the next states for every possible point on the row. Update the pointers accordingly. Return true.
	bool generateNextStatesRow(pair(pair, pair) board, pair(pair, char) row, pair(pair, pair) pointerRow, char currentPlayer, int rowNumber) is
		pair(char, char) front = fst row ;
		
		char cell1 = fst front ;
		char cell2 = snd front ;
		char cell3 = snd row ;
		
		pair(pair, pair) frontP = fst pointerRow ;
		
		fst frontP = call generateNextStatesCell(board, cell1, currentPlayer, rowNumber, 1) ;
		snd frontP = call generateNextStatesCell(board, cell2, currentPlayer, rowNumber, 2) ;
		snd pointerRow = call generateNextStatesCell(board, cell3, currentPlayer, rowNumber, 3) ;
		
		return true
	end
	
	# Generate Just the next states for the cell on the board. Returns the pointer to the next state.
	pair(pair, int) generateNextStatesCell(pair(pair, pair) board, char cell, char currentPlayer, int rowNumber, int columnNumber) is
		if cell == '\0' then
			# If the cell is empty, generate the next state.
			pair(pair, pair) board2 = call cloneBoard(board) ;
			bool _ = call placeMove(board2, currentPlayer, rowNumber, columnNumber) ;
			pair(pair, int) state = call convertFromBoardToState(board2) ;
			char nextPlayer = call oppositeSymbol(currentPlayer) ;
			
			# Generate next states recursively and return it out.
			state = call generateNextStates(state, nextPlayer) ;
			return state
		else
			# If the cell is not empty, return null.
			return null
		fi
	end
	
	# Clone board.
	pair(pair, pair) cloneBoard(pair(pair, pair) board) is
		pair(pair, pair) board2 = call allocateNewBoard() ; 
		bool _ = call copyBoard(board, board2) ;
		return board2 
	end
	
	# Copy the content of one board to another. Return true.
	bool copyBoard(pair(pair, pair) from, pair(pair, pair) to) is
		pair(pair, pair) frontFrom = fst from ;
		pair(pair, char) row1From = fst frontFrom ;
		pair(pair, char) row2From = snd frontFrom ;
		pair(pair, char) row3From = snd from ;
		
		pair(pair, pair) frontTo = fst to ;
		pair(pair, char) row1To = fst frontTo ;
		pair(pair, char) row2To = snd frontTo ;
		pair(pair, char) row3To = snd to ;
				
		bool _ = call copyRow(row1From, row1To) ;		
		_ = call copyRow(row2From, row2To) ;
		_ = call copyRow(row3From, row3To) ;
				
		return true
	end
	
	# Copy from one board row to another. Return true.
	bool copyRow(pair(pair, char) from, pair(pair, char) to) is
		pair(char, char) frontFrom = fst from ;
		pair(char, char) frontTo = fst to ;
		
		fst frontTo = fst frontFrom ;
		snd frontTo = snd frontFrom ;
		snd to = snd from ;
		return true
	end
	
	# Calculate the value of how good each state is using Minimax approach. 
	# If AI wins, value = 100.
	# If AI lose, value = -100.
	# If Stalemate, value = 0.
	# Otherwise, combine the values from the next states.
	# If this state is null, then return -101 if it is a max state, 101 if it is a min state (thus those values will not be picked).
	# Return the value.
	int setValuesForAllStates(pair(pair, int) state, char aiSymbol, char currentPlayer) is
		int outValue = 0 ;
		if state == null then
			# The current state is impossible to reach.
			# Assign a value that will not be picked in the future.
			if currentPlayer == aiSymbol then
				# Later on, we will pick the lowest value (min). So we set this value high so that it will not be picked.
				outValue = 101
			else
				# Later on, we will pick the highest value (max). So we set this value low so that it will not be picked.
				outValue = -101
			fi
		else 
		
			pair(pair, pair) front = fst state ;
			
			pair(pair, pair) board = fst front ;
			pair(pair, pair) pointers = snd front ;
			
			char anotherPlayer = call oppositeSymbol(currentPlayer) ;
			
			# The current player is about to play. So if another player has won it already, the current player cannot play it.
			bool won = call hasWon(board, anotherPlayer) ;
		
			if won then
				if anotherPlayer == aiSymbol then
					outValue = 100 # We won
				else
					outValue = -100 # We lost
				fi 
			else
				bool hasEmptyCell = call containEmptyCell(board) ;
				if hasEmptyCell then
					# If can do next move, calculate the value from the next states.
					outValue = call calculateValuesFromNextStates(pointers, aiSymbol, anotherPlayer) ;
					
					# In order for the AI to choose the winning move immediately, we have to reduce the value for those not winning yet.
					# So if the next move has value 100, we set the value of this move 90.
					if outValue == 100 then
						outValue = 90 
					else
						skip
					fi
				else
					# Otherwise, it is a stalemate.
					outValue = 0 
				fi 
			fi ;
			snd state = outValue
		fi ;
		return outValue
	end
	
	# Calculate the values for each next state, then combine them to get the value of this state. Return the value.
	int calculateValuesFromNextStates(pair(pair, pair) pointers, char aiSymbol, char playerOfNextState) is
		pair(pair, pair) front = fst pointers ;
		
		pair(pair, pair) row1 = fst front ;
		pair(pair, pair) row2 = snd front ;
		pair(pair, pair) row3 = snd pointers ;
		
		int value1 = call calculateValuesFromNextStatesRow(row1, aiSymbol, playerOfNextState) ;
		int value2 = call calculateValuesFromNextStatesRow(row2, aiSymbol, playerOfNextState) ;
		int value3 = call calculateValuesFromNextStatesRow(row3, aiSymbol, playerOfNextState) ;
		
		int out = call combineValue(aiSymbol, playerOfNextState, value1, value2, value3) ;
		return out
	end
	
	# Calculate the values for each next state in a row, then combine them to get the value of this row. Return the value.
	int calculateValuesFromNextStatesRow(pair(pair, pair) rowPointers, char aiSymbol, char playerOfNextState) is
		pair(pair, pair) front = fst rowPointers ;
		
		pair(pair, int) state1 = fst front ;
		pair(pair, int) state2 = snd front ; 
		pair(pair, int) state3 = snd rowPointers ;
		
		int value1 = call setValuesForAllStates(state1, aiSymbol, playerOfNextState) ;
		int value2 = call setValuesForAllStates(state2, aiSymbol, playerOfNextState) ;
		int value3 = call setValuesForAllStates(state3, aiSymbol, playerOfNextState) ;
		
		int out = call combineValue(aiSymbol, playerOfNextState, value1, value2, value3) ;
		return out
	end
	
	int combineValue(char aiSymbol, char playerOfNextState, int value1, int value2, int value3) is
		int out = 0 ;
		if aiSymbol == playerOfNextState then
			# We move next so the human moves now. Pick the lowest value.
			out = call min3(value1, value2, value3)
		else
			# Human moves next so we move now. Pick the highest value.
			out = call max3(value1, value2, value3)
		fi ;
		return out
	end
	
	# Find the minimum of the three.
	int min3(int a, int b, int c) is
		if a < b then
			if a < c then
				return a 
			else 
				return c
			fi
		else
			if b < c then
				return b
			else 
				return c
			fi
		fi
	end
	
	# Find the maximum of the three.
	int max3(int a, int b, int c) is
		if a > b then
			if a > c then
				return a 
			else 
				return c
			fi
		else
			if b > c then
				return b
			else 
				return c
			fi
		fi
	end
	
	# Destroy all memory used by the AI. Return true.
	bool destroyAI(pair(pair, pair) aiData) is
		
		pair(char, pair) info = fst aiData ;
 		pair(pair, int) stateTree = snd aiData ;

		bool _ = call deleteStateTreeRecursively(stateTree) ;
		free info ;
		free aiData ;
		return true
	end
	
	# Ask the AI for a new move. Return true.
	bool askForAMoveAI(pair(pair, pair) board, char currentTurn, char playerSymbol, pair(pair, pair) aiData, int[] move) is
		
		pair(char, pair) info = fst aiData ;
 		pair(pair, int) stateTree = snd aiData ;
		
		pair(pair, pair) front = fst stateTree ;
		
		pair(pair, pair) pointers = snd front ;
		int stateValue = snd stateTree ;
		
		bool _ = call findTheBestMove(pointers, stateValue, move) ;		
		
		println "AI is cleaning up its memory..." ;
		# Update the state tree by using the new move.
		snd aiData = call deleteAllOtherChildren(pointers, move[0], move[1]) ;
	
		_ = call deleteThisStateOnly(stateTree) ;
		return true
	end
	
	# Given the pointers to all next states, pick the first one with the given stateValue and store the move in the the given array.
	# Return true. 
	bool findTheBestMove(pair(pair, pair) pointers, int stateValue, int[] move) is

		# We have a hack by changing the state value to 90 if the next state is 100. 
		# So if we have a state value of 90, look for the one with 100 first.
		# If found, use it. Otherwise, look for the one with 90.
		if stateValue == 90 then
			bool found = call findMoveWithGivenValue(pointers, 100, move) ;
			if found then
				return true
			else
				skip
			fi
		else
			skip
		fi ;
		
		# Normal case. Or when cannot find the child with 100.
		bool found = call findMoveWithGivenValue(pointers, stateValue, move) ;
		if found then
			return true
		else
			# Should not happen. Cannot find such move.
			println "Internal Error: cannot find the next move for the AI" ;
			exit -1
		fi
		
	end

	# Given the pointers to all next states, pick the first one with the given stateValue and store the move in the the given array.
	# Return true in this case. Otherwise, the move array is untouched and return false. 
	bool findMoveWithGivenValue(pair(pair, pair) pointers, int stateValue, int[] move) is
		pair(pair, pair) front = fst pointers ;
		
		pair(pair, pair) row1 = fst front ;
		pair(pair, pair) row2 = snd front ; 
		pair(pair, pair) row3 = snd pointers ;
		
		bool find = call findMoveWithGivenValueRow(row1, stateValue, move) ;
		if find then
			move[0] = 1
		else
			find = call findMoveWithGivenValueRow(row2, stateValue, move) ;
			if find then
				move[0] = 2
			else
				find = call findMoveWithGivenValueRow(row3, stateValue, move) ;
				if find then
					move[0] = 3
				else
					# Not found, return false.
					return false
				fi
			fi
		fi ;
		return true
	end
	
	# Given a row of pointers, pick the first one with the given stateValue and store in move[1], return true if such child state is found. Otherwise, return false and move[1] is untouched.
	bool findMoveWithGivenValueRow(pair(pair, pair) rowPointers, int stateValue, int[] move) is
		
		pair(pair, pair) front = fst rowPointers ;
		
		pair(pair, int) cell1 = fst front ;
		pair(pair, int) cell2 = snd front ;
		pair(pair, int) cell3 = snd rowPointers ;
		
		bool find = call hasGivenStateValue(cell1, stateValue) ;
		if find then
			move[1] = 1
		else
			find = call hasGivenStateValue(cell2, stateValue) ;
			if find then
				move[1] = 2 
			else 
				find = call hasGivenStateValue(cell3, stateValue) ;
				if find then
					move[1] = 3
				else 
					return false
				fi
			fi
		fi ;
		return true
	end
	
	# Given a state, an a state value. Returns true iff the state has the given state value.
	bool hasGivenStateValue(pair(pair, int) state, int stateValue) is
		if state == null then
			return false
		else
			int actual = snd state ;
			return actual == stateValue
		fi
	end
	
	# Notify a move made by a human player to the AI. Return true.
	bool notifyMoveAI(pair(pair, pair) board, char currentTurn, char playerSymbol, pair(pair, pair) aiData, int moveRow, int moveColumn) is
		
		#pair(char, pair) info = fst aiData ; #unused
		pair(pair, int) stateTree = snd aiData ;
		
		pair(pair, pair) front = fst stateTree ;
		
		#pair(pair, pair) board = fst front ; #unused
		pair(pair, pair) pointers = snd front ;
		
		println "AI is cleaning up its memory..." ;
		
		# Set new state tree, remove all other children created by making other moves.
		snd aiData = call deleteAllOtherChildren(pointers, moveRow, moveColumn) ;
		bool _ = call deleteThisStateOnly(stateTree) ;
		return true
	end
	
	# Delete all decendent states apart from those made by moving a given move. Return the child state of that given move.
	pair(pair, int) deleteAllOtherChildren(pair(pair, pair) pointers, int moveRow, int moveColumn) is
		pair(pair, pair) front = fst pointers ;
		
		pair(pair, pair) row1 = fst front ;
		pair(pair, pair) row2 = snd front ;
		pair(pair, pair) row3 = snd pointers ;

		# Find which row to keep or which rows to delete.
		pair(pair, pair) toKeepRow = null;
		pair(pair, pair) toDeleteRow1 = null;
		pair(pair, pair) toDeleteRow2 = null;
		
		if moveRow == 1 then
			toKeepRow = row1 ; 
			toDeleteRow1 = row2 ; 
			toDeleteRow2 = row3
		else 
			toDeleteRow1 = row1 ;
			if moveRow == 2 then
				toKeepRow = row2 ; 
				toDeleteRow2 = row3
			else
				# moveRow == 3
				toKeepRow = row3 ; 
				toDeleteRow2 = row2
			fi
		fi ;
		
		pair(pair, int) out = call deleteAllOtherChildrenRow(toKeepRow, moveColumn) ;
		bool _ = call deleteChildrenStateRecursivelyRow(toDeleteRow1) ;
		_ = call deleteChildrenStateRecursivelyRow(toDeleteRow2) ;
		
		return out
	end
	
	pair(pair, int) deleteAllOtherChildrenRow(pair(pair, pair) rowPointers, int moveColumn) is
		pair(pair, pair) front = fst rowPointers ;
		
		pair(pair, int) cell1 = fst front ;
		pair(pair, int) cell2 = snd front ;
		pair(pair, int) cell3 = snd rowPointers ;

		# Find which cell to keep or which cells to delete.
		pair(pair, int) toKeepCell = null;
		pair(pair, int) toDeleteCell1 = null;
		pair(pair, int) toDeleteCell2 = null;
		
		if moveColumn == 1 then
			toKeepCell = cell1 ; 
			toDeleteCell1 = cell2 ; 
			toDeleteCell2 = cell3
		else 
			toDeleteCell1 = cell1 ;
			if moveColumn == 2 then
				toKeepCell = cell2 ; 
				toDeleteCell2 = cell3
			else
				# moveColumn == 3
				toKeepCell = cell3 ; 
				toDeleteCell2 = cell2
			fi
		fi ;
		
		bool _ = call deleteStateTreeRecursively(toDeleteCell1) ;
		_ = call deleteStateTreeRecursively(toDeleteCell2) ;
		
		return toKeepCell
	end
	
	# Deallocate a given state and all its decendents.
	bool deleteStateTreeRecursively(pair(pair, int) stateTree) is
		if stateTree == null then
			return true 
		else
			pair(pair, pair) front = fst stateTree ;
			
			pair(pair, pair) board = fst front ;
			pair(pair, pair) pointers = snd front ;
			
			bool _ = call deleteChildrenStateRecursively(pointers) ;
			_ = call deleteThisStateOnly(stateTree) ;
			return true
		fi		
	end
	
	# Given a state tree, deallocate the board, the pointers and the other pairs of this state only. The childrens are preserved. Return true.
	bool deleteThisStateOnly(pair(pair, int) stateTree) is	
		pair(pair, pair) front = fst stateTree ;
		
		pair(pair, pair) board = fst front ;
		pair(pair, pair) pointers = snd front ;

		bool _ = call freeBoard(board) ;
		_ = call freePointers(pointers) ;
		free front ;
		free stateTree ;
		return true
	end
	
	bool freePointers(pair(pair, pair) pointers) is
		pair(pair, pair) front = fst pointers ;
		
		pair(pair, pair) row1 = fst front ;
		pair(pair, pair) row2 = snd front ;
		pair(pair, pair) row3 = snd pointers ;
		
		bool _ = call freePointersRow(row1) ;
		_ = call freePointersRow(row2) ;
		_ = call freePointersRow(row3) ;
		
		free front ;
		free pointers ;
		return true
	end
	
	bool freePointersRow(pair(pair, pair) rowPointers) is
		pair(pair, pair) front = fst rowPointers ;
		
		free front ;
		free rowPointers ;
		return true
	end
	
	# Deallocate all decendent states.
	bool deleteChildrenStateRecursively(pair(pair, pair) pointers) is
		pair(pair, pair) front = fst pointers ;
		
		pair(pair, pair) row1 = fst front ;
		pair(pair, pair) row2 = snd front ;
		pair(pair, pair) row3 = snd pointers ;
		
		bool _ = call deleteChildrenStateRecursivelyRow(row1) ;
		_ = call deleteChildrenStateRecursivelyRow(row2) ;
		_ = call deleteChildrenStateRecursivelyRow(row3) ;
		
		return true
	end
	
	# Deallocate all decendent states given a row of pointers.
	bool deleteChildrenStateRecursivelyRow(pair(pair, pair) rowPointers) is
		pair(pair, pair) front = fst rowPointers ;
		pair(pair, int) cell1 = fst front ;
		pair(pair, int) cell2 = snd front ;
		pair(pair, int) cell3 = snd rowPointers ;
		
		bool _ = call deleteStateTreeRecursively(cell1) ;
		_ = call deleteStateTreeRecursively(cell2) ;
		_ = call deleteStateTreeRecursively(cell3) ;
		
		return true
	end
	
	############################### Game Engine Functions ##################################
	
	# Ask for a move from the current player. The valid move is stored in the move array. Return true.
	bool askForAMove(pair(pair, pair) board, char currentTurn, char playerSymbol, pair(pair, pair) aiData, int[] move) is
		if currentTurn == playerSymbol then
			bool _ = call askForAMoveHuman(board, move)
		else 
			bool _ = call askForAMoveAI(board, currentTurn, playerSymbol, aiData, move)
		fi ;
		return true
	end
	
	# Place the given move of the currentTurn in the board. Return true.
	bool placeMove(pair(pair, pair) board, char currentTurn, int moveRow, int moveColumn) is
		
		# Find the target row.
		pair(pair, char) targetRow = null ;
		if moveRow <= 2 then
			pair(pair, pair) front = fst board ;
			if moveRow == 1 then
				targetRow = fst front
			else
				# moveRow == 2
				targetRow = snd front
			fi
		else
			# moveRow == 3
			targetRow = snd board
		fi ;
		
		# Set the target cell
		if moveColumn <= 2 then
			pair(char, char) front = fst targetRow ;
			if moveColumn == 1 then
				fst front = currentTurn
			else
				# moveColumn == 2
				snd front = currentTurn
			fi
		else
			# moveColumn == 3
			snd targetRow = currentTurn
		fi ;
		return true
		
	end
	
	# Notify the opponent about a move of another party. Return true.
	bool notifyMove(pair(pair, pair) board, char currentTurn, char playerSymbol, pair(pair, pair) aiData, int moveRow, int moveColumn) is
		if currentTurn == playerSymbol then
			bool _ = call notifyMoveAI(board, currentTurn, playerSymbol, aiData, moveRow, moveColumn)
		else 
			bool _ = call notifyMoveHuman(board, currentTurn, playerSymbol, moveRow, moveColumn)
		fi ;
		return true
	end
	
	# Given either 'x' or 'o', returns another one.
	char oppositeSymbol(char symbol) is
		if symbol == 'x' then
			return 'o' 
		else
			if symbol == 'o' then
				return 'x'
			else
				# Should not happen!
				println "Internal Error: symbol given is neither \'x\' or \'o\'" ;
				exit -1 
			fi 
		fi
	end
	
	# row = 1, 2 or 3
	# column = 1, 2 or 3
	char symbolAt(pair(pair, pair) board, int row, int column) is
	
		# Find the target row.
		pair(pair, char) targetRow = null ;
		if row <= 2 then
			pair(pair, pair) front = fst board ;
			if row == 1 then
				targetRow = fst front
			else
				# row == 2
				targetRow = snd front
			fi
		else
			# row == 3
			targetRow = snd board
		fi ;
		
		# Now find the target cell.
		char targetCell = '\0' ;
		if column <= 2 then
			pair(char, char) front = fst targetRow ;
			if column == 1 then 
				targetCell = fst front 
			else
				# column == 2
				targetCell = snd front
			fi
		else
			# column == 3
			targetCell = snd targetRow
		fi ;
			
		return targetCell	
	end
	
	# Return true if there is at least one empty cell where the next player can place a move. Otherwise, return false (game ends).
	bool containEmptyCell(pair(pair, pair) board) is
		pair(pair, pair) front = fst board ;
		
		pair(pair, char) row1 = fst front ;
		pair(pair, char) row2 = snd front ;
		pair(pair, char) row3 = snd board ;
		
		bool row1ContainEmpty = call containEmptyCellRow(row1) ;
		bool row2ContainEmpty = call containEmptyCellRow(row2) ;
		bool row3ContainEmpty = call containEmptyCellRow(row3) ;
		
		return row1ContainEmpty || row2ContainEmpty || row3ContainEmpty
	end
	
	bool containEmptyCellRow(pair(pair, char) row) is
		pair(char, char) front = fst row ;
		
		char cell1 = fst front ;
		char cell2 = snd front ;
		char cell3 = snd row ;
		
		return cell1 == '\0' || cell2 == '\0' || cell3 == '\0'
	end
	
	# Find if the candidate symbol ('x' or 'o') has won the game.
	# Returns true if and only if it has won. 
	bool hasWon(pair(pair, pair) board, char candidate) is
		char c11 = call symbolAt(board, 1, 1) ;
		char c12 = call symbolAt(board, 1, 2) ;
		char c13 = call symbolAt(board, 1, 3) ;
		char c21 = call symbolAt(board, 2, 1) ;
		char c22 = call symbolAt(board, 2, 2) ;
		char c23 = call symbolAt(board, 2, 3) ;
		char c31 = call symbolAt(board, 3, 1) ;
		char c32 = call symbolAt(board, 3, 2) ;
		char c33 = call symbolAt(board, 3, 3) ;
		
		return 
			# Row win
			c11 == candidate && c12 == candidate && c13 == candidate ||
			c21 == candidate && c22 == candidate && c23 == candidate ||
			c31 == candidate && c32 == candidate && c33 == candidate ||
			 
			# Column win
			c11 == candidate && c21 == candidate && c31 == candidate ||
			c12 == candidate && c22 == candidate && c32 == candidate ||
			c13 == candidate && c23 == candidate && c33 == candidate ||
			
			# Diagonal win
			c11 == candidate && c22 == candidate && c33 == candidate ||
			c13 == candidate && c22 == candidate && c31 == candidate
	end
	
	# Allocate a new board. 
	# We use a Pair4Three structure to store pointers to the 3 rows.
	pair(pair, pair) allocateNewBoard() is
		pair(pair, char) row1 = call allocateNewRow() ;
		pair(pair, char) row2 = call allocateNewRow() ;
		pair(pair, char) row3 = call allocateNewRow() ;
		
		pair(pair, pair) front = newpair(row1, row2) ;
		pair(pair, pair) root = newpair(front, row3) ;
		return root
	end
	
	# Allocate a row of the board. 
	# A row is represented by a Pair4Three structure.
	# The default value in each cell is '\0'.
	pair(pair, char) allocateNewRow() is
		pair(char, char) front = newpair('\0', '\0') ;
		pair(pair, char) root = newpair(front, '\0') ;
		return root
	end

	# Free a memory used to store the whole board.
	# Return true.
	bool freeBoard(pair(pair, pair) board) is
		pair(pair, pair) front = fst board ;
		
		pair(pair, char) row1 = fst front ;
		pair(pair, char) row2 = snd front ;
		pair(pair, char) row3 = snd board ;
		
		bool _ = call freeRow(row1) ;
		_ = call freeRow(row2) ;
		_ = call freeRow(row3) ;
		
		free front ;
		free board ;
		return true
	end
	
	# Free the memory used for a row. Return true.
	bool freeRow(pair(pair, char) row) is
		pair(char, char) front = fst row ;
		free front ;
		free row ;
		return true
	end
	
	# For debugging purpose.
	bool printAiData(pair(pair, pair) aiData) is
		
		pair(char, pair) info = fst aiData ;
		pair(pair, int) stateTree = snd aiData ;
		
		bool _ = call printStateTreeRecursively(stateTree) ;
		exit 0
	end
	
	bool printStateTreeRecursively(pair(pair, int) stateTree) is
		if stateTree == null then
			return true 
		else 
			pair(pair, pair) front = fst stateTree ;
			
			pair(pair, pair) board = fst front ;
			pair(pair, pair) pointers = snd front ;
			int value = snd stateTree ;
			
			# Print the value
			print 'v' ;
			print '=' ;
			println value ;
			
			bool _ = call printBoard(board) ;
			_ = call printChildrenStateTree(pointers) ;
			
			println 'p' ;
			return true
		fi
	end
	
	bool printChildrenStateTree(pair(pair, pair) pointers) is
		pair(pair, pair) front = fst pointers ;
		
		pair(pair, pair) row1 = fst front ;
		pair(pair, pair) row2 = snd front ;
		pair(pair, pair) row3 = snd pointers ;
		
		bool _ = call printChildrenStateTreeRow(row1) ;
		_ = call printChildrenStateTreeRow(row2) ;
		_ = call printChildrenStateTreeRow(row3) ;
		return true
	end
	
	bool printChildrenStateTreeRow(pair(pair, pair) rowPointers) is
		pair(pair, pair) front = fst rowPointers ;
		
		pair(pair, int) cell1 = fst front ;
		pair(pair, int) cell2 = snd front ;
		pair(pair, int) cell3 = snd rowPointers ;
		
		bool _ = call printStateTreeRecursively(cell1) ;
		_ = call printStateTreeRecursively(cell2) ;
		_ = call printStateTreeRecursively(cell3) ;
		
		return true
	end
	
	############################## Main Function ############################
	
	char playerSymbol = call chooseSymbol() ;
	char aiSymbol = call oppositeSymbol(playerSymbol) ;
	char currentTurn = 'x' ;
	
	pair(pair, pair) board = call allocateNewBoard() ;
	
	println "Initialising AI. Please wait, this may take a few minutes." ;
	pair(pair, pair) aiData = call initAI(aiSymbol) ;
	
	int turnCount = 0 ;
	char winner = '\0' ;
	
	bool _ = call printBoard(board) ;
	
	while winner == '\0' && turnCount < 9 do
		int[] move = [0, 0] ;
		_ = call askForAMove(board, currentTurn, playerSymbol, aiData, move) ;
		_ = call placeMove(board, currentTurn, move[0], move[1]) ;
		_ = call notifyMove(board, currentTurn, playerSymbol, aiData, move[0], move[1]) ;
		_ = call printBoard(board) ;
		bool won = call hasWon(board, currentTurn) ;
		if won then
			winner = currentTurn
		else 
			skip
		fi ;
		
		# Progress to the next turn
		currentTurn = call oppositeSymbol(currentTurn) ;
		turnCount = turnCount + 1
	done ;
	
	_ = call freeBoard(board) ;
	_ = call destroyAI(aiData) ;
	
	if winner != '\0' then
		print winner ;
		println " has won!" 
	else 
		println "Stalemate!" 
	fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ticTacToe.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 38
4		.ascii	"========= Tic Tac Toe ================"
5	msg_1:
6		.word 38
7		.ascii	"=  Because we know you want to win   ="
8	msg_2:
9		.word 38
10		.ascii	"======================================"
11	msg_3:
12		.word 38
13		.ascii	"=                                    ="
14	msg_4:
15		.word 38
16		.ascii	"= Who would you like to be?          ="
17	msg_5:
18		.word 38
19		.ascii	"=   x  (play first)                  ="
20	msg_6:
21		.word 38
22		.ascii	"=   o  (play second)                 ="
23	msg_7:
24		.word 38
25		.ascii	"=   q  (quit)                        ="
26	msg_8:
27		.word 38
28		.ascii	"=                                    ="
29	msg_9:
30		.word 38
31		.ascii	"======================================"
32	msg_10:
33		.word 39
34		.ascii	"Which symbol you would like to choose: "
35	msg_11:
36		.word 15
37		.ascii	"Goodbye safety."
38	msg_12:
39		.word 16
40		.ascii	"Invalid symbol: "
41	msg_13:
42		.word 17
43		.ascii	"Please try again."
44	msg_14:
45		.word 17
46		.ascii	"You have chosen: "
47	msg_15:
48		.word 6
49		.ascii	" 1 2 3"
50	msg_16:
51		.word 1
52		.ascii	"1"
53	msg_17:
54		.word 6
55		.ascii	" -+-+-"
56	msg_18:
57		.word 1
58		.ascii	"2"
59	msg_19:
60		.word 6
61		.ascii	" -+-+-"
62	msg_20:
63		.word 1
64		.ascii	"3"
65	msg_21:
66		.word 0
67		.ascii	""
68	msg_22:
69		.word 0
70		.ascii	""
71	msg_23:
72		.word 23
73		.ascii	"What is your next move?"
74	msg_24:
75		.word 12
76		.ascii	" row (1-3): "
77	msg_25:
78		.word 15
79		.ascii	" column (1-3): "
80	msg_26:
81		.word 0
82		.ascii	""
83	msg_27:
84		.word 39
85		.ascii	"Your move is invalid. Please try again."
86	msg_28:
87		.word 21
88		.ascii	"The AI played at row "
89	msg_29:
90		.word 8
91		.ascii	" column "
92	msg_30:
93		.word 31
94		.ascii	"AI is cleaning up its memory..."
95	msg_31:
96		.word 52
97		.ascii	"Internal Error: cannot find the next move for the AI"
98	msg_32:
99		.word 31
100		.ascii	"AI is cleaning up its memory..."
101	msg_33:
102		.word 50
103		.ascii	"Internal Error: symbol given is neither \'x\' or \'o\'"
104	msg_34:
105		.word 58
106		.ascii	"Initialising AI. Please wait, this may take a few minutes."
107	msg_35:
108		.word 9
109		.ascii	" has won!"
110	msg_36:
111		.word 10
112		.ascii	"Stalemate!"
113	msg_37:
114		.word 5
115		.ascii	"%.*s\0"
116	msg_38:
117		.word 1
118		.ascii	"\0"
119	msg_39:
120		.word 4
121		.ascii	" %c\0"
122	msg_40:
123		.word 50
124		.ascii	"NullReferenceError: dereference a null reference\n\0"
125	msg_41:
126		.word 3
127		.ascii	"%d\0"
128	msg_42:
129		.word 44
130		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
131	msg_43:
132		.word 45
133		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
134	msg_44:
135		.word 3
136		.ascii	"%d\0"
137	msg_45:
138		.word 50
139		.ascii	"NullReferenceError: dereference a null reference\n\0"
140	msg_46:
141		.word 82
142		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
143	
144	.text
145	
146	.global main
147	f_chooseSymbol:
148		PUSH {lr}
149		SUB sp, sp, #1
150		LDR r4, =msg_0
151		MOV r0, r4
152		BL p_print_string
153		BL p_print_ln
154		LDR r4, =msg_1
155		MOV r0, r4
156		BL p_print_string
157		BL p_print_ln
158		LDR r4, =msg_2
159		MOV r0, r4
160		BL p_print_string
161		BL p_print_ln
162		LDR r4, =msg_3
163		MOV r0, r4
164		BL p_print_string
165		BL p_print_ln
166		LDR r4, =msg_4
167		MOV r0, r4
168		BL p_print_string
169		BL p_print_ln
170		LDR r4, =msg_5
171		MOV r0, r4
172		BL p_print_string
173		BL p_print_ln
174		LDR r4, =msg_6
175		MOV r0, r4
176		BL p_print_string
177		BL p_print_ln
178		LDR r4, =msg_7
179		MOV r0, r4
180		BL p_print_string
181		BL p_print_ln
182		LDR r4, =msg_8
183		MOV r0, r4
184		BL p_print_string
185		BL p_print_ln
186		LDR r4, =msg_9
187		MOV r0, r4
188		BL p_print_string
189		BL p_print_ln
190		MOV r4, #0
191		STRB r4, [sp]
192		B L0
193	L1:
194		SUB sp, sp, #1
195		LDR r4, =msg_10
196		MOV r0, r4
197		BL p_print_string
198		MOV r4, #0
199		STRB r4, [sp]
200		ADD r4, sp, #0
201		MOV r0, r4
202		BL p_read_char
203		LDRSB r4, [sp]
204		MOV r5, #'x'
205		CMP r4, r5
206		MOVEQ r4, #1
207		MOVNE r4, #0
208		LDRSB r5, [sp]
209		MOV r6, #'X'
210		CMP r5, r6
211		MOVEQ r5, #1
212		MOVNE r5, #0
213		ORR r4, r4, r5
214		CMP r4, #0
215		BEQ L2
216		MOV r4, #'x'
217		STRB r4, [sp, #1]
218		B L3
219	L2:
220		LDRSB r4, [sp]
221		MOV r5, #'o'
222		CMP r4, r5
223		MOVEQ r4, #1
224		MOVNE r4, #0
225		LDRSB r5, [sp]
226		MOV r6, #'O'
227		CMP r5, r6
228		MOVEQ r5, #1
229		MOVNE r5, #0
230		ORR r4, r4, r5
231		CMP r4, #0
232		BEQ L4
233		MOV r4, #'o'
234		STRB r4, [sp, #1]
235		B L5
236	L4:
237		LDRSB r4, [sp]
238		MOV r5, #'q'
239		CMP r4, r5
240		MOVEQ r4, #1
241		MOVNE r4, #0
242		LDRSB r5, [sp]
243		MOV r6, #'Q'
244		CMP r5, r6
245		MOVEQ r5, #1
246		MOVNE r5, #0
247		ORR r4, r4, r5
248		CMP r4, #0
249		BEQ L6
250		LDR r4, =msg_11
251		MOV r0, r4
252		BL p_print_string
253		BL p_print_ln
254		LDR r4, =0
255		MOV r0, r4
256		BL exit
257		B L7
258	L6:
259		LDR r4, =msg_12
260		MOV r0, r4
261		BL p_print_string
262		LDRSB r4, [sp]
263		MOV r0, r4
264		BL putchar
265		BL p_print_ln
266		LDR r4, =msg_13
267		MOV r0, r4
268		BL p_print_string
269		BL p_print_ln
270	L7:
271	L5:
272	L3:
273		ADD sp, sp, #1
274	L0:
275		LDRSB r4, [sp]
276		MOV r5, #0
277		CMP r4, r5
278		MOVEQ r4, #1
279		MOVNE r4, #0
280		CMP r4, #1
281		BEQ L1
282		LDR r4, =msg_14
283		MOV r0, r4
284		BL p_print_string
285		LDRSB r4, [sp]
286		MOV r0, r4
287		BL putchar
288		BL p_print_ln
289		LDRSB r4, [sp]
290		MOV r0, r4
291		ADD sp, sp, #1
292		POP {pc}
293		POP {pc}
294		.ltorg
295	f_printBoard:
296		PUSH {lr}
297		SUB sp, sp, #17
298		LDR r4, [sp, #21]
299		MOV r0, r4
300		BL p_check_null_pointer
301		LDR r4, [r4]
302		LDR r4, [r4]
303		STR r4, [sp, #13]
304		LDR r4, [sp, #13]
305		MOV r0, r4
306		BL p_check_null_pointer
307		LDR r4, [r4]
308		LDR r4, [r4]
309		STR r4, [sp, #9]
310		LDR r4, [sp, #13]
311		MOV r0, r4
312		BL p_check_null_pointer
313		LDR r4, [r4, #4]
314		LDR r4, [r4]
315		STR r4, [sp, #5]
316		LDR r4, [sp, #21]
317		MOV r0, r4
318		BL p_check_null_pointer
319		LDR r4, [r4, #4]
320		LDR r4, [r4]
321		STR r4, [sp, #1]
322		LDR r4, =msg_15
323		MOV r0, r4
324		BL p_print_string
325		BL p_print_ln
326		LDR r4, =msg_16
327		MOV r0, r4
328		BL p_print_string
329		LDR r4, [sp, #9]
330		STR r4, [sp, #-4]!
331		BL f_printRow
332		ADD sp, sp, #4
333		MOV r4, r0
334		STRB r4, [sp]
335		LDR r4, =msg_17
336		MOV r0, r4
337		BL p_print_string
338		BL p_print_ln
339		LDR r4, =msg_18
340		MOV r0, r4
341		BL p_print_string
342		LDR r4, [sp, #5]
343		STR r4, [sp, #-4]!
344		BL f_printRow
345		ADD sp, sp, #4
346		MOV r4, r0
347		STRB r4, [sp]
348		LDR r4, =msg_19
349		MOV r0, r4
350		BL p_print_string
351		BL p_print_ln
352		LDR r4, =msg_20
353		MOV r0, r4
354		BL p_print_string
355		LDR r4, [sp, #1]
356		STR r4, [sp, #-4]!
357		BL f_printRow
358		ADD sp, sp, #4
359		MOV r4, r0
360		STRB r4, [sp]
361		LDR r4, =msg_21
362		MOV r0, r4
363		BL p_print_string
364		BL p_print_ln
365		MOV r4, #1
366		MOV r0, r4
367		ADD sp, sp, #17
368		POP {pc}
369		POP {pc}
370		.ltorg
371	f_printRow:
372		PUSH {lr}
373		SUB sp, sp, #8
374		LDR r4, [sp, #12]
375		MOV r0, r4
376		BL p_check_null_pointer
377		LDR r4, [r4]
378		LDR r4, [r4]
379		STR r4, [sp, #4]
380		LDR r4, [sp, #4]
381		MOV r0, r4
382		BL p_check_null_pointer
383		LDR r4, [r4]
384		LDRSB r4, [r4]
385		STRB r4, [sp, #3]
386		LDR r4, [sp, #4]
387		MOV r0, r4
388		BL p_check_null_pointer
389		LDR r4, [r4, #4]
390		LDRSB r4, [r4]
391		STRB r4, [sp, #2]
392		LDR r4, [sp, #12]
393		MOV r0, r4
394		BL p_check_null_pointer
395		LDR r4, [r4, #4]
396		LDRSB r4, [r4]
397		STRB r4, [sp, #1]
398		LDRSB r4, [sp, #3]
399		STRB r4, [sp, #-1]!
400		BL f_printCell
401		ADD sp, sp, #1
402		MOV r4, r0
403		STRB r4, [sp]
404		MOV r4, #'|'
405		MOV r0, r4
406		BL putchar
407		LDRSB r4, [sp, #2]
408		STRB r4, [sp, #-1]!
409		BL f_printCell
410		ADD sp, sp, #1
411		MOV r4, r0
412		STRB r4, [sp]
413		MOV r4, #'|'
414		MOV r0, r4
415		BL putchar
416		LDRSB r4, [sp, #1]
417		STRB r4, [sp, #-1]!
418		BL f_printCell
419		ADD sp, sp, #1
420		MOV r4, r0
421		STRB r4, [sp]
422		LDR r4, =msg_22
423		MOV r0, r4
424		BL p_print_string
425		BL p_print_ln
426		MOV r4, #1
427		MOV r0, r4
428		ADD sp, sp, #8
429		POP {pc}
430		POP {pc}
431		.ltorg
432	f_printCell:
433		PUSH {lr}
434		LDRSB r4, [sp, #4]
435		MOV r5, #0
436		CMP r4, r5
437		MOVEQ r4, #1
438		MOVNE r4, #0
439		CMP r4, #0
440		BEQ L8
441		MOV r4, #' '
442		MOV r0, r4
443		BL putchar
444		B L9
445	L8:
446		LDRSB r4, [sp, #4]
447		MOV r0, r4
448		BL putchar
449	L9:
450		MOV r4, #1
451		MOV r0, r4
452		POP {pc}
453		POP {pc}
454		.ltorg
455	f_askForAMoveHuman:
456		PUSH {lr}
457		SUB sp, sp, #9
458		MOV r4, #0
459		STRB r4, [sp, #8]
460		LDR r4, =0
461		STR r4, [sp, #4]
462		LDR r4, =0
463		STR r4, [sp]
464		B L10
465	L11:
466		LDR r4, =msg_23
467		MOV r0, r4
468		BL p_print_string
469		BL p_print_ln
470		LDR r4, =msg_24
471		MOV r0, r4
472		BL p_print_string
473		ADD r4, sp, #4
474		MOV r0, r4
475		BL p_read_int
476		LDR r4, =msg_25
477		MOV r0, r4
478		BL p_print_string
479		ADD r4, sp, #0
480		MOV r0, r4
481		BL p_read_int
482		LDR r4, [sp]
483		STR r4, [sp, #-4]!
484		LDR r4, [sp, #8]
485		STR r4, [sp, #-4]!
486		LDR r4, [sp, #21]
487		STR r4, [sp, #-4]!
488		BL f_validateMove
489		ADD sp, sp, #12
490		MOV r4, r0
491		STRB r4, [sp, #8]
492		LDRSB r4, [sp, #8]
493		CMP r4, #0
494		BEQ L12
495		LDR r4, =msg_26
496		MOV r0, r4
497		BL p_print_string
498		BL p_print_ln
499		LDR r4, [sp, #4]
500		ADD r5, sp, #17
501		LDR r6, =0
502		LDR r5, [r5]
503		MOV r0, r6
504		MOV r1, r5
505		BL p_check_array_bounds
506		ADD r5, r5, #4
507		ADD r5, r5, r6, LSL #2
508		STR r4, [r5]
509		LDR r4, [sp]
510		ADD r6, sp, #17
511		LDR r7, =1
512		LDR r6, [r6]
513		MOV r0, r7
514		MOV r1, r6
515		BL p_check_array_bounds
516		ADD r6, r6, #4
517		ADD r6, r6, r7, LSL #2
518		STR r4, [r6]
519		MOV r4, #1
520		MOV r0, r4
521		ADD sp, sp, #9
522		POP {pc}
523		B L13
524	L12:
525		LDR r4, =msg_27
526		MOV r0, r4
527		BL p_print_string
528		BL p_print_ln
529	L13:
530	L10:
531		LDRSB r4, [sp, #8]
532		EOR r4, r4, #1
533		CMP r4, #1
534		BEQ L11
535		MOV r4, #1
536		MOV r0, r4
537		ADD sp, sp, #9
538		POP {pc}
539		POP {pc}
540		.ltorg
541	f_validateMove:
542		PUSH {lr}
543		LDR r4, =1
544		LDR r5, [sp, #8]
545		CMP r4, r5
546		MOVLE r4, #1
547		MOVGT r4, #0
548		LDR r5, [sp, #8]
549		LDR r6, =3
550		CMP r5, r6
551		MOVLE r5, #1
552		MOVGT r5, #0
553		AND r4, r4, r5
554		LDR r5, =1
555		LDR r6, [sp, #12]
556		CMP r5, r6
557		MOVLE r5, #1
558		MOVGT r5, #0
559		AND r4, r4, r5
560		LDR r5, [sp, #12]
561		LDR r6, =3
562		CMP r5, r6
563		MOVLE r5, #1
564		MOVGT r5, #0
565		AND r4, r4, r5
566		CMP r4, #0
567		BEQ L14
568		SUB sp, sp, #1
569		LDR r4, [sp, #13]
570		STR r4, [sp, #-4]!
571		LDR r4, [sp, #13]
572		STR r4, [sp, #-4]!
573		LDR r4, [sp, #13]
574		STR r4, [sp, #-4]!
575		BL f_symbolAt
576		ADD sp, sp, #12
577		MOV r4, r0
578		STRB r4, [sp]
579		LDRSB r4, [sp]
580		MOV r5, #0
581		CMP r4, r5
582		MOVEQ r4, #1
583		MOVNE r4, #0
584		MOV r0, r4
585		ADD sp, sp, #1
586		POP {pc}
587		ADD sp, sp, #1
588		B L15
589	L14:
590		MOV r4, #0
591		MOV r0, r4
592		POP {pc}
593	L15:
594		POP {pc}
595		.ltorg
596	f_notifyMoveHuman:
597		PUSH {lr}
598		LDR r4, =msg_28
599		MOV r0, r4
600		BL p_print_string
601		LDR r4, [sp, #10]
602		MOV r0, r4
603		BL p_print_int
604		LDR r4, =msg_29
605		MOV r0, r4
606		BL p_print_string
607		LDR r4, [sp, #14]
608		MOV r0, r4
609		BL p_print_int
610		BL p_print_ln
611		MOV r4, #1
612		MOV r0, r4
613		POP {pc}
614		POP {pc}
615		.ltorg
616	f_initAI:
617		PUSH {lr}
618		SUB sp, sp, #16
619		LDR r0, =8
620		BL malloc
621		MOV r4, r0
622		LDRSB r5, [sp, #20]
623		LDR r0, =1
624		BL malloc
625		STRB r5, [r0]
626		STR r0, [r4]
627		LDR r5, =0
628		LDR r0, =4
629		BL malloc
630		STR r5, [r0]
631		STR r0, [r4, #4]
632		STR r4, [sp, #12]
633		LDRSB r4, [sp, #20]
634		STRB r4, [sp, #-1]!
635		BL f_generateAllPossibleStates
636		ADD sp, sp, #1
637		MOV r4, r0
638		STR r4, [sp, #8]
639		MOV r4, #'x'
640		STRB r4, [sp, #-1]!
641		LDRSB r4, [sp, #21]
642		STRB r4, [sp, #-1]!
643		LDR r4, [sp, #10]
644		STR r4, [sp, #-4]!
645		BL f_setValuesForAllStates
646		ADD sp, sp, #6
647		MOV r4, r0
648		STR r4, [sp, #4]
649		LDR r0, =8
650		BL malloc
651		MOV r4, r0
652		LDR r5, [sp, #12]
653		LDR r0, =4
654		BL malloc
655		STR r5, [r0]
656		STR r0, [r4]
657		LDR r5, [sp, #8]
658		LDR r0, =4
659		BL malloc
660		STR r5, [r0]
661		STR r0, [r4, #4]
662		STR r4, [sp]
663		LDR r4, [sp]
664		MOV r0, r4
665		ADD sp, sp, #16
666		POP {pc}
667		POP {pc}
668		.ltorg
669	f_generateAllPossibleStates:
670		PUSH {lr}
671		SUB sp, sp, #8
672		BL f_allocateNewBoard
673		MOV r4, r0
674		STR r4, [sp, #4]
675		LDR r4, [sp, #4]
676		STR r4, [sp, #-4]!
677		BL f_convertFromBoardToState
678		ADD sp, sp, #4
679		MOV r4, r0
680		STR r4, [sp]
681		MOV r4, #'x'
682		STRB r4, [sp, #-1]!
683		LDR r4, [sp, #1]
684		STR r4, [sp, #-4]!
685		BL f_generateNextStates
686		ADD sp, sp, #5
687		MOV r4, r0
688		STR r4, [sp]
689		LDR r4, [sp]
690		MOV r0, r4
691		ADD sp, sp, #8
692		POP {pc}
693		POP {pc}
694		.ltorg
695	f_convertFromBoardToState:
696		PUSH {lr}
697		SUB sp, sp, #12
698		BL f_generateEmptyPointerBoard
699		MOV r4, r0
700		STR r4, [sp, #8]
701		LDR r0, =8
702		BL malloc
703		MOV r4, r0
704		LDR r5, [sp, #16]
705		LDR r0, =4
706		BL malloc
707		STR r5, [r0]
708		STR r0, [r4]
709		LDR r5, [sp, #8]
710		LDR r0, =4
711		BL malloc
712		STR r5, [r0]
713		STR r0, [r4, #4]
714		STR r4, [sp, #4]
715		LDR r0, =8
716		BL malloc
717		MOV r4, r0
718		LDR r5, [sp, #4]
719		LDR r0, =4
720		BL malloc
721		STR r5, [r0]
722		STR r0, [r4]
723		LDR r5, =0
724		LDR r0, =4
725		BL malloc
726		STR r5, [r0]
727		STR r0, [r4, #4]
728		STR r4, [sp]
729		LDR r4, [sp]
730		MOV r0, r4
731		ADD sp, sp, #12
732		POP {pc}
733		POP {pc}
734		.ltorg
735	f_generateEmptyPointerBoard:
736		PUSH {lr}
737		SUB sp, sp, #20
738		BL f_generateEmptyPointerRow
739		MOV r4, r0
740		STR r4, [sp, #16]
741		BL f_generateEmptyPointerRow
742		MOV r4, r0
743		STR r4, [sp, #12]
744		BL f_generateEmptyPointerRow
745		MOV r4, r0
746		STR r4, [sp, #8]
747		LDR r0, =8
748		BL malloc
749		MOV r4, r0
750		LDR r5, [sp, #16]
751		LDR r0, =4
752		BL malloc
753		STR r5, [r0]
754		STR r0, [r4]
755		LDR r5, [sp, #12]
756		LDR r0, =4
757		BL malloc
758		STR r5, [r0]
759		STR r0, [r4, #4]
760		STR r4, [sp, #4]
761		LDR r0, =8
762		BL malloc
763		MOV r4, r0
764		LDR r5, [sp, #4]
765		LDR r0, =4
766		BL malloc
767		STR r5, [r0]
768		STR r0, [r4]
769		LDR r5, [sp, #8]
770		LDR r0, =4
771		BL malloc
772		STR r5, [r0]
773		STR r0, [r4, #4]
774		STR r4, [sp]
775		LDR r4, [sp]
776		MOV r0, r4
777		ADD sp, sp, #20
778		POP {pc}
779		POP {pc}
780		.ltorg
781	f_generateEmptyPointerRow:
782		PUSH {lr}
783		SUB sp, sp, #8
784		LDR r0, =8
785		BL malloc
786		MOV r4, r0
787		LDR r5, =0
788		LDR r0, =4
789		BL malloc
790		STR r5, [r0]
791		STR r0, [r4]
792		LDR r5, =0
793		LDR r0, =4
794		BL malloc
795		STR r5, [r0]
796		STR r0, [r4, #4]
797		STR r4, [sp, #4]
798		LDR r0, =8
799		BL malloc
800		MOV r4, r0
801		LDR r5, [sp, #4]
802		LDR r0, =4
803		BL malloc
804		STR r5, [r0]
805		STR r0, [r4]
806		LDR r5, =0
807		LDR r0, =4
808		BL malloc
809		STR r5, [r0]
810		STR r0, [r4, #4]
811		STR r4, [sp]
812		LDR r4, [sp]
813		MOV r0, r4
814		ADD sp, sp, #8
815		POP {pc}
816		POP {pc}
817		.ltorg
818	f_generateNextStates:
819		PUSH {lr}
820		SUB sp, sp, #14
821		LDR r4, [sp, #18]
822		MOV r0, r4
823		BL p_check_null_pointer
824		LDR r4, [r4]
825		LDR r4, [r4]
826		STR r4, [sp, #10]
827		LDR r4, [sp, #10]
828		MOV r0, r4
829		BL p_check_null_pointer
830		LDR r4, [r4]
831		LDR r4, [r4]
832		STR r4, [sp, #6]
833		LDR r4, [sp, #10]
834		MOV r0, r4
835		BL p_check_null_pointer
836		LDR r4, [r4, #4]
837		LDR r4, [r4]
838		STR r4, [sp, #2]
839		LDRSB r4, [sp, #22]
840		STRB r4, [sp, #-1]!
841		BL f_oppositeSymbol
842		ADD sp, sp, #1
843		MOV r4, r0
844		STRB r4, [sp, #1]
845		LDRSB r4, [sp, #1]
846		STRB r4, [sp, #-1]!
847		LDR r4, [sp, #7]
848		STR r4, [sp, #-4]!
849		BL f_hasWon
850		ADD sp, sp, #5
851		MOV r4, r0
852		STRB r4, [sp]
853		LDRSB r4, [sp]
854		CMP r4, #0
855		BEQ L16
856		LDR r4, [sp, #18]
857		MOV r0, r4
858		ADD sp, sp, #14
859		POP {pc}
860		B L17
861	L16:
862		SUB sp, sp, #1
863		LDRSB r4, [sp, #23]
864		STRB r4, [sp, #-1]!
865		LDR r4, [sp, #4]
866		STR r4, [sp, #-4]!
867		LDR r4, [sp, #12]
868		STR r4, [sp, #-4]!
869		BL f_generateNextStatesBoard
870		ADD sp, sp, #9
871		MOV r4, r0
872		STRB r4, [sp]
873		LDR r4, [sp, #19]
874		MOV r0, r4
875		ADD sp, sp, #15
876		POP {pc}
877		ADD sp, sp, #1
878	L17:
879		POP {pc}
880		.ltorg
881	f_generateNextStatesBoard:
882		PUSH {lr}
883		SUB sp, sp, #33
884		LDR r4, [sp, #37]
885		MOV r0, r4
886		BL p_check_null_pointer
887		LDR r4, [r4]
888		LDR r4, [r4]
889		STR r4, [sp, #29]
890		LDR r4, [sp, #29]
891		MOV r0, r4
892		BL p_check_null_pointer
893		LDR r4, [r4]
894		LDR r4, [r4]
895		STR r4, [sp, #25]
896		LDR r4, [sp, #29]
897		MOV r0, r4
898		BL p_check_null_pointer
899		LDR r4, [r4, #4]
900		LDR r4, [r4]
901		STR r4, [sp, #21]
902		LDR r4, [sp, #37]
903		MOV r0, r4
904		BL p_check_null_pointer
905		LDR r4, [r4, #4]
906		LDR r4, [r4]
907		STR r4, [sp, #17]
908		LDR r4, [sp, #41]
909		MOV r0, r4
910		BL p_check_null_pointer
911		LDR r4, [r4]
912		LDR r4, [r4]
913		STR r4, [sp, #13]
914		LDR r4, [sp, #13]
915		MOV r0, r4
916		BL p_check_null_pointer
917		LDR r4, [r4]
918		LDR r4, [r4]
919		STR r4, [sp, #9]
920		LDR r4, [sp, #13]
921		MOV r0, r4
922		BL p_check_null_pointer
923		LDR r4, [r4, #4]
924		LDR r4, [r4]
925		STR r4, [sp, #5]
926		LDR r4, [sp, #41]
927		MOV r0, r4
928		BL p_check_null_pointer
929		LDR r4, [r4, #4]
930		LDR r4, [r4]
931		STR r4, [sp, #1]
932		LDR r4, =1
933		STR r4, [sp, #-4]!
934		LDRSB r4, [sp, #49]
935		STRB r4, [sp, #-1]!
936		LDR r4, [sp, #14]
937		STR r4, [sp, #-4]!
938		LDR r4, [sp, #34]
939		STR r4, [sp, #-4]!
940		LDR r4, [sp, #50]
941		STR r4, [sp, #-4]!
942		BL f_generateNextStatesRow
943		ADD sp, sp, #17
944		MOV r4, r0
945		STRB r4, [sp]
946		LDR r4, =2
947		STR r4, [sp, #-4]!
948		LDRSB r4, [sp, #49]
949		STRB r4, [sp, #-1]!
950		LDR r4, [sp, #10]
951		STR r4, [sp, #-4]!
952		LDR r4, [sp, #30]
953		STR r4, [sp, #-4]!
954		LDR r4, [sp, #50]
955		STR r4, [sp, #-4]!
956		BL f_generateNextStatesRow
957		ADD sp, sp, #17
958		MOV r4, r0
959		STRB r4, [sp]
960		LDR r4, =3
961		STR r4, [sp, #-4]!
962		LDRSB r4, [sp, #49]
963		STRB r4, [sp, #-1]!
964		LDR r4, [sp, #6]
965		STR r4, [sp, #-4]!
966		LDR r4, [sp, #26]
967		STR r4, [sp, #-4]!
968		LDR r4, [sp, #50]
969		STR r4, [sp, #-4]!
970		BL f_generateNextStatesRow
971		ADD sp, sp, #17
972		MOV r4, r0
973		STRB r4, [sp]
974		MOV r4, #1
975		MOV r0, r4
976		ADD sp, sp, #33
977		POP {pc}
978		POP {pc}
979		.ltorg
980	f_generateNextStatesRow:
981		PUSH {lr}
982		SUB sp, sp, #11
983		LDR r4, [sp, #19]
984		MOV r0, r4
985		BL p_check_null_pointer
986		LDR r4, [r4]
987		LDR r4, [r4]
988		STR r4, [sp, #7]
989		LDR r4, [sp, #7]
990		MOV r0, r4
991		BL p_check_null_pointer
992		LDR r4, [r4]
993		LDRSB r4, [r4]
994		STRB r4, [sp, #6]
995		LDR r4, [sp, #7]
996		MOV r0, r4
997		BL p_check_null_pointer
998		LDR r4, [r4, #4]
999		LDRSB r4, [r4]
1000		STRB r4, [sp, #5]
1001		LDR r4, [sp, #19]
1002		MOV r0, r4
1003		BL p_check_null_pointer
1004		LDR r4, [r4, #4]
1005		LDRSB r4, [r4]
1006		STRB r4, [sp, #4]
1007		LDR r4, [sp, #23]
1008		MOV r0, r4
1009		BL p_check_null_pointer
1010		LDR r4, [r4]
1011		LDR r4, [r4]
1012		STR r4, [sp]
1013		LDR r4, =1
1014		STR r4, [sp, #-4]!
1015		LDR r4, [sp, #32]
1016		STR r4, [sp, #-4]!
1017		LDRSB r4, [sp, #35]
1018		STRB r4, [sp, #-1]!
1019		LDRSB r4, [sp, #15]
1020		STRB r4, [sp, #-1]!
1021		LDR r4, [sp, #25]
1022		STR r4, [sp, #-4]!
1023		BL f_generateNextStatesCell
1024		ADD sp, sp, #14
1025		MOV r4, r0
1026		LDR r5, [sp]
1027		MOV r0, r5
1028		BL p_check_null_pointer
1029		LDR r5, [r5]
1030		STR r4, [r5]
1031		LDR r4, =2
1032		STR r4, [sp, #-4]!
1033		LDR r4, [sp, #32]
1034		STR r4, [sp, #-4]!
1035		LDRSB r4, [sp, #35]
1036		STRB r4, [sp, #-1]!
1037		LDRSB r4, [sp, #14]
1038		STRB r4, [sp, #-1]!
1039		LDR r4, [sp, #25]
1040		STR r4, [sp, #-4]!
1041		BL f_generateNextStatesCell
1042		ADD sp, sp, #14
1043		MOV r4, r0
1044		LDR r5, [sp]
1045		MOV r0, r5
1046		BL p_check_null_pointer
1047		LDR r5, [r5, #4]
1048		STR r4, [r5]
1049		LDR r4, =3
1050		STR r4, [sp, #-4]!
1051		LDR r4, [sp, #32]
1052		STR r4, [sp, #-4]!
1053		LDRSB r4, [sp, #35]
1054		STRB r4, [sp, #-1]!
1055		LDRSB r4, [sp, #13]
1056		STRB r4, [sp, #-1]!
1057		LDR r4, [sp, #25]
1058		STR r4, [sp, #-4]!
1059		BL f_generateNextStatesCell
1060		ADD sp, sp, #14
1061		MOV r4, r0
1062		LDR r5, [sp, #23]
1063		MOV r0, r5
1064		BL p_check_null_pointer
1065		LDR r5, [r5, #4]
1066		STR r4, [r5]
1067		MOV r4, #1
1068		MOV r0, r4
1069		ADD sp, sp, #11
1070		POP {pc}
1071		POP {pc}
1072		.ltorg
1073	f_generateNextStatesCell:
1074		PUSH {lr}
1075		LDRSB r4, [sp, #8]
1076		MOV r5, #0
1077		CMP r4, r5
1078		MOVEQ r4, #1
1079		MOVNE r4, #0
1080		CMP r4, #0
1081		BEQ L18
1082		SUB sp, sp, #10
1083		LDR r4, [sp, #14]
1084		STR r4, [sp, #-4]!
1085		BL f_cloneBoard
1086		ADD sp, sp, #4
1087		MOV r4, r0
1088		STR r4, [sp, #6]
1089		LDR r4, [sp, #24]
1090		STR r4, [sp, #-4]!
1091		LDR r4, [sp, #24]
1092		STR r4, [sp, #-4]!
1093		LDRSB r4, [sp, #27]
1094		STRB r4, [sp, #-1]!
1095		LDR r4, [sp, #15]
1096		STR r4, [sp, #-4]!
1097		BL f_placeMove
1098		ADD sp, sp, #13
1099		MOV r4, r0
1100		STRB r4, [sp, #5]
1101		LDR r4, [sp, #6]
1102		STR r4, [sp, #-4]!
1103		BL f_convertFromBoardToState
1104		ADD sp, sp, #4
1105		MOV r4, r0
1106		STR r4, [sp, #1]
1107		LDRSB r4, [sp, #19]
1108		STRB r4, [sp, #-1]!
1109		BL f_oppositeSymbol
1110		ADD sp, sp, #1
1111		MOV r4, r0
1112		STRB r4, [sp]
1113		LDRSB r4, [sp]
1114		STRB r4, [sp, #-1]!
1115		LDR r4, [sp, #2]
1116		STR r4, [sp, #-4]!
1117		BL f_generateNextStates
1118		ADD sp, sp, #5
1119		MOV r4, r0
1120		STR r4, [sp, #1]
1121		LDR r4, [sp, #1]
1122		MOV r0, r4
1123		ADD sp, sp, #10
1124		POP {pc}
1125		ADD sp, sp, #10
1126		B L19
1127	L18:
1128		LDR r4, =0
1129		MOV r0, r4
1130		POP {pc}
1131	L19:
1132		POP {pc}
1133		.ltorg
1134	f_cloneBoard:
1135		PUSH {lr}
1136		SUB sp, sp, #5
1137		BL f_allocateNewBoard
1138		MOV r4, r0
1139		STR r4, [sp, #1]
1140		LDR r4, [sp, #1]
1141		STR r4, [sp, #-4]!
1142		LDR r4, [sp, #13]
1143		STR r4, [sp, #-4]!
1144		BL f_copyBoard
1145		ADD sp, sp, #8
1146		MOV r4, r0
1147		STRB r4, [sp]
1148		LDR r4, [sp, #1]
1149		MOV r0, r4
1150		ADD sp, sp, #5
1151		POP {pc}
1152		POP {pc}
1153		.ltorg
1154	f_copyBoard:
1155		PUSH {lr}
1156		SUB sp, sp, #33
1157		LDR r4, [sp, #37]
1158		MOV r0, r4
1159		BL p_check_null_pointer
1160		LDR r4, [r4]
1161		LDR r4, [r4]
1162		STR r4, [sp, #29]
1163		LDR r4, [sp, #29]
1164		MOV r0, r4
1165		BL p_check_null_pointer
1166		LDR r4, [r4]
1167		LDR r4, [r4]
1168		STR r4, [sp, #25]
1169		LDR r4, [sp, #29]
1170		MOV r0, r4
1171		BL p_check_null_pointer
1172		LDR r4, [r4, #4]
1173		LDR r4, [r4]
1174		STR r4, [sp, #21]
1175		LDR r4, [sp, #37]
1176		MOV r0, r4
1177		BL p_check_null_pointer
1178		LDR r4, [r4, #4]
1179		LDR r4, [r4]
1180		STR r4, [sp, #17]
1181		LDR r4, [sp, #41]
1182		MOV r0, r4
1183		BL p_check_null_pointer
1184		LDR r4, [r4]
1185		LDR r4, [r4]
1186		STR r4, [sp, #13]
1187		LDR r4, [sp, #13]
1188		MOV r0, r4
1189		BL p_check_null_pointer
1190		LDR r4, [r4]
1191		LDR r4, [r4]
1192		STR r4, [sp, #9]
1193		LDR r4, [sp, #13]
1194		MOV r0, r4
1195		BL p_check_null_pointer
1196		LDR r4, [r4, #4]
1197		LDR r4, [r4]
1198		STR r4, [sp, #5]
1199		LDR r4, [sp, #41]
1200		MOV r0, r4
1201		BL p_check_null_pointer
1202		LDR r4, [r4, #4]
1203		LDR r4, [r4]
1204		STR r4, [sp, #1]
1205		LDR r4, [sp, #9]
1206		STR r4, [sp, #-4]!
1207		LDR r4, [sp, #29]
1208		STR r4, [sp, #-4]!
1209		BL f_copyRow
1210		ADD sp, sp, #8
1211		MOV r4, r0
1212		STRB r4, [sp]
1213		LDR r4, [sp, #5]
1214		STR r4, [sp, #-4]!
1215		LDR r4, [sp, #25]
1216		STR r4, [sp, #-4]!
1217		BL f_copyRow
1218		ADD sp, sp, #8
1219		MOV r4, r0
1220		STRB r4, [sp]
1221		LDR r4, [sp, #1]
1222		STR r4, [sp, #-4]!
1223		LDR r4, [sp, #21]
1224		STR r4, [sp, #-4]!
1225		BL f_copyRow
1226		ADD sp, sp, #8
1227		MOV r4, r0
1228		STRB r4, [sp]
1229		MOV r4, #1
1230		MOV r0, r4
1231		ADD sp, sp, #33
1232		POP {pc}
1233		POP {pc}
1234		.ltorg
1235	f_copyRow:
1236		PUSH {lr}
1237		SUB sp, sp, #8
1238		LDR r4, [sp, #12]
1239		MOV r0, r4
1240		BL p_check_null_pointer
1241		LDR r4, [r4]
1242		LDR r4, [r4]
1243		STR r4, [sp, #4]
1244		LDR r4, [sp, #16]
1245		MOV r0, r4
1246		BL p_check_null_pointer
1247		LDR r4, [r4]
1248		LDR r4, [r4]
1249		STR r4, [sp]
1250		LDR r4, [sp, #4]
1251		MOV r0, r4
1252		BL p_check_null_pointer
1253		LDR r4, [r4]
1254		LDRSB r4, [r4]
1255		LDR r5, [sp]
1256		MOV r0, r5
1257		BL p_check_null_pointer
1258		LDR r5, [r5]
1259		STRB r4, [r5]
1260		LDR r4, [sp, #4]
1261		MOV r0, r4
1262		BL p_check_null_pointer
1263		LDR r4, [r4, #4]
1264		LDRSB r4, [r4]
1265		LDR r5, [sp]
1266		MOV r0, r5
1267		BL p_check_null_pointer
1268		LDR r5, [r5, #4]
1269		STRB r4, [r5]
1270		LDR r4, [sp, #12]
1271		MOV r0, r4
1272		BL p_check_null_pointer
1273		LDR r4, [r4, #4]
1274		LDRSB r4, [r4]
1275		LDR r5, [sp, #16]
1276		MOV r0, r5
1277		BL p_check_null_pointer
1278		LDR r5, [r5, #4]
1279		STRB r4, [r5]
1280		MOV r4, #1
1281		MOV r0, r4
1282		ADD sp, sp, #8
1283		POP {pc}
1284		POP {pc}
1285		.ltorg
1286	f_setValuesForAllStates:
1287		PUSH {lr}
1288		SUB sp, sp, #4
1289		LDR r4, =0
1290		STR r4, [sp]
1291		LDR r4, [sp, #8]
1292		LDR r5, =0
1293		CMP r4, r5
1294		MOVEQ r4, #1
1295		MOVNE r4, #0
1296		CMP r4, #0
1297		BEQ L20
1298		LDRSB r4, [sp, #13]
1299		LDRSB r5, [sp, #12]
1300		CMP r4, r5
1301		MOVEQ r4, #1
1302		MOVNE r4, #0
1303		CMP r4, #0
1304		BEQ L22
1305		LDR r4, =101
1306		STR r4, [sp]
1307		B L23
1308	L22:
1309		LDR r4, =-101
1310		STR r4, [sp]
1311	L23:
1312		B L21
1313	L20:
1314		SUB sp, sp, #14
1315		LDR r4, [sp, #22]
1316		MOV r0, r4
1317		BL p_check_null_pointer
1318		LDR r4, [r4]
1319		LDR r4, [r4]
1320		STR r4, [sp, #10]
1321		LDR r4, [sp, #10]
1322		MOV r0, r4
1323		BL p_check_null_pointer
1324		LDR r4, [r4]
1325		LDR r4, [r4]
1326		STR r4, [sp, #6]
1327		LDR r4, [sp, #10]
1328		MOV r0, r4
1329		BL p_check_null_pointer
1330		LDR r4, [r4, #4]
1331		LDR r4, [r4]
1332		STR r4, [sp, #2]
1333		LDRSB r4, [sp, #27]
1334		STRB r4, [sp, #-1]!
1335		BL f_oppositeSymbol
1336		ADD sp, sp, #1
1337		MOV r4, r0
1338		STRB r4, [sp, #1]
1339		LDRSB r4, [sp, #1]
1340		STRB r4, [sp, #-1]!
1341		LDR r4, [sp, #7]
1342		STR r4, [sp, #-4]!
1343		BL f_hasWon
1344		ADD sp, sp, #5
1345		MOV r4, r0
1346		STRB r4, [sp]
1347		LDRSB r4, [sp]
1348		CMP r4, #0
1349		BEQ L24
1350		LDRSB r4, [sp, #1]
1351		LDRSB r5, [sp, #26]
1352		CMP r4, r5
1353		MOVEQ r4, #1
1354		MOVNE r4, #0
1355		CMP r4, #0
1356		BEQ L26
1357		LDR r4, =100
1358		STR r4, [sp, #14]
1359		B L27
1360	L26:
1361		LDR r4, =-100
1362		STR r4, [sp, #14]
1363	L27:
1364		B L25
1365	L24:
1366		SUB sp, sp, #1
1367		LDR r4, [sp, #7]
1368		STR r4, [sp, #-4]!
1369		BL f_containEmptyCell
1370		ADD sp, sp, #4
1371		MOV r4, r0
1372		STRB r4, [sp]
1373		LDRSB r4, [sp]
1374		CMP r4, #0
1375		BEQ L28
1376		LDRSB r4, [sp, #2]
1377		STRB r4, [sp, #-1]!
1378		LDRSB r4, [sp, #28]
1379		STRB r4, [sp, #-1]!
1380		LDR r4, [sp, #5]
1381		STR r4, [sp, #-4]!
1382		BL f_calculateValuesFromNextStates
1383		ADD sp, sp, #6
1384		MOV r4, r0
1385		STR r4, [sp, #15]
1386		LDR r4, [sp, #15]
1387		LDR r5, =100
1388		CMP r4, r5
1389		MOVEQ r4, #1
1390		MOVNE r4, #0
1391		CMP r4, #0
1392		BEQ L30
1393		LDR r4, =90
1394		STR r4, [sp, #15]
1395		B L31
1396	L30:
1397	L31:
1398		B L29
1399	L28:
1400		LDR r4, =0
1401		STR r4, [sp, #15]
1402	L29:
1403		ADD sp, sp, #1
1404	L25:
1405		LDR r4, [sp, #14]
1406		LDR r5, [sp, #22]
1407		MOV r0, r5
1408		BL p_check_null_pointer
1409		LDR r5, [r5, #4]
1410		STR r4, [r5]
1411		ADD sp, sp, #14
1412	L21:
1413		LDR r4, [sp]
1414		MOV r0, r4
1415		ADD sp, sp, #4
1416		POP {pc}
1417		POP {pc}
1418		.ltorg
1419	f_calculateValuesFromNextStates:
1420		PUSH {lr}
1421		SUB sp, sp, #32
1422		LDR r4, [sp, #36]
1423		MOV r0, r4
1424		BL p_check_null_pointer
1425		LDR r4, [r4]
1426		LDR r4, [r4]
1427		STR r4, [sp, #28]
1428		LDR r4, [sp, #28]
1429		MOV r0, r4
1430		BL p_check_null_pointer
1431		LDR r4, [r4]
1432		LDR r4, [r4]
1433		STR r4, [sp, #24]
1434		LDR r4, [sp, #28]
1435		MOV r0, r4
1436		BL p_check_null_pointer
1437		LDR r4, [r4, #4]
1438		LDR r4, [r4]
1439		STR r4, [sp, #20]
1440		LDR r4, [sp, #36]
1441		MOV r0, r4
1442		BL p_check_null_pointer
1443		LDR r4, [r4, #4]
1444		LDR r4, [r4]
1445		STR r4, [sp, #16]
1446		LDRSB r4, [sp, #41]
1447		STRB r4, [sp, #-1]!
1448		LDRSB r4, [sp, #41]
1449		STRB r4, [sp, #-1]!
1450		LDR r4, [sp, #26]
1451		STR r4, [sp, #-4]!
1452		BL f_calculateValuesFromNextStatesRow
1453		ADD sp, sp, #6
1454		MOV r4, r0
1455		STR r4, [sp, #12]
1456		LDRSB r4, [sp, #41]
1457		STRB r4, [sp, #-1]!
1458		LDRSB r4, [sp, #41]
1459		STRB r4, [sp, #-1]!
1460		LDR r4, [sp, #22]
1461		STR r4, [sp, #-4]!
1462		BL f_calculateValuesFromNextStatesRow
1463		ADD sp, sp, #6
1464		MOV r4, r0
1465		STR r4, [sp, #8]
1466		LDRSB r4, [sp, #41]
1467		STRB r4, [sp, #-1]!
1468		LDRSB r4, [sp, #41]
1469		STRB r4, [sp, #-1]!
1470		LDR r4, [sp, #18]
1471		STR r4, [sp, #-4]!
1472		BL f_calculateValuesFromNextStatesRow
1473		ADD sp, sp, #6
1474		MOV r4, r0
1475		STR r4, [sp, #4]
1476		LDR r4, [sp, #4]
1477		STR r4, [sp, #-4]!
1478		LDR r4, [sp, #12]
1479		STR r4, [sp, #-4]!
1480		LDR r4, [sp, #20]
1481		STR r4, [sp, #-4]!
1482		LDRSB r4, [sp, #53]
1483		STRB r4, [sp, #-1]!
1484		LDRSB r4, [sp, #53]
1485		STRB r4, [sp, #-1]!
1486		BL f_combineValue
1487		ADD sp, sp, #14
1488		MOV r4, r0
1489		STR r4, [sp]
1490		LDR r4, [sp]
1491		MOV r0, r4
1492		ADD sp, sp, #32
1493		POP {pc}
1494		POP {pc}
1495		.ltorg
1496	f_calculateValuesFromNextStatesRow:
1497		PUSH {lr}
1498		SUB sp, sp, #32
1499		LDR r4, [sp, #36]
1500		MOV r0, r4
1501		BL p_check_null_pointer
1502		LDR r4, [r4]
1503		LDR r4, [r4]
1504		STR r4, [sp, #28]
1505		LDR r4, [sp, #28]
1506		MOV r0, r4
1507		BL p_check_null_pointer
1508		LDR r4, [r4]
1509		LDR r4, [r4]
1510		STR r4, [sp, #24]
1511		LDR r4, [sp, #28]
1512		MOV r0, r4
1513		BL p_check_null_pointer
1514		LDR r4, [r4, #4]
1515		LDR r4, [r4]
1516		STR r4, [sp, #20]
1517		LDR r4, [sp, #36]
1518		MOV r0, r4
1519		BL p_check_null_pointer
1520		LDR r4, [r4, #4]
1521		LDR r4, [r4]
1522		STR r4, [sp, #16]
1523		LDRSB r4, [sp, #41]
1524		STRB r4, [sp, #-1]!
1525		LDRSB r4, [sp, #41]
1526		STRB r4, [sp, #-1]!
1527		LDR r4, [sp, #26]
1528		STR r4, [sp, #-4]!
1529		BL f_setValuesForAllStates
1530		ADD sp, sp, #6
1531		MOV r4, r0
1532		STR r4, [sp, #12]
1533		LDRSB r4, [sp, #41]
1534		STRB r4, [sp, #-1]!
1535		LDRSB r4, [sp, #41]
1536		STRB r4, [sp, #-1]!
1537		LDR r4, [sp, #22]
1538		STR r4, [sp, #-4]!
1539		BL f_setValuesForAllStates
1540		ADD sp, sp, #6
1541		MOV r4, r0
1542		STR r4, [sp, #8]
1543		LDRSB r4, [sp, #41]
1544		STRB r4, [sp, #-1]!
1545		LDRSB r4, [sp, #41]
1546		STRB r4, [sp, #-1]!
1547		LDR r4, [sp, #18]
1548		STR r4, [sp, #-4]!
1549		BL f_setValuesForAllStates
1550		ADD sp, sp, #6
1551		MOV r4, r0
1552		STR r4, [sp, #4]
1553		LDR r4, [sp, #4]
1554		STR r4, [sp, #-4]!
1555		LDR r4, [sp, #12]
1556		STR r4, [sp, #-4]!
1557		LDR r4, [sp, #20]
1558		STR r4, [sp, #-4]!
1559		LDRSB r4, [sp, #53]
1560		STRB r4, [sp, #-1]!
1561		LDRSB r4, [sp, #53]
1562		STRB r4, [sp, #-1]!
1563		BL f_combineValue
1564		ADD sp, sp, #14
1565		MOV r4, r0
1566		STR r4, [sp]
1567		LDR r4, [sp]
1568		MOV r0, r4
1569		ADD sp, sp, #32
1570		POP {pc}
1571		POP {pc}
1572		.ltorg
1573	f_combineValue:
1574		PUSH {lr}
1575		SUB sp, sp, #4
1576		LDR r4, =0
1577		STR r4, [sp]
1578		LDRSB r4, [sp, #8]
1579		LDRSB r5, [sp, #9]
1580		CMP r4, r5
1581		MOVEQ r4, #1
1582		MOVNE r4, #0
1583		CMP r4, #0
1584		BEQ L32
1585		LDR r4, [sp, #18]
1586		STR r4, [sp, #-4]!
1587		LDR r4, [sp, #18]
1588		STR r4, [sp, #-4]!
1589		LDR r4, [sp, #18]
1590		STR r4, [sp, #-4]!
1591		BL f_min3
1592		ADD sp, sp, #12
1593		MOV r4, r0
1594		STR r4, [sp]
1595		B L33
1596	L32:
1597		LDR r4, [sp, #18]
1598		STR r4, [sp, #-4]!
1599		LDR r4, [sp, #18]
1600		STR r4, [sp, #-4]!
1601		LDR r4, [sp, #18]
1602		STR r4, [sp, #-4]!
1603		BL f_max3
1604		ADD sp, sp, #12
1605		MOV r4, r0
1606		STR r4, [sp]
1607	L33:
1608		LDR r4, [sp]
1609		MOV r0, r4
1610		ADD sp, sp, #4
1611		POP {pc}
1612		POP {pc}
1613		.ltorg
1614	f_min3:
1615		PUSH {lr}
1616		LDR r4, [sp, #4]
1617		LDR r5, [sp, #8]
1618		CMP r4, r5
1619		MOVLT r4, #1
1620		MOVGE r4, #0
1621		CMP r4, #0
1622		BEQ L34
1623		LDR r4, [sp, #4]
1624		LDR r5, [sp, #12]
1625		CMP r4, r5
1626		MOVLT r4, #1
1627		MOVGE r4, #0
1628		CMP r4, #0
1629		BEQ L36
1630		LDR r4, [sp, #4]
1631		MOV r0, r4
1632		POP {pc}
1633		B L37
1634	L36:
1635		LDR r4, [sp, #12]
1636		MOV r0, r4
1637		POP {pc}
1638	L37:
1639		B L35
1640	L34:
1641		LDR r4, [sp, #8]
1642		LDR r5, [sp, #12]
1643		CMP r4, r5
1644		MOVLT r4, #1
1645		MOVGE r4, #0
1646		CMP r4, #0
1647		BEQ L38
1648		LDR r4, [sp, #8]
1649		MOV r0, r4
1650		POP {pc}
1651		B L39
1652	L38:
1653		LDR r4, [sp, #12]
1654		MOV r0, r4
1655		POP {pc}
1656	L39:
1657	L35:
1658		POP {pc}
1659		.ltorg
1660	f_max3:
1661		PUSH {lr}
1662		LDR r4, [sp, #4]
1663		LDR r5, [sp, #8]
1664		CMP r4, r5
1665		MOVGT r4, #1
1666		MOVLE r4, #0
1667		CMP r4, #0
1668		BEQ L40
1669		LDR r4, [sp, #4]
1670		LDR r5, [sp, #12]
1671		CMP r4, r5
1672		MOVGT r4, #1
1673		MOVLE r4, #0
1674		CMP r4, #0
1675		BEQ L42
1676		LDR r4, [sp, #4]
1677		MOV r0, r4
1678		POP {pc}
1679		B L43
1680	L42:
1681		LDR r4, [sp, #12]
1682		MOV r0, r4
1683		POP {pc}
1684	L43:
1685		B L41
1686	L40:
1687		LDR r4, [sp, #8]
1688		LDR r5, [sp, #12]
1689		CMP r4, r5
1690		MOVGT r4, #1
1691		MOVLE r4, #0
1692		CMP r4, #0
1693		BEQ L44
1694		LDR r4, [sp, #8]
1695		MOV r0, r4
1696		POP {pc}
1697		B L45
1698	L44:
1699		LDR r4, [sp, #12]
1700		MOV r0, r4
1701		POP {pc}
1702	L45:
1703	L41:
1704		POP {pc}
1705		.ltorg
1706	f_destroyAI:
1707		PUSH {lr}
1708		SUB sp, sp, #9
1709		LDR r4, [sp, #13]
1710		MOV r0, r4
1711		BL p_check_null_pointer
1712		LDR r4, [r4]
1713		LDR r4, [r4]
1714		STR r4, [sp, #5]
1715		LDR r4, [sp, #13]
1716		MOV r0, r4
1717		BL p_check_null_pointer
1718		LDR r4, [r4, #4]
1719		LDR r4, [r4]
1720		STR r4, [sp, #1]
1721		LDR r4, [sp, #1]
1722		STR r4, [sp, #-4]!
1723		BL f_deleteStateTreeRecursively
1724		ADD sp, sp, #4
1725		MOV r4, r0
1726		STRB r4, [sp]
1727		LDR r4, [sp, #5]
1728		MOV r0, r4
1729		BL p_free_pair
1730		LDR r4, [sp, #13]
1731		MOV r0, r4
1732		BL p_free_pair
1733		MOV r4, #1
1734		MOV r0, r4
1735		ADD sp, sp, #9
1736		POP {pc}
1737		POP {pc}
1738		.ltorg
1739	f_askForAMoveAI:
1740		PUSH {lr}
1741		SUB sp, sp, #21
1742		LDR r4, [sp, #31]
1743		MOV r0, r4
1744		BL p_check_null_pointer
1745		LDR r4, [r4]
1746		LDR r4, [r4]
1747		STR r4, [sp, #17]
1748		LDR r4, [sp, #31]
1749		MOV r0, r4
1750		BL p_check_null_pointer
1751		LDR r4, [r4, #4]
1752		LDR r4, [r4]
1753		STR r4, [sp, #13]
1754		LDR r4, [sp, #13]
1755		MOV r0, r4
1756		BL p_check_null_pointer
1757		LDR r4, [r4]
1758		LDR r4, [r4]
1759		STR r4, [sp, #9]
1760		LDR r4, [sp, #9]
1761		MOV r0, r4
1762		BL p_check_null_pointer
1763		LDR r4, [r4, #4]
1764		LDR r4, [r4]
1765		STR r4, [sp, #5]
1766		LDR r4, [sp, #13]
1767		MOV r0, r4
1768		BL p_check_null_pointer
1769		LDR r4, [r4, #4]
1770		LDR r4, [r4]
1771		STR r4, [sp, #1]
1772		LDR r4, [sp, #35]
1773		STR r4, [sp, #-4]!
1774		LDR r4, [sp, #5]
1775		STR r4, [sp, #-4]!
1776		LDR r4, [sp, #13]
1777		STR r4, [sp, #-4]!
1778		BL f_findTheBestMove
1779		ADD sp, sp, #12
1780		MOV r4, r0
1781		STRB r4, [sp]
1782		LDR r4, =msg_30
1783		MOV r0, r4
1784		BL p_print_string
1785		BL p_print_ln
1786		ADD r4, sp, #35
1787		LDR r5, =1
1788		LDR r4, [r4]
1789		MOV r0, r5
1790		MOV r1, r4
1791		BL p_check_array_bounds
1792		ADD r4, r4, #4
1793		ADD r4, r4, r5, LSL #2
1794		LDR r4, [r4]
1795		STR r4, [sp, #-4]!
1796		ADD r4, sp, #39
1797		LDR r5, =0
1798		LDR r4, [r4]
1799		MOV r0, r5
1800		MOV r1, r4
1801		BL p_check_array_bounds
1802		ADD r4, r4, #4
1803		ADD r4, r4, r5, LSL #2
1804		LDR r4, [r4]
1805		STR r4, [sp, #-4]!
1806		LDR r4, [sp, #13]
1807		STR r4, [sp, #-4]!
1808		BL f_deleteAllOtherChildren
1809		ADD sp, sp, #12
1810		MOV r4, r0
1811		LDR r5, [sp, #31]
1812		MOV r0, r5
1813		BL p_check_null_pointer
1814		LDR r5, [r5, #4]
1815		STR r4, [r5]
1816		LDR r4, [sp, #13]
1817		STR r4, [sp, #-4]!
1818		BL f_deleteThisStateOnly
1819		ADD sp, sp, #4
1820		MOV r4, r0
1821		STRB r4, [sp]
1822		MOV r4, #1
1823		MOV r0, r4
1824		ADD sp, sp, #21
1825		POP {pc}
1826		POP {pc}
1827		.ltorg
1828	f_findTheBestMove:
1829		PUSH {lr}
1830		SUB sp, sp, #1
1831		LDR r4, [sp, #9]
1832		LDR r5, =90
1833		CMP r4, r5
1834		MOVEQ r4, #1
1835		MOVNE r4, #0
1836		CMP r4, #0
1837		BEQ L46
1838		SUB sp, sp, #1
1839		LDR r4, [sp, #14]
1840		STR r4, [sp, #-4]!
1841		LDR r4, =100
1842		STR r4, [sp, #-4]!
1843		LDR r4, [sp, #14]
1844		STR r4, [sp, #-4]!
1845		BL f_findMoveWithGivenValue
1846		ADD sp, sp, #12
1847		MOV r4, r0
1848		STRB r4, [sp]
1849		LDRSB r4, [sp]
1850		CMP r4, #0
1851		BEQ L48
1852		MOV r4, #1
1853		MOV r0, r4
1854		ADD sp, sp, #2
1855		POP {pc}
1856		B L49
1857	L48:
1858	L49:
1859		ADD sp, sp, #1
1860		B L47
1861	L46:
1862	L47:
1863		LDR r4, [sp, #13]
1864		STR r4, [sp, #-4]!
1865		LDR r4, [sp, #13]
1866		STR r4, [sp, #-4]!
1867		LDR r4, [sp, #13]
1868		STR r4, [sp, #-4]!
1869		BL f_findMoveWithGivenValue
1870		ADD sp, sp, #12
1871		MOV r4, r0
1872		STRB r4, [sp]
1873		LDRSB r4, [sp]
1874		CMP r4, #0
1875		BEQ L50
1876		MOV r4, #1
1877		MOV r0, r4
1878		ADD sp, sp, #1
1879		POP {pc}
1880		B L51
1881	L50:
1882		LDR r4, =msg_31
1883		MOV r0, r4
1884		BL p_print_string
1885		BL p_print_ln
1886		LDR r4, =-1
1887		MOV r0, r4
1888		BL exit
1889	L51:
1890		POP {pc}
1891		.ltorg
1892	f_findMoveWithGivenValue:
1893		PUSH {lr}
1894		SUB sp, sp, #17
1895		LDR r4, [sp, #21]
1896		MOV r0, r4
1897		BL p_check_null_pointer
1898		LDR r4, [r4]
1899		LDR r4, [r4]
1900		STR r4, [sp, #13]
1901		LDR r4, [sp, #13]
1902		MOV r0, r4
1903		BL p_check_null_pointer
1904		LDR r4, [r4]
1905		LDR r4, [r4]
1906		STR r4, [sp, #9]
1907		LDR r4, [sp, #13]
1908		MOV r0, r4
1909		BL p_check_null_pointer
1910		LDR r4, [r4, #4]
1911		LDR r4, [r4]
1912		STR r4, [sp, #5]
1913		LDR r4, [sp, #21]
1914		MOV r0, r4
1915		BL p_check_null_pointer
1916		LDR r4, [r4, #4]
1917		LDR r4, [r4]
1918		STR r4, [sp, #1]
1919		LDR r4, [sp, #29]
1920		STR r4, [sp, #-4]!
1921		LDR r4, [sp, #29]
1922		STR r4, [sp, #-4]!
1923		LDR r4, [sp, #17]
1924		STR r4, [sp, #-4]!
1925		BL f_findMoveWithGivenValueRow
1926		ADD sp, sp, #12
1927		MOV r4, r0
1928		STRB r4, [sp]
1929		LDRSB r4, [sp]
1930		CMP r4, #0
1931		BEQ L52
1932		LDR r4, =1
1933		ADD r5, sp, #29
1934		LDR r6, =0
1935		LDR r5, [r5]
1936		MOV r0, r6
1937		MOV r1, r5
1938		BL p_check_array_bounds
1939		ADD r5, r5, #4
1940		ADD r5, r5, r6, LSL #2
1941		STR r4, [r5]
1942		B L53
1943	L52:
1944		LDR r4, [sp, #29]
1945		STR r4, [sp, #-4]!
1946		LDR r4, [sp, #29]
1947		STR r4, [sp, #-4]!
1948		LDR r4, [sp, #13]
1949		STR r4, [sp, #-4]!
1950		BL f_findMoveWithGivenValueRow
1951		ADD sp, sp, #12
1952		MOV r4, r0
1953		STRB r4, [sp]
1954		LDRSB r4, [sp]
1955		CMP r4, #0
1956		BEQ L54
1957		LDR r4, =2
1958		ADD r6, sp, #29
1959		LDR r7, =0
1960		LDR r6, [r6]
1961		MOV r0, r7
1962		MOV r1, r6
1963		BL p_check_array_bounds
1964		ADD r6, r6, #4
1965		ADD r6, r6, r7, LSL #2
1966		STR r4, [r6]
1967		B L55
1968	L54:
1969		LDR r4, [sp, #29]
1970		STR r4, [sp, #-4]!
1971		LDR r4, [sp, #29]
1972		STR r4, [sp, #-4]!
1973		LDR r4, [sp, #9]
1974		STR r4, [sp, #-4]!
1975		BL f_findMoveWithGivenValueRow
1976		ADD sp, sp, #12
1977		MOV r4, r0
1978		STRB r4, [sp]
1979		LDRSB r4, [sp]
1980		CMP r4, #0
1981		BEQ L56
1982		LDR r4, =3
1983		ADD r7, sp, #29
1984		LDR r8, =0
1985		LDR r7, [r7]
1986		MOV r0, r8
1987		MOV r1, r7
1988		BL p_check_array_bounds
1989		ADD r7, r7, #4
1990		ADD r7, r7, r8, LSL #2
1991		STR r4, [r7]
1992		B L57
1993	L56:
1994		MOV r4, #0
1995		MOV r0, r4
1996		ADD sp, sp, #17
1997		POP {pc}
1998	L57:
1999	L55:
2000	L53:
2001		MOV r4, #1
2002		MOV r0, r4
2003		ADD sp, sp, #17
2004		POP {pc}
2005		POP {pc}
2006		.ltorg
2007	f_findMoveWithGivenValueRow:
2008		PUSH {lr}
2009		SUB sp, sp, #17
2010		LDR r4, [sp, #21]
2011		MOV r0, r4
2012		BL p_check_null_pointer
2013		LDR r4, [r4]
2014		LDR r4, [r4]
2015		STR r4, [sp, #13]
2016		LDR r4, [sp, #13]
2017		MOV r0, r4
2018		BL p_check_null_pointer
2019		LDR r4, [r4]
2020		LDR r4, [r4]
2021		STR r4, [sp, #9]
2022		LDR r4, [sp, #13]
2023		MOV r0, r4
2024		BL p_check_null_pointer
2025		LDR r4, [r4, #4]
2026		LDR r4, [r4]
2027		STR r4, [sp, #5]
2028		LDR r4, [sp, #21]
2029		MOV r0, r4
2030		BL p_check_null_pointer
2031		LDR r4, [r4, #4]
2032		LDR r4, [r4]
2033		STR r4, [sp, #1]
2034		LDR r4, [sp, #25]
2035		STR r4, [sp, #-4]!
2036		LDR r4, [sp, #13]
2037		STR r4, [sp, #-4]!
2038		BL f_hasGivenStateValue
2039		ADD sp, sp, #8
2040		MOV r4, r0
2041		STRB r4, [sp]
2042		LDRSB r4, [sp]
2043		CMP r4, #0
2044		BEQ L58
2045		LDR r4, =1
2046		ADD r5, sp, #29
2047		LDR r6, =1
2048		LDR r5, [r5]
2049		MOV r0, r6
2050		MOV r1, r5
2051		BL p_check_array_bounds
2052		ADD r5, r5, #4
2053		ADD r5, r5, r6, LSL #2
2054		STR r4, [r5]
2055		B L59
2056	L58:
2057		LDR r4, [sp, #25]
2058		STR r4, [sp, #-4]!
2059		LDR r4, [sp, #9]
2060		STR r4, [sp, #-4]!
2061		BL f_hasGivenStateValue
2062		ADD sp, sp, #8
2063		MOV r4, r0
2064		STRB r4, [sp]
2065		LDRSB r4, [sp]
2066		CMP r4, #0
2067		BEQ L60
2068		LDR r4, =2
2069		ADD r6, sp, #29
2070		LDR r7, =1
2071		LDR r6, [r6]
2072		MOV r0, r7
2073		MOV r1, r6
2074		BL p_check_array_bounds
2075		ADD r6, r6, #4
2076		ADD r6, r6, r7, LSL #2
2077		STR r4, [r6]
2078		B L61
2079	L60:
2080		LDR r4, [sp, #25]
2081		STR r4, [sp, #-4]!
2082		LDR r4, [sp, #5]
2083		STR r4, [sp, #-4]!
2084		BL f_hasGivenStateValue
2085		ADD sp, sp, #8
2086		MOV r4, r0
2087		STRB r4, [sp]
2088		LDRSB r4, [sp]
2089		CMP r4, #0
2090		BEQ L62
2091		LDR r4, =3
2092		ADD r7, sp, #29
2093		LDR r8, =1
2094		LDR r7, [r7]
2095		MOV r0, r8
2096		MOV r1, r7
2097		BL p_check_array_bounds
2098		ADD r7, r7, #4
2099		ADD r7, r7, r8, LSL #2
2100		STR r4, [r7]
2101		B L63
2102	L62:
2103		MOV r4, #0
2104		MOV r0, r4
2105		ADD sp, sp, #17
2106		POP {pc}
2107	L63:
2108	L61:
2109	L59:
2110		MOV r4, #1
2111		MOV r0, r4
2112		ADD sp, sp, #17
2113		POP {pc}
2114		POP {pc}
2115		.ltorg
2116	f_hasGivenStateValue:
2117		PUSH {lr}
2118		LDR r4, [sp, #4]
2119		LDR r5, =0
2120		CMP r4, r5
2121		MOVEQ r4, #1
2122		MOVNE r4, #0
2123		CMP r4, #0
2124		BEQ L64
2125		MOV r4, #0
2126		MOV r0, r4
2127		POP {pc}
2128		B L65
2129	L64:
2130		SUB sp, sp, #4
2131		LDR r4, [sp, #8]
2132		MOV r0, r4
2133		BL p_check_null_pointer
2134		LDR r4, [r4, #4]
2135		LDR r4, [r4]
2136		STR r4, [sp]
2137		LDR r4, [sp]
2138		LDR r5, [sp, #12]
2139		CMP r4, r5
2140		MOVEQ r4, #1
2141		MOVNE r4, #0
2142		MOV r0, r4
2143		ADD sp, sp, #4
2144		POP {pc}
2145		ADD sp, sp, #4
2146	L65:
2147		POP {pc}
2148		.ltorg
2149	f_notifyMoveAI:
2150		PUSH {lr}
2151		SUB sp, sp, #13
2152		LDR r4, [sp, #23]
2153		MOV r0, r4
2154		BL p_check_null_pointer
2155		LDR r4, [r4, #4]
2156		LDR r4, [r4]
2157		STR r4, [sp, #9]
2158		LDR r4, [sp, #9]
2159		MOV r0, r4
2160		BL p_check_null_pointer
2161		LDR r4, [r4]
2162		LDR r4, [r4]
2163		STR r4, [sp, #5]
2164		LDR r4, [sp, #5]
2165		MOV r0, r4
2166		BL p_check_null_pointer
2167		LDR r4, [r4, #4]
2168		LDR r4, [r4]
2169		STR r4, [sp, #1]
2170		LDR r4, =msg_32
2171		MOV r0, r4
2172		BL p_print_string
2173		BL p_print_ln
2174		LDR r4, [sp, #31]
2175		STR r4, [sp, #-4]!
2176		LDR r4, [sp, #31]
2177		STR r4, [sp, #-4]!
2178		LDR r4, [sp, #9]
2179		STR r4, [sp, #-4]!
2180		BL f_deleteAllOtherChildren
2181		ADD sp, sp, #12
2182		MOV r4, r0
2183		LDR r5, [sp, #23]
2184		MOV r0, r5
2185		BL p_check_null_pointer
2186		LDR r5, [r5, #4]
2187		STR r4, [r5]
2188		LDR r4, [sp, #9]
2189		STR r4, [sp, #-4]!
2190		BL f_deleteThisStateOnly
2191		ADD sp, sp, #4
2192		MOV r4, r0
2193		STRB r4, [sp]
2194		MOV r4, #1
2195		MOV r0, r4
2196		ADD sp, sp, #13
2197		POP {pc}
2198		POP {pc}
2199		.ltorg
2200	f_deleteAllOtherChildren:
2201		PUSH {lr}
2202		SUB sp, sp, #33
2203		LDR r4, [sp, #37]
2204		MOV r0, r4
2205		BL p_check_null_pointer
2206		LDR r4, [r4]
2207		LDR r4, [r4]
2208		STR r4, [sp, #29]
2209		LDR r4, [sp, #29]
2210		MOV r0, r4
2211		BL p_check_null_pointer
2212		LDR r4, [r4]
2213		LDR r4, [r4]
2214		STR r4, [sp, #25]
2215		LDR r4, [sp, #29]
2216		MOV r0, r4
2217		BL p_check_null_pointer
2218		LDR r4, [r4, #4]
2219		LDR r4, [r4]
2220		STR r4, [sp, #21]
2221		LDR r4, [sp, #37]
2222		MOV r0, r4
2223		BL p_check_null_pointer
2224		LDR r4, [r4, #4]
2225		LDR r4, [r4]
2226		STR r4, [sp, #17]
2227		LDR r4, =0
2228		STR r4, [sp, #13]
2229		LDR r4, =0
2230		STR r4, [sp, #9]
2231		LDR r4, =0
2232		STR r4, [sp, #5]
2233		LDR r4, [sp, #41]
2234		LDR r5, =1
2235		CMP r4, r5
2236		MOVEQ r4, #1
2237		MOVNE r4, #0
2238		CMP r4, #0
2239		BEQ L66
2240		LDR r4, [sp, #25]
2241		STR r4, [sp, #13]
2242		LDR r4, [sp, #21]
2243		STR r4, [sp, #9]
2244		LDR r4, [sp, #17]
2245		STR r4, [sp, #5]
2246		B L67
2247	L66:
2248		LDR r4, [sp, #25]
2249		STR r4, [sp, #9]
2250		LDR r4, [sp, #41]
2251		LDR r5, =2
2252		CMP r4, r5
2253		MOVEQ r4, #1
2254		MOVNE r4, #0
2255		CMP r4, #0
2256		BEQ L68
2257		LDR r4, [sp, #21]
2258		STR r4, [sp, #13]
2259		LDR r4, [sp, #17]
2260		STR r4, [sp, #5]
2261		B L69
2262	L68:
2263		LDR r4, [sp, #17]
2264		STR r4, [sp, #13]
2265		LDR r4, [sp, #21]
2266		STR r4, [sp, #5]
2267	L69:
2268	L67:
2269		LDR r4, [sp, #45]
2270		STR r4, [sp, #-4]!
2271		LDR r4, [sp, #17]
2272		STR r4, [sp, #-4]!
2273		BL f_deleteAllOtherChildrenRow
2274		ADD sp, sp, #8
2275		MOV r4, r0
2276		STR r4, [sp, #1]
2277		LDR r4, [sp, #9]
2278		STR r4, [sp, #-4]!
2279		BL f_deleteChildrenStateRecursivelyRow
2280		ADD sp, sp, #4
2281		MOV r4, r0
2282		STRB r4, [sp]
2283		LDR r4, [sp, #5]
2284		STR r4, [sp, #-4]!
2285		BL f_deleteChildrenStateRecursivelyRow
2286		ADD sp, sp, #4
2287		MOV r4, r0
2288		STRB r4, [sp]
2289		LDR r4, [sp, #1]
2290		MOV r0, r4
2291		ADD sp, sp, #33
2292		POP {pc}
2293		POP {pc}
2294		.ltorg
2295	f_deleteAllOtherChildrenRow:
2296		PUSH {lr}
2297		SUB sp, sp, #29
2298		LDR r4, [sp, #33]
2299		MOV r0, r4
2300		BL p_check_null_pointer
2301		LDR r4, [r4]
2302		LDR r4, [r4]
2303		STR r4, [sp, #25]
2304		LDR r4, [sp, #25]
2305		MOV r0, r4
2306		BL p_check_null_pointer
2307		LDR r4, [r4]
2308		LDR r4, [r4]
2309		STR r4, [sp, #21]
2310		LDR r4, [sp, #25]
2311		MOV r0, r4
2312		BL p_check_null_pointer
2313		LDR r4, [r4, #4]
2314		LDR r4, [r4]
2315		STR r4, [sp, #17]
2316		LDR r4, [sp, #33]
2317		MOV r0, r4
2318		BL p_check_null_pointer
2319		LDR r4, [r4, #4]
2320		LDR r4, [r4]
2321		STR r4, [sp, #13]
2322		LDR r4, =0
2323		STR r4, [sp, #9]
2324		LDR r4, =0
2325		STR r4, [sp, #5]
2326		LDR r4, =0
2327		STR r4, [sp, #1]
2328		LDR r4, [sp, #37]
2329		LDR r5, =1
2330		CMP r4, r5
2331		MOVEQ r4, #1
2332		MOVNE r4, #0
2333		CMP r4, #0
2334		BEQ L70
2335		LDR r4, [sp, #21]
2336		STR r4, [sp, #9]
2337		LDR r4, [sp, #17]
2338		STR r4, [sp, #5]
2339		LDR r4, [sp, #13]
2340		STR r4, [sp, #1]
2341		B L71
2342	L70:
2343		LDR r4, [sp, #21]
2344		STR r4, [sp, #5]
2345		LDR r4, [sp, #37]
2346		LDR r5, =2
2347		CMP r4, r5
2348		MOVEQ r4, #1
2349		MOVNE r4, #0
2350		CMP r4, #0
2351		BEQ L72
2352		LDR r4, [sp, #17]
2353		STR r4, [sp, #9]
2354		LDR r4, [sp, #13]
2355		STR r4, [sp, #1]
2356		B L73
2357	L72:
2358		LDR r4, [sp, #13]
2359		STR r4, [sp, #9]
2360		LDR r4, [sp, #17]
2361		STR r4, [sp, #1]
2362	L73:
2363	L71:
2364		LDR r4, [sp, #5]
2365		STR r4, [sp, #-4]!
2366		BL f_deleteStateTreeRecursively
2367		ADD sp, sp, #4
2368		MOV r4, r0
2369		STRB r4, [sp]
2370		LDR r4, [sp, #1]
2371		STR r4, [sp, #-4]!
2372		BL f_deleteStateTreeRecursively
2373		ADD sp, sp, #4
2374		MOV r4, r0
2375		STRB r4, [sp]
2376		LDR r4, [sp, #9]
2377		MOV r0, r4
2378		ADD sp, sp, #29
2379		POP {pc}
2380		POP {pc}
2381		.ltorg
2382	f_deleteStateTreeRecursively:
2383		PUSH {lr}
2384		LDR r4, [sp, #4]
2385		LDR r5, =0
2386		CMP r4, r5
2387		MOVEQ r4, #1
2388		MOVNE r4, #0
2389		CMP r4, #0
2390		BEQ L74
2391		MOV r4, #1
2392		MOV r0, r4
2393		POP {pc}
2394		B L75
2395	L74:
2396		SUB sp, sp, #13
2397		LDR r4, [sp, #17]
2398		MOV r0, r4
2399		BL p_check_null_pointer
2400		LDR r4, [r4]
2401		LDR r4, [r4]
2402		STR r4, [sp, #9]
2403		LDR r4, [sp, #9]
2404		MOV r0, r4
2405		BL p_check_null_pointer
2406		LDR r4, [r4]
2407		LDR r4, [r4]
2408		STR r4, [sp, #5]
2409		LDR r4, [sp, #9]
2410		MOV r0, r4
2411		BL p_check_null_pointer
2412		LDR r4, [r4, #4]
2413		LDR r4, [r4]
2414		STR r4, [sp, #1]
2415		LDR r4, [sp, #1]
2416		STR r4, [sp, #-4]!
2417		BL f_deleteChildrenStateRecursively
2418		ADD sp, sp, #4
2419		MOV r4, r0
2420		STRB r4, [sp]
2421		LDR r4, [sp, #17]
2422		STR r4, [sp, #-4]!
2423		BL f_deleteThisStateOnly
2424		ADD sp, sp, #4
2425		MOV r4, r0
2426		STRB r4, [sp]
2427		MOV r4, #1
2428		MOV r0, r4
2429		ADD sp, sp, #13
2430		POP {pc}
2431		ADD sp, sp, #13
2432	L75:
2433		POP {pc}
2434		.ltorg
2435	f_deleteThisStateOnly:
2436		PUSH {lr}
2437		SUB sp, sp, #13
2438		LDR r4, [sp, #17]
2439		MOV r0, r4
2440		BL p_check_null_pointer
2441		LDR r4, [r4]
2442		LDR r4, [r4]
2443		STR r4, [sp, #9]
2444		LDR r4, [sp, #9]
2445		MOV r0, r4
2446		BL p_check_null_pointer
2447		LDR r4, [r4]
2448		LDR r4, [r4]
2449		STR r4, [sp, #5]
2450		LDR r4, [sp, #9]
2451		MOV r0, r4
2452		BL p_check_null_pointer
2453		LDR r4, [r4, #4]
2454		LDR r4, [r4]
2455		STR r4, [sp, #1]
2456		LDR r4, [sp, #5]
2457		STR r4, [sp, #-4]!
2458		BL f_freeBoard
2459		ADD sp, sp, #4
2460		MOV r4, r0
2461		STRB r4, [sp]
2462		LDR r4, [sp, #1]
2463		STR r4, [sp, #-4]!
2464		BL f_freePointers
2465		ADD sp, sp, #4
2466		MOV r4, r0
2467		STRB r4, [sp]
2468		LDR r4, [sp, #9]
2469		MOV r0, r4
2470		BL p_free_pair
2471		LDR r4, [sp, #17]
2472		MOV r0, r4
2473		BL p_free_pair
2474		MOV r4, #1
2475		MOV r0, r4
2476		ADD sp, sp, #13
2477		POP {pc}
2478		POP {pc}
2479		.ltorg
2480	f_freePointers:
2481		PUSH {lr}
2482		SUB sp, sp, #17
2483		LDR r4, [sp, #21]
2484		MOV r0, r4
2485		BL p_check_null_pointer
2486		LDR r4, [r4]
2487		LDR r4, [r4]
2488		STR r4, [sp, #13]
2489		LDR r4, [sp, #13]
2490		MOV r0, r4
2491		BL p_check_null_pointer
2492		LDR r4, [r4]
2493		LDR r4, [r4]
2494		STR r4, [sp, #9]
2495		LDR r4, [sp, #13]
2496		MOV r0, r4
2497		BL p_check_null_pointer
2498		LDR r4, [r4, #4]
2499		LDR r4, [r4]
2500		STR r4, [sp, #5]
2501		LDR r4, [sp, #21]
2502		MOV r0, r4
2503		BL p_check_null_pointer
2504		LDR r4, [r4, #4]
2505		LDR r4, [r4]
2506		STR r4, [sp, #1]
2507		LDR r4, [sp, #9]
2508		STR r4, [sp, #-4]!
2509		BL f_freePointersRow
2510		ADD sp, sp, #4
2511		MOV r4, r0
2512		STRB r4, [sp]
2513		LDR r4, [sp, #5]
2514		STR r4, [sp, #-4]!
2515		BL f_freePointersRow
2516		ADD sp, sp, #4
2517		MOV r4, r0
2518		STRB r4, [sp]
2519		LDR r4, [sp, #1]
2520		STR r4, [sp, #-4]!
2521		BL f_freePointersRow
2522		ADD sp, sp, #4
2523		MOV r4, r0
2524		STRB r4, [sp]
2525		LDR r4, [sp, #13]
2526		MOV r0, r4
2527		BL p_free_pair
2528		LDR r4, [sp, #21]
2529		MOV r0, r4
2530		BL p_free_pair
2531		MOV r4, #1
2532		MOV r0, r4
2533		ADD sp, sp, #17
2534		POP {pc}
2535		POP {pc}
2536		.ltorg
2537	f_freePointersRow:
2538		PUSH {lr}
2539		SUB sp, sp, #4
2540		LDR r4, [sp, #8]
2541		MOV r0, r4
2542		BL p_check_null_pointer
2543		LDR r4, [r4]
2544		LDR r4, [r4]
2545		STR r4, [sp]
2546		LDR r4, [sp]
2547		MOV r0, r4
2548		BL p_free_pair
2549		LDR r4, [sp, #8]
2550		MOV r0, r4
2551		BL p_free_pair
2552		MOV r4, #1
2553		MOV r0, r4
2554		ADD sp, sp, #4
2555		POP {pc}
2556		POP {pc}
2557		.ltorg
2558	f_deleteChildrenStateRecursively:
2559		PUSH {lr}
2560		SUB sp, sp, #17
2561		LDR r4, [sp, #21]
2562		MOV r0, r4
2563		BL p_check_null_pointer
2564		LDR r4, [r4]
2565		LDR r4, [r4]
2566		STR r4, [sp, #13]
2567		LDR r4, [sp, #13]
2568		MOV r0, r4
2569		BL p_check_null_pointer
2570		LDR r4, [r4]
2571		LDR r4, [r4]
2572		STR r4, [sp, #9]
2573		LDR r4, [sp, #13]
2574		MOV r0, r4
2575		BL p_check_null_pointer
2576		LDR r4, [r4, #4]
2577		LDR r4, [r4]
2578		STR r4, [sp, #5]
2579		LDR r4, [sp, #21]
2580		MOV r0, r4
2581		BL p_check_null_pointer
2582		LDR r4, [r4, #4]
2583		LDR r4, [r4]
2584		STR r4, [sp, #1]
2585		LDR r4, [sp, #9]
2586		STR r4, [sp, #-4]!
2587		BL f_deleteChildrenStateRecursivelyRow
2588		ADD sp, sp, #4
2589		MOV r4, r0
2590		STRB r4, [sp]
2591		LDR r4, [sp, #5]
2592		STR r4, [sp, #-4]!
2593		BL f_deleteChildrenStateRecursivelyRow
2594		ADD sp, sp, #4
2595		MOV r4, r0
2596		STRB r4, [sp]
2597		LDR r4, [sp, #1]
2598		STR r4, [sp, #-4]!
2599		BL f_deleteChildrenStateRecursivelyRow
2600		ADD sp, sp, #4
2601		MOV r4, r0
2602		STRB r4, [sp]
2603		MOV r4, #1
2604		MOV r0, r4
2605		ADD sp, sp, #17
2606		POP {pc}
2607		POP {pc}
2608		.ltorg
2609	f_deleteChildrenStateRecursivelyRow:
2610		PUSH {lr}
2611		SUB sp, sp, #17
2612		LDR r4, [sp, #21]
2613		MOV r0, r4
2614		BL p_check_null_pointer
2615		LDR r4, [r4]
2616		LDR r4, [r4]
2617		STR r4, [sp, #13]
2618		LDR r4, [sp, #13]
2619		MOV r0, r4
2620		BL p_check_null_pointer
2621		LDR r4, [r4]
2622		LDR r4, [r4]
2623		STR r4, [sp, #9]
2624		LDR r4, [sp, #13]
2625		MOV r0, r4
2626		BL p_check_null_pointer
2627		LDR r4, [r4, #4]
2628		LDR r4, [r4]
2629		STR r4, [sp, #5]
2630		LDR r4, [sp, #21]
2631		MOV r0, r4
2632		BL p_check_null_pointer
2633		LDR r4, [r4, #4]
2634		LDR r4, [r4]
2635		STR r4, [sp, #1]
2636		LDR r4, [sp, #9]
2637		STR r4, [sp, #-4]!
2638		BL f_deleteStateTreeRecursively
2639		ADD sp, sp, #4
2640		MOV r4, r0
2641		STRB r4, [sp]
2642		LDR r4, [sp, #5]
2643		STR r4, [sp, #-4]!
2644		BL f_deleteStateTreeRecursively
2645		ADD sp, sp, #4
2646		MOV r4, r0
2647		STRB r4, [sp]
2648		LDR r4, [sp, #1]
2649		STR r4, [sp, #-4]!
2650		BL f_deleteStateTreeRecursively
2651		ADD sp, sp, #4
2652		MOV r4, r0
2653		STRB r4, [sp]
2654		MOV r4, #1
2655		MOV r0, r4
2656		ADD sp, sp, #17
2657		POP {pc}
2658		POP {pc}
2659		.ltorg
2660	f_askForAMove:
2661		PUSH {lr}
2662		LDRSB r4, [sp, #8]
2663		LDRSB r5, [sp, #9]
2664		CMP r4, r5
2665		MOVEQ r4, #1
2666		MOVNE r4, #0
2667		CMP r4, #0
2668		BEQ L76
2669		SUB sp, sp, #1
2670		LDR r4, [sp, #15]
2671		STR r4, [sp, #-4]!
2672		LDR r4, [sp, #9]
2673		STR r4, [sp, #-4]!
2674		BL f_askForAMoveHuman
2675		ADD sp, sp, #8
2676		MOV r4, r0
2677		STRB r4, [sp]
2678		ADD sp, sp, #1
2679		B L77
2680	L76:
2681		SUB sp, sp, #1
2682		LDR r4, [sp, #15]
2683		STR r4, [sp, #-4]!
2684		LDR r4, [sp, #15]
2685		STR r4, [sp, #-4]!
2686		LDRSB r4, [sp, #18]
2687		STRB r4, [sp, #-1]!
2688		LDRSB r4, [sp, #18]
2689		STRB r4, [sp, #-1]!
2690		LDR r4, [sp, #15]
2691		STR r4, [sp, #-4]!
2692		BL f_askForAMoveAI
2693		ADD sp, sp, #14
2694		MOV r4, r0
2695		STRB r4, [sp]
2696		ADD sp, sp, #1
2697	L77:
2698		MOV r4, #1
2699		MOV r0, r4
2700		POP {pc}
2701		POP {pc}
2702		.ltorg
2703	f_placeMove:
2704		PUSH {lr}
2705		SUB sp, sp, #4
2706		LDR r4, =0
2707		STR r4, [sp]
2708		LDR r4, [sp, #13]
2709		LDR r5, =2
2710		CMP r4, r5
2711		MOVLE r4, #1
2712		MOVGT r4, #0
2713		CMP r4, #0
2714		BEQ L78
2715		SUB sp, sp, #4
2716		LDR r4, [sp, #12]
2717		MOV r0, r4
2718		BL p_check_null_pointer
2719		LDR r4, [r4]
2720		LDR r4, [r4]
2721		STR r4, [sp]
2722		LDR r4, [sp, #17]
2723		LDR r5, =1
2724		CMP r4, r5
2725		MOVEQ r4, #1
2726		MOVNE r4, #0
2727		CMP r4, #0
2728		BEQ L80
2729		LDR r4, [sp]
2730		MOV r0, r4
2731		BL p_check_null_pointer
2732		LDR r4, [r4]
2733		LDR r4, [r4]
2734		STR r4, [sp, #4]
2735		B L81
2736	L80:
2737		LDR r4, [sp]
2738		MOV r0, r4
2739		BL p_check_null_pointer
2740		LDR r4, [r4, #4]
2741		LDR r4, [r4]
2742		STR r4, [sp, #4]
2743	L81:
2744		ADD sp, sp, #4
2745		B L79
2746	L78:
2747		LDR r4, [sp, #8]
2748		MOV r0, r4
2749		BL p_check_null_pointer
2750		LDR r4, [r4, #4]
2751		LDR r4, [r4]
2752		STR r4, [sp]
2753	L79:
2754		LDR r4, [sp, #17]
2755		LDR r5, =2
2756		CMP r4, r5
2757		MOVLE r4, #1
2758		MOVGT r4, #0
2759		CMP r4, #0
2760		BEQ L82
2761		SUB sp, sp, #4
2762		LDR r4, [sp, #4]
2763		MOV r0, r4
2764		BL p_check_null_pointer
2765		LDR r4, [r4]
2766		LDR r4, [r4]
2767		STR r4, [sp]
2768		LDR r4, [sp, #21]
2769		LDR r5, =1
2770		CMP r4, r5
2771		MOVEQ r4, #1
2772		MOVNE r4, #0
2773		CMP r4, #0
2774		BEQ L84
2775		LDRSB r4, [sp, #16]
2776		LDR r5, [sp]
2777		MOV r0, r5
2778		BL p_check_null_pointer
2779		LDR r5, [r5]
2780		STRB r4, [r5]
2781		B L85
2782	L84:
2783		LDRSB r4, [sp, #16]
2784		LDR r5, [sp]
2785		MOV r0, r5
2786		BL p_check_null_pointer
2787		LDR r5, [r5, #4]
2788		STRB r4, [r5]
2789	L85:
2790		ADD sp, sp, #4
2791		B L83
2792	L82:
2793		LDRSB r4, [sp, #12]
2794		LDR r5, [sp]
2795		MOV r0, r5
2796		BL p_check_null_pointer
2797		LDR r5, [r5, #4]
2798		STRB r4, [r5]
2799	L83:
2800		MOV r4, #1
2801		MOV r0, r4
2802		ADD sp, sp, #4
2803		POP {pc}
2804		POP {pc}
2805		.ltorg
2806	f_notifyMove:
2807		PUSH {lr}
2808		LDRSB r4, [sp, #8]
2809		LDRSB r5, [sp, #9]
2810		CMP r4, r5
2811		MOVEQ r4, #1
2812		MOVNE r4, #0
2813		CMP r4, #0
2814		BEQ L86
2815		SUB sp, sp, #1
2816		LDR r4, [sp, #19]
2817		STR r4, [sp, #-4]!
2818		LDR r4, [sp, #19]
2819		STR r4, [sp, #-4]!
2820		LDR r4, [sp, #19]
2821		STR r4, [sp, #-4]!
2822		LDRSB r4, [sp, #22]
2823		STRB r4, [sp, #-1]!
2824		LDRSB r4, [sp, #22]
2825		STRB r4, [sp, #-1]!
2826		LDR r4, [sp, #19]
2827		STR r4, [sp, #-4]!
2828		BL f_notifyMoveAI
2829		ADD sp, sp, #18
2830		MOV r4, r0
2831		STRB r4, [sp]
2832		ADD sp, sp, #1
2833		B L87
2834	L86:
2835		SUB sp, sp, #1
2836		LDR r4, [sp, #19]
2837		STR r4, [sp, #-4]!
2838		LDR r4, [sp, #19]
2839		STR r4, [sp, #-4]!
2840		LDRSB r4, [sp, #18]
2841		STRB r4, [sp, #-1]!
2842		LDRSB r4, [sp, #18]
2843		STRB r4, [sp, #-1]!
2844		LDR r4, [sp, #15]
2845		STR r4, [sp, #-4]!
2846		BL f_notifyMoveHuman
2847		ADD sp, sp, #14
2848		MOV r4, r0
2849		STRB r4, [sp]
2850		ADD sp, sp, #1
2851	L87:
2852		MOV r4, #1
2853		MOV r0, r4
2854		POP {pc}
2855		POP {pc}
2856		.ltorg
2857	f_oppositeSymbol:
2858		PUSH {lr}
2859		LDRSB r4, [sp, #4]
2860		MOV r5, #'x'
2861		CMP r4, r5
2862		MOVEQ r4, #1
2863		MOVNE r4, #0
2864		CMP r4, #0
2865		BEQ L88
2866		MOV r4, #'o'
2867		MOV r0, r4
2868		POP {pc}
2869		B L89
2870	L88:
2871		LDRSB r4, [sp, #4]
2872		MOV r5, #'o'
2873		CMP r4, r5
2874		MOVEQ r4, #1
2875		MOVNE r4, #0
2876		CMP r4, #0
2877		BEQ L90
2878		MOV r4, #'x'
2879		MOV r0, r4
2880		POP {pc}
2881		B L91
2882	L90:
2883		LDR r4, =msg_33
2884		MOV r0, r4
2885		BL p_print_string
2886		BL p_print_ln
2887		LDR r4, =-1
2888		MOV r0, r4
2889		BL exit
2890	L91:
2891	L89:
2892		POP {pc}
2893		.ltorg
2894	f_symbolAt:
2895		PUSH {lr}
2896		SUB sp, sp, #5
2897		LDR r4, =0
2898		STR r4, [sp, #1]
2899		LDR r4, [sp, #13]
2900		LDR r5, =2
2901		CMP r4, r5
2902		MOVLE r4, #1
2903		MOVGT r4, #0
2904		CMP r4, #0
2905		BEQ L92
2906		SUB sp, sp, #4
2907		LDR r4, [sp, #13]
2908		MOV r0, r4
2909		BL p_check_null_pointer
2910		LDR r4, [r4]
2911		LDR r4, [r4]
2912		STR r4, [sp]
2913		LDR r4, [sp, #17]
2914		LDR r5, =1
2915		CMP r4, r5
2916		MOVEQ r4, #1
2917		MOVNE r4, #0
2918		CMP r4, #0
2919		BEQ L94
2920		LDR r4, [sp]
2921		MOV r0, r4
2922		BL p_check_null_pointer
2923		LDR r4, [r4]
2924		LDR r4, [r4]
2925		STR r4, [sp, #5]
2926		B L95
2927	L94:
2928		LDR r4, [sp]
2929		MOV r0, r4
2930		BL p_check_null_pointer
2931		LDR r4, [r4, #4]
2932		LDR r4, [r4]
2933		STR r4, [sp, #5]
2934	L95:
2935		ADD sp, sp, #4
2936		B L93
2937	L92:
2938		LDR r4, [sp, #9]
2939		MOV r0, r4
2940		BL p_check_null_pointer
2941		LDR r4, [r4, #4]
2942		LDR r4, [r4]
2943		STR r4, [sp, #1]
2944	L93:
2945		MOV r4, #0
2946		STRB r4, [sp]
2947		LDR r4, [sp, #17]
2948		LDR r5, =2
2949		CMP r4, r5
2950		MOVLE r4, #1
2951		MOVGT r4, #0
2952		CMP r4, #0
2953		BEQ L96
2954		SUB sp, sp, #4
2955		LDR r4, [sp, #5]
2956		MOV r0, r4
2957		BL p_check_null_pointer
2958		LDR r4, [r4]
2959		LDR r4, [r4]
2960		STR r4, [sp]
2961		LDR r4, [sp, #21]
2962		LDR r5, =1
2963		CMP r4, r5
2964		MOVEQ r4, #1
2965		MOVNE r4, #0
2966		CMP r4, #0
2967		BEQ L98
2968		LDR r4, [sp]
2969		MOV r0, r4
2970		BL p_check_null_pointer
2971		LDR r4, [r4]
2972		LDRSB r4, [r4]
2973		STRB r4, [sp, #4]
2974		B L99
2975	L98:
2976		LDR r4, [sp]
2977		MOV r0, r4
2978		BL p_check_null_pointer
2979		LDR r4, [r4, #4]
2980		LDRSB r4, [r4]
2981		STRB r4, [sp, #4]
2982	L99:
2983		ADD sp, sp, #4
2984		B L97
2985	L96:
2986		LDR r4, [sp, #1]
2987		MOV r0, r4
2988		BL p_check_null_pointer
2989		LDR r4, [r4, #4]
2990		LDRSB r4, [r4]
2991		STRB r4, [sp]
2992	L97:
2993		LDRSB r4, [sp]
2994		MOV r0, r4
2995		ADD sp, sp, #5
2996		POP {pc}
2997		POP {pc}
2998		.ltorg
2999	f_containEmptyCell:
3000		PUSH {lr}
3001		SUB sp, sp, #19
3002		LDR r4, [sp, #23]
3003		MOV r0, r4
3004		BL p_check_null_pointer
3005		LDR r4, [r4]
3006		LDR r4, [r4]
3007		STR r4, [sp, #15]
3008		LDR r4, [sp, #15]
3009		MOV r0, r4
3010		BL p_check_null_pointer
3011		LDR r4, [r4]
3012		LDR r4, [r4]
3013		STR r4, [sp, #11]
3014		LDR r4, [sp, #15]
3015		MOV r0, r4
3016		BL p_check_null_pointer
3017		LDR r4, [r4, #4]
3018		LDR r4, [r4]
3019		STR r4, [sp, #7]
3020		LDR r4, [sp, #23]
3021		MOV r0, r4
3022		BL p_check_null_pointer
3023		LDR r4, [r4, #4]
3024		LDR r4, [r4]
3025		STR r4, [sp, #3]
3026		LDR r4, [sp, #11]
3027		STR r4, [sp, #-4]!
3028		BL f_containEmptyCellRow
3029		ADD sp, sp, #4
3030		MOV r4, r0
3031		STRB r4, [sp, #2]
3032		LDR r4, [sp, #7]
3033		STR r4, [sp, #-4]!
3034		BL f_containEmptyCellRow
3035		ADD sp, sp, #4
3036		MOV r4, r0
3037		STRB r4, [sp, #1]
3038		LDR r4, [sp, #3]
3039		STR r4, [sp, #-4]!
3040		BL f_containEmptyCellRow
3041		ADD sp, sp, #4
3042		MOV r4, r0
3043		STRB r4, [sp]
3044		LDRSB r4, [sp, #2]
3045		LDRSB r5, [sp, #1]
3046		ORR r4, r4, r5
3047		LDRSB r5, [sp]
3048		ORR r4, r4, r5
3049		MOV r0, r4
3050		ADD sp, sp, #19
3051		POP {pc}
3052		POP {pc}
3053		.ltorg
3054	f_containEmptyCellRow:
3055		PUSH {lr}
3056		SUB sp, sp, #7
3057		LDR r4, [sp, #11]
3058		MOV r0, r4
3059		BL p_check_null_pointer
3060		LDR r4, [r4]
3061		LDR r4, [r4]
3062		STR r4, [sp, #3]
3063		LDR r4, [sp, #3]
3064		MOV r0, r4
3065		BL p_check_null_pointer
3066		LDR r4, [r4]
3067		LDRSB r4, [r4]
3068		STRB r4, [sp, #2]
3069		LDR r4, [sp, #3]
3070		MOV r0, r4
3071		BL p_check_null_pointer
3072		LDR r4, [r4, #4]
3073		LDRSB r4, [r4]
3074		STRB r4, [sp, #1]
3075		LDR r4, [sp, #11]
3076		MOV r0, r4
3077		BL p_check_null_pointer
3078		LDR r4, [r4, #4]
3079		LDRSB r4, [r4]
3080		STRB r4, [sp]
3081		LDRSB r4, [sp, #2]
3082		MOV r5, #0
3083		CMP r4, r5
3084		MOVEQ r4, #1
3085		MOVNE r4, #0
3086		LDRSB r5, [sp, #1]
3087		MOV r6, #0
3088		CMP r5, r6
3089		MOVEQ r5, #1
3090		MOVNE r5, #0
3091		ORR r4, r4, r5
3092		LDRSB r5, [sp]
3093		MOV r6, #0
3094		CMP r5, r6
3095		MOVEQ r5, #1
3096		MOVNE r5, #0
3097		ORR r4, r4, r5
3098		MOV r0, r4
3099		ADD sp, sp, #7
3100		POP {pc}
3101		POP {pc}
3102		.ltorg
3103	f_hasWon:
3104		PUSH {lr}
3105		SUB sp, sp, #9
3106		LDR r4, =1
3107		STR r4, [sp, #-4]!
3108		LDR r4, =1
3109		STR r4, [sp, #-4]!
3110		LDR r4, [sp, #21]
3111		STR r4, [sp, #-4]!
3112		BL f_symbolAt
3113		ADD sp, sp, #12
3114		MOV r4, r0
3115		STRB r4, [sp, #8]
3116		LDR r4, =2
3117		STR r4, [sp, #-4]!
3118		LDR r4, =1
3119		STR r4, [sp, #-4]!
3120		LDR r4, [sp, #21]
3121		STR r4, [sp, #-4]!
3122		BL f_symbolAt
3123		ADD sp, sp, #12
3124		MOV r4, r0
3125		STRB r4, [sp, #7]
3126		LDR r4, =3
3127		STR r4, [sp, #-4]!
3128		LDR r4, =1
3129		STR r4, [sp, #-4]!
3130		LDR r4, [sp, #21]
3131		STR r4, [sp, #-4]!
3132		BL f_symbolAt
3133		ADD sp, sp, #12
3134		MOV r4, r0
3135		STRB r4, [sp, #6]
3136		LDR r4, =1
3137		STR r4, [sp, #-4]!
3138		LDR r4, =2
3139		STR r4, [sp, #-4]!
3140		LDR r4, [sp, #21]
3141		STR r4, [sp, #-4]!
3142		BL f_symbolAt
3143		ADD sp, sp, #12
3144		MOV r4, r0
3145		STRB r4, [sp, #5]
3146		LDR r4, =2
3147		STR r4, [sp, #-4]!
3148		LDR r4, =2
3149		STR r4, [sp, #-4]!
3150		LDR r4, [sp, #21]
3151		STR r4, [sp, #-4]!
3152		BL f_symbolAt
3153		ADD sp, sp, #12
3154		MOV r4, r0
3155		STRB r4, [sp, #4]
3156		LDR r4, =3
3157		STR r4, [sp, #-4]!
3158		LDR r4, =2
3159		STR r4, [sp, #-4]!
3160		LDR r4, [sp, #21]
3161		STR r4, [sp, #-4]!
3162		BL f_symbolAt
3163		ADD sp, sp, #12
3164		MOV r4, r0
3165		STRB r4, [sp, #3]
3166		LDR r4, =1
3167		STR r4, [sp, #-4]!
3168		LDR r4, =3
3169		STR r4, [sp, #-4]!
3170		LDR r4, [sp, #21]
3171		STR r4, [sp, #-4]!
3172		BL f_symbolAt
3173		ADD sp, sp, #12
3174		MOV r4, r0
3175		STRB r4, [sp, #2]
3176		LDR r4, =2
3177		STR r4, [sp, #-4]!
3178		LDR r4, =3
3179		STR r4, [sp, #-4]!
3180		LDR r4, [sp, #21]
3181		STR r4, [sp, #-4]!
3182		BL f_symbolAt
3183		ADD sp, sp, #12
3184		MOV r4, r0
3185		STRB r4, [sp, #1]
3186		LDR r4, =3
3187		STR r4, [sp, #-4]!
3188		LDR r4, =3
3189		STR r4, [sp, #-4]!
3190		LDR r4, [sp, #21]
3191		STR r4, [sp, #-4]!
3192		BL f_symbolAt
3193		ADD sp, sp, #12
3194		MOV r4, r0
3195		STRB r4, [sp]
3196		LDRSB r4, [sp, #8]
3197		LDRSB r5, [sp, #17]
3198		CMP r4, r5
3199		MOVEQ r4, #1
3200		MOVNE r4, #0
3201		LDRSB r5, [sp, #7]
3202		LDRSB r6, [sp, #17]
3203		CMP r5, r6
3204		MOVEQ r5, #1
3205		MOVNE r5, #0
3206		AND r4, r4, r5
3207		LDRSB r5, [sp, #6]
3208		LDRSB r6, [sp, #17]
3209		CMP r5, r6
3210		MOVEQ r5, #1
3211		MOVNE r5, #0
3212		AND r4, r4, r5
3213		LDRSB r5, [sp, #5]
3214		LDRSB r6, [sp, #17]
3215		CMP r5, r6
3216		MOVEQ r5, #1
3217		MOVNE r5, #0
3218		LDRSB r6, [sp, #4]
3219		LDRSB r7, [sp, #17]
3220		CMP r6, r7
3221		MOVEQ r6, #1
3222		MOVNE r6, #0
3223		AND r5, r5, r6
3224		LDRSB r6, [sp, #3]
3225		LDRSB r7, [sp, #17]
3226		CMP r6, r7
3227		MOVEQ r6, #1
3228		MOVNE r6, #0
3229		AND r5, r5, r6
3230		ORR r4, r4, r5
3231		LDRSB r5, [sp, #2]
3232		LDRSB r6, [sp, #17]
3233		CMP r5, r6
3234		MOVEQ r5, #1
3235		MOVNE r5, #0
3236		LDRSB r6, [sp, #1]
3237		LDRSB r7, [sp, #17]
3238		CMP r6, r7
3239		MOVEQ r6, #1
3240		MOVNE r6, #0
3241		AND r5, r5, r6
3242		LDRSB r6, [sp]
3243		LDRSB r7, [sp, #17]
3244		CMP r6, r7
3245		MOVEQ r6, #1
3246		MOVNE r6, #0
3247		AND r5, r5, r6
3248		ORR r4, r4, r5
3249		LDRSB r5, [sp, #8]
3250		LDRSB r6, [sp, #17]
3251		CMP r5, r6
3252		MOVEQ r5, #1
3253		MOVNE r5, #0
3254		LDRSB r6, [sp, #5]
3255		LDRSB r7, [sp, #17]
3256		CMP r6, r7
3257		MOVEQ r6, #1
3258		MOVNE r6, #0
3259		AND r5, r5, r6
3260		LDRSB r6, [sp, #2]
3261		LDRSB r7, [sp, #17]
3262		CMP r6, r7
3263		MOVEQ r6, #1
3264		MOVNE r6, #0
3265		AND r5, r5, r6
3266		ORR r4, r4, r5
3267		LDRSB r5, [sp, #7]
3268		LDRSB r6, [sp, #17]
3269		CMP r5, r6
3270		MOVEQ r5, #1
3271		MOVNE r5, #0
3272		LDRSB r6, [sp, #4]
3273		LDRSB r7, [sp, #17]
3274		CMP r6, r7
3275		MOVEQ r6, #1
3276		MOVNE r6, #0
3277		AND r5, r5, r6
3278		LDRSB r6, [sp, #1]
3279		LDRSB r7, [sp, #17]
3280		CMP r6, r7
3281		MOVEQ r6, #1
3282		MOVNE r6, #0
3283		AND r5, r5, r6
3284		ORR r4, r4, r5
3285		LDRSB r5, [sp, #6]
3286		LDRSB r6, [sp, #17]
3287		CMP r5, r6
3288		MOVEQ r5, #1
3289		MOVNE r5, #0
3290		LDRSB r6, [sp, #3]
3291		LDRSB r7, [sp, #17]
3292		CMP r6, r7
3293		MOVEQ r6, #1
3294		MOVNE r6, #0
3295		AND r5, r5, r6
3296		LDRSB r6, [sp]
3297		LDRSB r7, [sp, #17]
3298		CMP r6, r7
3299		MOVEQ r6, #1
3300		MOVNE r6, #0
3301		AND r5, r5, r6
3302		ORR r4, r4, r5
3303		LDRSB r5, [sp, #8]
3304		LDRSB r6, [sp, #17]
3305		CMP r5, r6
3306		MOVEQ r5, #1
3307		MOVNE r5, #0
3308		LDRSB r6, [sp, #4]
3309		LDRSB r7, [sp, #17]
3310		CMP r6, r7
3311		MOVEQ r6, #1
3312		MOVNE r6, #0
3313		AND r5, r5, r6
3314		LDRSB r6, [sp]
3315		LDRSB r7, [sp, #17]
3316		CMP r6, r7
3317		MOVEQ r6, #1
3318		MOVNE r6, #0
3319		AND r5, r5, r6
3320		ORR r4, r4, r5
3321		LDRSB r5, [sp, #6]
3322		LDRSB r6, [sp, #17]
3323		CMP r5, r6
3324		MOVEQ r5, #1
3325		MOVNE r5, #0
3326		LDRSB r6, [sp, #4]
3327		LDRSB r7, [sp, #17]
3328		CMP r6, r7
3329		MOVEQ r6, #1
3330		MOVNE r6, #0
3331		AND r5, r5, r6
3332		LDRSB r6, [sp, #2]
3333		LDRSB r7, [sp, #17]
3334		CMP r6, r7
3335		MOVEQ r6, #1
3336		MOVNE r6, #0
3337		AND r5, r5, r6
3338		ORR r4, r4, r5
3339		MOV r0, r4
3340		ADD sp, sp, #9
3341		POP {pc}
3342		POP {pc}
3343		.ltorg
3344	f_allocateNewBoard:
3345		PUSH {lr}
3346		SUB sp, sp, #20
3347		BL f_allocateNewRow
3348		MOV r4, r0
3349		STR r4, [sp, #16]
3350		BL f_allocateNewRow
3351		MOV r4, r0
3352		STR r4, [sp, #12]
3353		BL f_allocateNewRow
3354		MOV r4, r0
3355		STR r4, [sp, #8]
3356		LDR r0, =8
3357		BL malloc
3358		MOV r4, r0
3359		LDR r5, [sp, #16]
3360		LDR r0, =4
3361		BL malloc
3362		STR r5, [r0]
3363		STR r0, [r4]
3364		LDR r5, [sp, #12]
3365		LDR r0, =4
3366		BL malloc
3367		STR r5, [r0]
3368		STR r0, [r4, #4]
3369		STR r4, [sp, #4]
3370		LDR r0, =8
3371		BL malloc
3372		MOV r4, r0
3373		LDR r5, [sp, #4]
3374		LDR r0, =4
3375		BL malloc
3376		STR r5, [r0]
3377		STR r0, [r4]
3378		LDR r5, [sp, #8]
3379		LDR r0, =4
3380		BL malloc
3381		STR r5, [r0]
3382		STR r0, [r4, #4]
3383		STR r4, [sp]
3384		LDR r4, [sp]
3385		MOV r0, r4
3386		ADD sp, sp, #20
3387		POP {pc}
3388		POP {pc}
3389		.ltorg
3390	f_allocateNewRow:
3391		PUSH {lr}
3392		SUB sp, sp, #8
3393		LDR r0, =8
3394		BL malloc
3395		MOV r4, r0
3396		MOV r5, #0
3397		LDR r0, =1
3398		BL malloc
3399		STRB r5, [r0]
3400		STR r0, [r4]
3401		MOV r5, #0
3402		LDR r0, =1
3403		BL malloc
3404		STRB r5, [r0]
3405		STR r0, [r4, #4]
3406		STR r4, [sp, #4]
3407		LDR r0, =8
3408		BL malloc
3409		MOV r4, r0
3410		LDR r5, [sp, #4]
3411		LDR r0, =4
3412		BL malloc
3413		STR r5, [r0]
3414		STR r0, [r4]
3415		MOV r5, #0
3416		LDR r0, =1
3417		BL malloc
3418		STRB r5, [r0]
3419		STR r0, [r4, #4]
3420		STR r4, [sp]
3421		LDR r4, [sp]
3422		MOV r0, r4
3423		ADD sp, sp, #8
3424		POP {pc}
3425		POP {pc}
3426		.ltorg
3427	f_freeBoard:
3428		PUSH {lr}
3429		SUB sp, sp, #17
3430		LDR r4, [sp, #21]
3431		MOV r0, r4
3432		BL p_check_null_pointer
3433		LDR r4, [r4]
3434		LDR r4, [r4]
3435		STR r4, [sp, #13]
3436		LDR r4, [sp, #13]
3437		MOV r0, r4
3438		BL p_check_null_pointer
3439		LDR r4, [r4]
3440		LDR r4, [r4]
3441		STR r4, [sp, #9]
3442		LDR r4, [sp, #13]
3443		MOV r0, r4
3444		BL p_check_null_pointer
3445		LDR r4, [r4, #4]
3446		LDR r4, [r4]
3447		STR r4, [sp, #5]
3448		LDR r4, [sp, #21]
3449		MOV r0, r4
3450		BL p_check_null_pointer
3451		LDR r4, [r4, #4]
3452		LDR r4, [r4]
3453		STR r4, [sp, #1]
3454		LDR r4, [sp, #9]
3455		STR r4, [sp, #-4]!
3456		BL f_freeRow
3457		ADD sp, sp, #4
3458		MOV r4, r0
3459		STRB r4, [sp]
3460		LDR r4, [sp, #5]
3461		STR r4, [sp, #-4]!
3462		BL f_freeRow
3463		ADD sp, sp, #4
3464		MOV r4, r0
3465		STRB r4, [sp]
3466		LDR r4, [sp, #1]
3467		STR r4, [sp, #-4]!
3468		BL f_freeRow
3469		ADD sp, sp, #4
3470		MOV r4, r0
3471		STRB r4, [sp]
3472		LDR r4, [sp, #13]
3473		MOV r0, r4
3474		BL p_free_pair
3475		LDR r4, [sp, #21]
3476		MOV r0, r4
3477		BL p_free_pair
3478		MOV r4, #1
3479		MOV r0, r4
3480		ADD sp, sp, #17
3481		POP {pc}
3482		POP {pc}
3483		.ltorg
3484	f_freeRow:
3485		PUSH {lr}
3486		SUB sp, sp, #4
3487		LDR r4, [sp, #8]
3488		MOV r0, r4
3489		BL p_check_null_pointer
3490		LDR r4, [r4]
3491		LDR r4, [r4]
3492		STR r4, [sp]
3493		LDR r4, [sp]
3494		MOV r0, r4
3495		BL p_free_pair
3496		LDR r4, [sp, #8]
3497		MOV r0, r4
3498		BL p_free_pair
3499		MOV r4, #1
3500		MOV r0, r4
3501		ADD sp, sp, #4
3502		POP {pc}
3503		POP {pc}
3504		.ltorg
3505	f_printAiData:
3506		PUSH {lr}
3507		SUB sp, sp, #9
3508		LDR r4, [sp, #13]
3509		MOV r0, r4
3510		BL p_check_null_pointer
3511		LDR r4, [r4]
3512		LDR r4, [r4]
3513		STR r4, [sp, #5]
3514		LDR r4, [sp, #13]
3515		MOV r0, r4
3516		BL p_check_null_pointer
3517		LDR r4, [r4, #4]
3518		LDR r4, [r4]
3519		STR r4, [sp, #1]
3520		LDR r4, [sp, #1]
3521		STR r4, [sp, #-4]!
3522		BL f_printStateTreeRecursively
3523		ADD sp, sp, #4
3524		MOV r4, r0
3525		STRB r4, [sp]
3526		LDR r4, =0
3527		MOV r0, r4
3528		BL exit
3529		POP {pc}
3530		.ltorg
3531	f_printStateTreeRecursively:
3532		PUSH {lr}
3533		LDR r4, [sp, #4]
3534		LDR r5, =0
3535		CMP r4, r5
3536		MOVEQ r4, #1
3537		MOVNE r4, #0
3538		CMP r4, #0
3539		BEQ L100
3540		MOV r4, #1
3541		MOV r0, r4
3542		POP {pc}
3543		B L101
3544	L100:
3545		SUB sp, sp, #17
3546		LDR r4, [sp, #21]
3547		MOV r0, r4
3548		BL p_check_null_pointer
3549		LDR r4, [r4]
3550		LDR r4, [r4]
3551		STR r4, [sp, #13]
3552		LDR r4, [sp, #13]
3553		MOV r0, r4
3554		BL p_check_null_pointer
3555		LDR r4, [r4]
3556		LDR r4, [r4]
3557		STR r4, [sp, #9]
3558		LDR r4, [sp, #13]
3559		MOV r0, r4
3560		BL p_check_null_pointer
3561		LDR r4, [r4, #4]
3562		LDR r4, [r4]
3563		STR r4, [sp, #5]
3564		LDR r4, [sp, #21]
3565		MOV r0, r4
3566		BL p_check_null_pointer
3567		LDR r4, [r4, #4]
3568		LDR r4, [r4]
3569		STR r4, [sp, #1]
3570		MOV r4, #'v'
3571		MOV r0, r4
3572		BL putchar
3573		MOV r4, #'='
3574		MOV r0, r4
3575		BL putchar
3576		LDR r4, [sp, #1]
3577		MOV r0, r4
3578		BL p_print_int
3579		BL p_print_ln
3580		LDR r4, [sp, #9]
3581		STR r4, [sp, #-4]!
3582		BL f_printBoard
3583		ADD sp, sp, #4
3584		MOV r4, r0
3585		STRB r4, [sp]
3586		LDR r4, [sp, #5]
3587		STR r4, [sp, #-4]!
3588		BL f_printChildrenStateTree
3589		ADD sp, sp, #4
3590		MOV r4, r0
3591		STRB r4, [sp]
3592		MOV r4, #'p'
3593		MOV r0, r4
3594		BL putchar
3595		BL p_print_ln
3596		MOV r4, #1
3597		MOV r0, r4
3598		ADD sp, sp, #17
3599		POP {pc}
3600		ADD sp, sp, #17
3601	L101:
3602		POP {pc}
3603		.ltorg
3604	f_printChildrenStateTree:
3605		PUSH {lr}
3606		SUB sp, sp, #17
3607		LDR r4, [sp, #21]
3608		MOV r0, r4
3609		BL p_check_null_pointer
3610		LDR r4, [r4]
3611		LDR r4, [r4]
3612		STR r4, [sp, #13]
3613		LDR r4, [sp, #13]
3614		MOV r0, r4
3615		BL p_check_null_pointer
3616		LDR r4, [r4]
3617		LDR r4, [r4]
3618		STR r4, [sp, #9]
3619		LDR r4, [sp, #13]
3620		MOV r0, r4
3621		BL p_check_null_pointer
3622		LDR r4, [r4, #4]
3623		LDR r4, [r4]
3624		STR r4, [sp, #5]
3625		LDR r4, [sp, #21]
3626		MOV r0, r4
3627		BL p_check_null_pointer
3628		LDR r4, [r4, #4]
3629		LDR r4, [r4]
3630		STR r4, [sp, #1]
3631		LDR r4, [sp, #9]
3632		STR r4, [sp, #-4]!
3633		BL f_printChildrenStateTreeRow
3634		ADD sp, sp, #4
3635		MOV r4, r0
3636		STRB r4, [sp]
3637		LDR r4, [sp, #5]
3638		STR r4, [sp, #-4]!
3639		BL f_printChildrenStateTreeRow
3640		ADD sp, sp, #4
3641		MOV r4, r0
3642		STRB r4, [sp]
3643		LDR r4, [sp, #1]
3644		STR r4, [sp, #-4]!
3645		BL f_printChildrenStateTreeRow
3646		ADD sp, sp, #4
3647		MOV r4, r0
3648		STRB r4, [sp]
3649		MOV r4, #1
3650		MOV r0, r4
3651		ADD sp, sp, #17
3652		POP {pc}
3653		POP {pc}
3654		.ltorg
3655	f_printChildrenStateTreeRow:
3656		PUSH {lr}
3657		SUB sp, sp, #17
3658		LDR r4, [sp, #21]
3659		MOV r0, r4
3660		BL p_check_null_pointer
3661		LDR r4, [r4]
3662		LDR r4, [r4]
3663		STR r4, [sp, #13]
3664		LDR r4, [sp, #13]
3665		MOV r0, r4
3666		BL p_check_null_pointer
3667		LDR r4, [r4]
3668		LDR r4, [r4]
3669		STR r4, [sp, #9]
3670		LDR r4, [sp, #13]
3671		MOV r0, r4
3672		BL p_check_null_pointer
3673		LDR r4, [r4, #4]
3674		LDR r4, [r4]
3675		STR r4, [sp, #5]
3676		LDR r4, [sp, #21]
3677		MOV r0, r4
3678		BL p_check_null_pointer
3679		LDR r4, [r4, #4]
3680		LDR r4, [r4]
3681		STR r4, [sp, #1]
3682		LDR r4, [sp, #9]
3683		STR r4, [sp, #-4]!
3684		BL f_printStateTreeRecursively
3685		ADD sp, sp, #4
3686		MOV r4, r0
3687		STRB r4, [sp]
3688		LDR r4, [sp, #5]
3689		STR r4, [sp, #-4]!
3690		BL f_printStateTreeRecursively
3691		ADD sp, sp, #4
3692		MOV r4, r0
3693		STRB r4, [sp]
3694		LDR r4, [sp, #1]
3695		STR r4, [sp, #-4]!
3696		BL f_printStateTreeRecursively
3697		ADD sp, sp, #4
3698		MOV r4, r0
3699		STRB r4, [sp]
3700		MOV r4, #1
3701		MOV r0, r4
3702		ADD sp, sp, #17
3703		POP {pc}
3704		POP {pc}
3705		.ltorg
3706	main:
3707		PUSH {lr}
3708		SUB sp, sp, #17
3709		BL f_chooseSymbol
3710		MOV r4, r0
3711		STRB r4, [sp, #16]
3712		LDRSB r4, [sp, #16]
3713		STRB r4, [sp, #-1]!
3714		BL f_oppositeSymbol
3715		ADD sp, sp, #1
3716		MOV r4, r0
3717		STRB r4, [sp, #15]
3718		MOV r4, #'x'
3719		STRB r4, [sp, #14]
3720		BL f_allocateNewBoard
3721		MOV r4, r0
3722		STR r4, [sp, #10]
3723		LDR r4, =msg_34
3724		MOV r0, r4
3725		BL p_print_string
3726		BL p_print_ln
3727		LDRSB r4, [sp, #15]
3728		STRB r4, [sp, #-1]!
3729		BL f_initAI
3730		ADD sp, sp, #1
3731		MOV r4, r0
3732		STR r4, [sp, #6]
3733		LDR r4, =0
3734		STR r4, [sp, #2]
3735		MOV r4, #0
3736		STRB r4, [sp, #1]
3737		LDR r4, [sp, #10]
3738		STR r4, [sp, #-4]!
3739		BL f_printBoard
3740		ADD sp, sp, #4
3741		MOV r4, r0
3742		STRB r4, [sp]
3743		B L102
3744	L103:
3745		SUB sp, sp, #5
3746		LDR r0, =12
3747		BL malloc
3748		MOV r4, r0
3749		LDR r5, =0
3750		STR r5, [r4, #4]
3751		LDR r5, =0
3752		STR r5, [r4, #8]
3753		LDR r5, =2
3754		STR r5, [r4]
3755		STR r4, [sp, #1]
3756		LDR r4, [sp, #1]
3757		STR r4, [sp, #-4]!
3758		LDR r4, [sp, #15]
3759		STR r4, [sp, #-4]!
3760		LDRSB r4, [sp, #29]
3761		STRB r4, [sp, #-1]!
3762		LDRSB r4, [sp, #28]
3763		STRB r4, [sp, #-1]!
3764		LDR r4, [sp, #25]
3765		STR r4, [sp, #-4]!
3766		BL f_askForAMove
3767		ADD sp, sp, #14
3768		MOV r4, r0
3769		STRB r4, [sp, #5]
3770		ADD r4, sp, #1
3771		LDR r5, =1
3772		LDR r4, [r4]
3773		MOV r0, r5
3774		MOV r1, r4
3775		BL p_check_array_bounds
3776		ADD r4, r4, #4
3777		ADD r4, r4, r5, LSL #2
3778		LDR r4, [r4]
3779		STR r4, [sp, #-4]!
3780		ADD r4, sp, #5
3781		LDR r5, =0
3782		LDR r4, [r4]
3783		MOV r0, r5
3784		MOV r1, r4
3785		BL p_check_array_bounds
3786		ADD r4, r4, #4
3787		ADD r4, r4, r5, LSL #2
3788		LDR r4, [r4]
3789		STR r4, [sp, #-4]!
3790		LDRSB r4, [sp, #27]
3791		STRB r4, [sp, #-1]!
3792		LDR r4, [sp, #24]
3793		STR r4, [sp, #-4]!
3794		BL f_placeMove
3795		ADD sp, sp, #13
3796		MOV r4, r0
3797		STRB r4, [sp, #5]
3798		ADD r4, sp, #1
3799		LDR r5, =1
3800		LDR r4, [r4]
3801		MOV r0, r5
3802		MOV r1, r4
3803		BL p_check_array_bounds
3804		ADD r4, r4, #4
3805		ADD r4, r4, r5, LSL #2
3806		LDR r4, [r4]
3807		STR r4, [sp, #-4]!
3808		ADD r4, sp, #5
3809		LDR r5, =0
3810		LDR r4, [r4]
3811		MOV r0, r5
3812		MOV r1, r4
3813		BL p_check_array_bounds
3814		ADD r4, r4, #4
3815		ADD r4, r4, r5, LSL #2
3816		LDR r4, [r4]
3817		STR r4, [sp, #-4]!
3818		LDR r4, [sp, #19]
3819		STR r4, [sp, #-4]!
3820		LDRSB r4, [sp, #33]
3821		STRB r4, [sp, #-1]!
3822		LDRSB r4, [sp, #32]
3823		STRB r4, [sp, #-1]!
3824		LDR r4, [sp, #29]
3825		STR r4, [sp, #-4]!
3826		BL f_notifyMove
3827		ADD sp, sp, #18
3828		MOV r4, r0
3829		STRB r4, [sp, #5]
3830		LDR r4, [sp, #15]
3831		STR r4, [sp, #-4]!
3832		BL f_printBoard
3833		ADD sp, sp, #4
3834		MOV r4, r0
3835		STRB r4, [sp, #5]
3836		LDRSB r4, [sp, #19]
3837		STRB r4, [sp, #-1]!
3838		LDR r4, [sp, #16]
3839		STR r4, [sp, #-4]!
3840		BL f_hasWon
3841		ADD sp, sp, #5
3842		MOV r4, r0
3843		STRB r4, [sp]
3844		LDRSB r4, [sp]
3845		CMP r4, #0
3846		BEQ L104
3847		LDRSB r4, [sp, #19]
3848		STRB r4, [sp, #6]
3849		B L105
3850	L104:
3851	L105:
3852		LDRSB r4, [sp, #19]
3853		STRB r4, [sp, #-1]!
3854		BL f_oppositeSymbol
3855		ADD sp, sp, #1
3856		MOV r4, r0
3857		STRB r4, [sp, #19]
3858		LDR r4, [sp, #7]
3859		LDR r5, =1
3860		ADDS r4, r4, r5
3861		BLVS p_throw_overflow_error
3862		STR r4, [sp, #7]
3863		ADD sp, sp, #5
3864	L102:
3865		LDRSB r4, [sp, #1]
3866		MOV r5, #0
3867		CMP r4, r5
3868		MOVEQ r4, #1
3869		MOVNE r4, #0
3870		LDR r5, [sp, #2]
3871		LDR r6, =9
3872		CMP r5, r6
3873		MOVLT r5, #1
3874		MOVGE r5, #0
3875		AND r4, r4, r5
3876		CMP r4, #1
3877		BEQ L103
3878		LDR r4, [sp, #10]
3879		STR r4, [sp, #-4]!
3880		BL f_freeBoard
3881		ADD sp, sp, #4
3882		MOV r4, r0
3883		STRB r4, [sp]
3884		LDR r4, [sp, #6]
3885		STR r4, [sp, #-4]!
3886		BL f_destroyAI
3887		ADD sp, sp, #4
3888		MOV r4, r0
3889		STRB r4, [sp]
3890		LDRSB r4, [sp, #1]
3891		MOV r5, #0
3892		CMP r4, r5
3893		MOVNE r4, #1
3894		MOVEQ r4, #0
3895		CMP r4, #0
3896		BEQ L106
3897		LDRSB r4, [sp, #1]
3898		MOV r0, r4
3899		BL putchar
3900		LDR r4, =msg_35
3901		MOV r0, r4
3902		BL p_print_string
3903		BL p_print_ln
3904		B L107
3905	L106:
3906		LDR r4, =msg_36
3907		MOV r0, r4
3908		BL p_print_string
3909		BL p_print_ln
3910	L107:
3911		ADD sp, sp, #17
3912		LDR r0, =0
3913		POP {pc}
3914		.ltorg
3915	p_print_string:
3916		PUSH {lr}
3917		LDR r1, [r0]
3918		ADD r2, r0, #4
3919		LDR r0, =msg_37
3920		ADD r0, r0, #4
3921		BL printf
3922		MOV r0, #0
3923		BL fflush
3924		POP {pc}
3925	p_print_ln:
3926		PUSH {lr}
3927		LDR r0, =msg_38
3928		ADD r0, r0, #4
3929		BL puts
3930		MOV r0, #0
3931		BL fflush
3932		POP {pc}
3933	p_read_char:
3934		PUSH {lr}
3935		MOV r1, r0
3936		LDR r0, =msg_39
3937		ADD r0, r0, #4
3938		BL scanf
3939		POP {pc}
3940	p_check_null_pointer:
3941		PUSH {lr}
3942		CMP r0, #0
3943		LDREQ r0, =msg_40
3944		BLEQ p_throw_runtime_error
3945		POP {pc}
3946	p_read_int:
3947		PUSH {lr}
3948		MOV r1, r0
3949		LDR r0, =msg_41
3950		ADD r0, r0, #4
3951		BL scanf
3952		POP {pc}
3953	p_check_array_bounds:
3954		PUSH {lr}
3955		CMP r0, #0
3956		LDRLT r0, =msg_42
3957		BLLT p_throw_runtime_error
3958		LDR r1, [r1]
3959		CMP r0, r1
3960		LDRCS r0, =msg_43
3961		BLCS p_throw_runtime_error
3962		POP {pc}
3963	p_print_int:
3964		PUSH {lr}
3965		MOV r1, r0
3966		LDR r0, =msg_44
3967		ADD r0, r0, #4
3968		BL printf
3969		MOV r0, #0
3970		BL fflush
3971		POP {pc}
3972	p_free_pair:
3973		PUSH {lr}
3974		CMP r0, #0
3975		LDREQ r0, =msg_45
3976		BEQ p_throw_runtime_error
3977		PUSH {r0}
3978		LDR r0, [r0]
3979		BL free
3980		LDR r0, [sp]
3981		LDR r0, [r0, #4]
3982		BL free
3983		POP {r0}
3984		BL free
3985		POP {pc}
3986	p_throw_overflow_error:
3987		LDR r0, =msg_46
3988		BL p_throw_runtime_error
3989	p_throw_runtime_error:
3990		BL p_print_string
3991		MOV r0, #-1
3992		BL exit
3993	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/array.wacc
-- Test: array.wacc

-- Uploaded file: 
---------------------------------------------------------------
# moderate complexity array manipulations

# Output:
# #addrs# = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

# Program:

begin
  int[] a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ;
  int i = 0 ;
  while i < 10 
  do
    a[i] = i ;
    i = i + 1
  done ;
  print a ;
  print " = {" ;
  i = 0 ;
  while i < 10 
  do 
    print a[i] ;
    if i < 9
    then
      print ", "
    else
      skip
    fi ;
    i = i + 1
  done ;
  println "}"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
array.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 4
4		.ascii	" = {"
5	msg_1:
6		.word 2
7		.ascii	", "
8	msg_2:
9		.word 1
10		.ascii	"}"
11	msg_3:
12		.word 44
13		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
14	msg_4:
15		.word 45
16		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
17	msg_5:
18		.word 82
19		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
20	msg_6:
21		.word 3
22		.ascii	"%p\0"
23	msg_7:
24		.word 5
25		.ascii	"%.*s\0"
26	msg_8:
27		.word 3
28		.ascii	"%d\0"
29	msg_9:
30		.word 1
31		.ascii	"\0"
32	
33	.text
34	
35	.global main
36	main:
37		PUSH {lr}
38		SUB sp, sp, #8
39		LDR r0, =44
40		BL malloc
41		MOV r4, r0
42		LDR r5, =0
43		STR r5, [r4, #4]
44		LDR r5, =0
45		STR r5, [r4, #8]
46		LDR r5, =0
47		STR r5, [r4, #12]
48		LDR r5, =0
49		STR r5, [r4, #16]
50		LDR r5, =0
51		STR r5, [r4, #20]
52		LDR r5, =0
53		STR r5, [r4, #24]
54		LDR r5, =0
55		STR r5, [r4, #28]
56		LDR r5, =0
57		STR r5, [r4, #32]
58		LDR r5, =0
59		STR r5, [r4, #36]
60		LDR r5, =0
61		STR r5, [r4, #40]
62		LDR r5, =10
63		STR r5, [r4]
64		STR r4, [sp, #4]
65		LDR r4, =0
66		STR r4, [sp]
67		B L0
68	L1:
69		LDR r4, [sp]
70		ADD r5, sp, #4
71		LDR r6, [sp]
72		LDR r5, [r5]
73		MOV r0, r6
74		MOV r1, r5
75		BL p_check_array_bounds
76		ADD r5, r5, #4
77		ADD r5, r5, r6, LSL #2
78		STR r4, [r5]
79		LDR r4, [sp]
80		LDR r6, =1
81		ADDS r4, r4, r6
82		BLVS p_throw_overflow_error
83		STR r4, [sp]
84	L0:
85		LDR r4, [sp]
86		LDR r6, =10
87		CMP r4, r6
88		MOVLT r4, #1
89		MOVGE r4, #0
90		CMP r4, #1
91		BEQ L1
92		LDR r4, [sp, #4]
93		MOV r0, r4
94		BL p_print_reference
95		LDR r4, =msg_0
96		MOV r0, r4
97		BL p_print_string
98		LDR r4, =0
99		STR r4, [sp]
100		B L2
101	L3:
102		ADD r4, sp, #4
103		LDR r6, [sp]
104		LDR r4, [r4]
105		MOV r0, r6
106		MOV r1, r4
107		BL p_check_array_bounds
108		ADD r4, r4, #4
109		ADD r4, r4, r6, LSL #2
110		LDR r4, [r4]
111		MOV r0, r4
112		BL p_print_int
113		LDR r4, [sp]
114		LDR r6, =9
115		CMP r4, r6
116		MOVLT r4, #1
117		MOVGE r4, #0
118		CMP r4, #0
119		BEQ L4
120		LDR r4, =msg_1
121		MOV r0, r4
122		BL p_print_string
123		B L5
124	L4:
125	L5:
126		LDR r4, [sp]
127		LDR r6, =1
128		ADDS r4, r4, r6
129		BLVS p_throw_overflow_error
130		STR r4, [sp]
131	L2:
132		LDR r4, [sp]
133		LDR r6, =10
134		CMP r4, r6
135		MOVLT r4, #1
136		MOVGE r4, #0
137		CMP r4, #1
138		BEQ L3
139		LDR r4, =msg_2
140		MOV r0, r4
141		BL p_print_string
142		BL p_print_ln
143		ADD sp, sp, #8
144		LDR r0, =0
145		POP {pc}
146		.ltorg
147	p_check_array_bounds:
148		PUSH {lr}
149		CMP r0, #0
150		LDRLT r0, =msg_3
151		BLLT p_throw_runtime_error
152		LDR r1, [r1]
153		CMP r0, r1
154		LDRCS r0, =msg_4
155		BLCS p_throw_runtime_error
156		POP {pc}
157	p_throw_overflow_error:
158		LDR r0, =msg_5
159		BL p_throw_runtime_error
160	p_print_reference:
161		PUSH {lr}
162		MOV r1, r0
163		LDR r0, =msg_6
164		ADD r0, r0, #4
165		BL printf
166		MOV r0, #0
167		BL fflush
168		POP {pc}
169	p_print_string:
170		PUSH {lr}
171		LDR r1, [r0]
172		ADD r2, r0, #4
173		LDR r0, =msg_7
174		ADD r0, r0, #4
175		BL printf
176		MOV r0, #0
177		BL fflush
178		POP {pc}
179	p_print_int:
180		PUSH {lr}
181		MOV r1, r0
182		LDR r0, =msg_8
183		ADD r0, r0, #4
184		BL printf
185		MOV r0, #0
186		BL fflush
187		POP {pc}
188	p_print_ln:
189		PUSH {lr}
190		LDR r0, =msg_9
191		ADD r0, r0, #4
192		BL puts
193		MOV r0, #0
194		BL fflush
195		POP {pc}
196	p_throw_runtime_error:
197		BL p_print_string
198		MOV r0, #-1
199		BL exit
200	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arrayBasic.wacc
-- Test: arrayBasic.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic array declaration and assignment

# Output:
# #empty#

# Program:

begin
  int[] a = [0]
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayBasic.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r0, =8
7		BL malloc
8		MOV r4, r0
9		LDR r5, =0
10		STR r5, [r4, #4]
11		LDR r5, =1
12		STR r5, [r4]
13		STR r4, [sp]
14		ADD sp, sp, #4
15		LDR r0, =0
16		POP {pc}
17		.ltorg
18	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arrayEmpty.wacc
-- Test: arrayEmpty.wacc

-- Uploaded file: 
---------------------------------------------------------------
# empty array declaration (seems to error currently)

# Output:
# #empty#

# Program:

begin
  int[] a = []
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayEmpty.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r0, =4
7		BL malloc
8		MOV r4, r0
9		LDR r5, =0
10		STR r5, [r4]
11		STR r4, [sp]
12		ADD sp, sp, #4
13		LDR r0, =0
14		POP {pc}
15		.ltorg
16	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arrayLength.wacc
-- Test: arrayLength.wacc

-- Uploaded file: 
---------------------------------------------------------------
# check length of array

# Output:
# 4

# Program:

begin
  int[] a = [43, 2, 18, 1] ;
  println len a
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayLength.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r0, =20
16		BL malloc
17		MOV r4, r0
18		LDR r5, =43
19		STR r5, [r4, #4]
20		LDR r5, =2
21		STR r5, [r4, #8]
22		LDR r5, =18
23		STR r5, [r4, #12]
24		LDR r5, =1
25		STR r5, [r4, #16]
26		LDR r5, =4
27		STR r5, [r4]
28		STR r4, [sp]
29		LDR r4, [sp]
30		LDR r4, [r4]
31		MOV r0, r4
32		BL p_print_int
33		BL p_print_ln
34		ADD sp, sp, #4
35		LDR r0, =0
36		POP {pc}
37		.ltorg
38	p_print_int:
39		PUSH {lr}
40		MOV r1, r0
41		LDR r0, =msg_0
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	p_print_ln:
48		PUSH {lr}
49		LDR r0, =msg_1
50		ADD r0, r0, #4
51		BL puts
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arrayLookup.wacc
-- Test: arrayLookup.wacc

-- Uploaded file: 
---------------------------------------------------------------
# check first element of array

# Output:
# 43

# Program:

begin
  int[] a = [43, 2, 18, 1] ;
  println a[0]
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayLookup.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 44
4		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
5	msg_1:
6		.word 45
7		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r0, =20
25		BL malloc
26		MOV r4, r0
27		LDR r5, =43
28		STR r5, [r4, #4]
29		LDR r5, =2
30		STR r5, [r4, #8]
31		LDR r5, =18
32		STR r5, [r4, #12]
33		LDR r5, =1
34		STR r5, [r4, #16]
35		LDR r5, =4
36		STR r5, [r4]
37		STR r4, [sp]
38		ADD r4, sp, #0
39		LDR r5, =0
40		LDR r4, [r4]
41		MOV r0, r5
42		MOV r1, r4
43		BL p_check_array_bounds
44		ADD r4, r4, #4
45		ADD r4, r4, r5, LSL #2
46		LDR r4, [r4]
47		MOV r0, r4
48		BL p_print_int
49		BL p_print_ln
50		ADD sp, sp, #4
51		LDR r0, =0
52		POP {pc}
53		.ltorg
54	p_check_array_bounds:
55		PUSH {lr}
56		CMP r0, #0
57		LDRLT r0, =msg_0
58		BLLT p_throw_runtime_error
59		LDR r1, [r1]
60		CMP r0, r1
61		LDRCS r0, =msg_1
62		BLCS p_throw_runtime_error
63		POP {pc}
64	p_print_int:
65		PUSH {lr}
66		MOV r1, r0
67		LDR r0, =msg_2
68		ADD r0, r0, #4
69		BL printf
70		MOV r0, #0
71		BL fflush
72		POP {pc}
73	p_print_ln:
74		PUSH {lr}
75		LDR r0, =msg_3
76		ADD r0, r0, #4
77		BL puts
78		MOV r0, #0
79		BL fflush
80		POP {pc}
81	p_throw_runtime_error:
82		BL p_print_string
83		MOV r0, #-1
84		BL exit
85	p_print_string:
86		PUSH {lr}
87		LDR r1, [r0]
88		ADD r2, r0, #4
89		LDR r0, =msg_4
90		ADD r0, r0, #4
91		BL printf
92		MOV r0, #0
93		BL fflush
94		POP {pc}
95	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arrayNested.wacc
-- Test: arrayNested.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic array declaration and assignment

# Output:
# 3
# 3

# Program:

begin
  int[] a = [1,2,3];
  int[] b = [3,4];
  int[][] c = [a,b] ;
  println c[0][2] ;
  println c[1][0]
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayNested.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 44
4		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
5	msg_1:
6		.word 45
7		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #12
24		LDR r0, =16
25		BL malloc
26		MOV r4, r0
27		LDR r5, =1
28		STR r5, [r4, #4]
29		LDR r5, =2
30		STR r5, [r4, #8]
31		LDR r5, =3
32		STR r5, [r4, #12]
33		LDR r5, =3
34		STR r5, [r4]
35		STR r4, [sp, #8]
36		LDR r0, =12
37		BL malloc
38		MOV r4, r0
39		LDR r5, =3
40		STR r5, [r4, #4]
41		LDR r5, =4
42		STR r5, [r4, #8]
43		LDR r5, =2
44		STR r5, [r4]
45		STR r4, [sp, #4]
46		LDR r0, =12
47		BL malloc
48		MOV r4, r0
49		LDR r5, [sp, #8]
50		STR r5, [r4, #4]
51		LDR r5, [sp, #4]
52		STR r5, [r4, #8]
53		LDR r5, =2
54		STR r5, [r4]
55		STR r4, [sp]
56		ADD r4, sp, #0
57		LDR r5, =0
58		LDR r4, [r4]
59		MOV r0, r5
60		MOV r1, r4
61		BL p_check_array_bounds
62		ADD r4, r4, #4
63		ADD r4, r4, r5, LSL #2
64		LDR r5, =2
65		LDR r4, [r4]
66		MOV r0, r5
67		MOV r1, r4
68		BL p_check_array_bounds
69		ADD r4, r4, #4
70		ADD r4, r4, r5, LSL #2
71		LDR r4, [r4]
72		MOV r0, r4
73		BL p_print_int
74		BL p_print_ln
75		ADD r4, sp, #0
76		LDR r5, =1
77		LDR r4, [r4]
78		MOV r0, r5
79		MOV r1, r4
80		BL p_check_array_bounds
81		ADD r4, r4, #4
82		ADD r4, r4, r5, LSL #2
83		LDR r5, =0
84		LDR r4, [r4]
85		MOV r0, r5
86		MOV r1, r4
87		BL p_check_array_bounds
88		ADD r4, r4, #4
89		ADD r4, r4, r5, LSL #2
90		LDR r4, [r4]
91		MOV r0, r4
92		BL p_print_int
93		BL p_print_ln
94		ADD sp, sp, #12
95		LDR r0, =0
96		POP {pc}
97		.ltorg
98	p_check_array_bounds:
99		PUSH {lr}
100		CMP r0, #0
101		LDRLT r0, =msg_0
102		BLLT p_throw_runtime_error
103		LDR r1, [r1]
104		CMP r0, r1
105		LDRCS r0, =msg_1
106		BLCS p_throw_runtime_error
107		POP {pc}
108	p_print_int:
109		PUSH {lr}
110		MOV r1, r0
111		LDR r0, =msg_2
112		ADD r0, r0, #4
113		BL printf
114		MOV r0, #0
115		BL fflush
116		POP {pc}
117	p_print_ln:
118		PUSH {lr}
119		LDR r0, =msg_3
120		ADD r0, r0, #4
121		BL puts
122		MOV r0, #0
123		BL fflush
124		POP {pc}
125	p_throw_runtime_error:
126		BL p_print_string
127		MOV r0, #-1
128		BL exit
129	p_print_string:
130		PUSH {lr}
131		LDR r1, [r0]
132		ADD r2, r0, #4
133		LDR r0, =msg_4
134		ADD r0, r0, #4
135		BL printf
136		MOV r0, #0
137		BL fflush
138		POP {pc}
139	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arrayPrint.wacc
-- Test: arrayPrint.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print the contents of a simple array

# Output:
# #addrs# = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

# Program:

begin
  int[] a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ;
  int i = 0 ;
  print a ;
  print " = {" ;
  i = 0 ;
  while i < 10 
  do 
    print a[i] ;
    if i < 9
    then
      print ", "
    else
      skip
    fi ;
    i = i + 1
  done ;
  println "}"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayPrint.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 4
4		.ascii	" = {"
5	msg_1:
6		.word 2
7		.ascii	", "
8	msg_2:
9		.word 1
10		.ascii	"}"
11	msg_3:
12		.word 3
13		.ascii	"%p\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 44
19		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
20	msg_6:
21		.word 45
22		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
23	msg_7:
24		.word 3
25		.ascii	"%d\0"
26	msg_8:
27		.word 82
28		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
29	msg_9:
30		.word 1
31		.ascii	"\0"
32	
33	.text
34	
35	.global main
36	main:
37		PUSH {lr}
38		SUB sp, sp, #8
39		LDR r0, =44
40		BL malloc
41		MOV r4, r0
42		LDR r5, =0
43		STR r5, [r4, #4]
44		LDR r5, =1
45		STR r5, [r4, #8]
46		LDR r5, =2
47		STR r5, [r4, #12]
48		LDR r5, =3
49		STR r5, [r4, #16]
50		LDR r5, =4
51		STR r5, [r4, #20]
52		LDR r5, =5
53		STR r5, [r4, #24]
54		LDR r5, =6
55		STR r5, [r4, #28]
56		LDR r5, =7
57		STR r5, [r4, #32]
58		LDR r5, =8
59		STR r5, [r4, #36]
60		LDR r5, =9
61		STR r5, [r4, #40]
62		LDR r5, =10
63		STR r5, [r4]
64		STR r4, [sp, #4]
65		LDR r4, =0
66		STR r4, [sp]
67		LDR r4, [sp, #4]
68		MOV r0, r4
69		BL p_print_reference
70		LDR r4, =msg_0
71		MOV r0, r4
72		BL p_print_string
73		LDR r4, =0
74		STR r4, [sp]
75		B L0
76	L1:
77		ADD r4, sp, #4
78		LDR r5, [sp]
79		LDR r4, [r4]
80		MOV r0, r5
81		MOV r1, r4
82		BL p_check_array_bounds
83		ADD r4, r4, #4
84		ADD r4, r4, r5, LSL #2
85		LDR r4, [r4]
86		MOV r0, r4
87		BL p_print_int
88		LDR r4, [sp]
89		LDR r5, =9
90		CMP r4, r5
91		MOVLT r4, #1
92		MOVGE r4, #0
93		CMP r4, #0
94		BEQ L2
95		LDR r4, =msg_1
96		MOV r0, r4
97		BL p_print_string
98		B L3
99	L2:
100	L3:
101		LDR r4, [sp]
102		LDR r5, =1
103		ADDS r4, r4, r5
104		BLVS p_throw_overflow_error
105		STR r4, [sp]
106	L0:
107		LDR r4, [sp]
108		LDR r5, =10
109		CMP r4, r5
110		MOVLT r4, #1
111		MOVGE r4, #0
112		CMP r4, #1
113		BEQ L1
114		LDR r4, =msg_2
115		MOV r0, r4
116		BL p_print_string
117		BL p_print_ln
118		ADD sp, sp, #8
119		LDR r0, =0
120		POP {pc}
121		.ltorg
122	p_print_reference:
123		PUSH {lr}
124		MOV r1, r0
125		LDR r0, =msg_3
126		ADD r0, r0, #4
127		BL printf
128		MOV r0, #0
129		BL fflush
130		POP {pc}
131	p_print_string:
132		PUSH {lr}
133		LDR r1, [r0]
134		ADD r2, r0, #4
135		LDR r0, =msg_4
136		ADD r0, r0, #4
137		BL printf
138		MOV r0, #0
139		BL fflush
140		POP {pc}
141	p_check_array_bounds:
142		PUSH {lr}
143		CMP r0, #0
144		LDRLT r0, =msg_5
145		BLLT p_throw_runtime_error
146		LDR r1, [r1]
147		CMP r0, r1
148		LDRCS r0, =msg_6
149		BLCS p_throw_runtime_error
150		POP {pc}
151	p_print_int:
152		PUSH {lr}
153		MOV r1, r0
154		LDR r0, =msg_7
155		ADD r0, r0, #4
156		BL printf
157		MOV r0, #0
158		BL fflush
159		POP {pc}
160	p_throw_overflow_error:
161		LDR r0, =msg_8
162		BL p_throw_runtime_error
163	p_print_ln:
164		PUSH {lr}
165		LDR r0, =msg_9
166		ADD r0, r0, #4
167		BL puts
168		MOV r0, #0
169		BL fflush
170		POP {pc}
171	p_throw_runtime_error:
172		BL p_print_string
173		MOV r0, #-1
174		BL exit
175	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/arraySimple.wacc
-- Test: arraySimple.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple array assignment and lookup

# Output:
# 42

# Program:

begin
  int[] a = [0] ;
  a[0] = 42 ;
  println a[0]
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arraySimple.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 44
4		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
5	msg_1:
6		.word 45
7		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r0, =8
25		BL malloc
26		MOV r4, r0
27		LDR r5, =0
28		STR r5, [r4, #4]
29		LDR r5, =1
30		STR r5, [r4]
31		STR r4, [sp]
32		LDR r4, =42
33		ADD r5, sp, #0
34		LDR r6, =0
35		LDR r5, [r5]
36		MOV r0, r6
37		MOV r1, r5
38		BL p_check_array_bounds
39		ADD r5, r5, #4
40		ADD r5, r5, r6, LSL #2
41		STR r4, [r5]
42		ADD r4, sp, #0
43		LDR r6, =0
44		LDR r4, [r4]
45		MOV r0, r6
46		MOV r1, r4
47		BL p_check_array_bounds
48		ADD r4, r4, #4
49		ADD r4, r4, r6, LSL #2
50		LDR r4, [r4]
51		MOV r0, r4
52		BL p_print_int
53		BL p_print_ln
54		ADD sp, sp, #4
55		LDR r0, =0
56		POP {pc}
57		.ltorg
58	p_check_array_bounds:
59		PUSH {lr}
60		CMP r0, #0
61		LDRLT r0, =msg_0
62		BLLT p_throw_runtime_error
63		LDR r1, [r1]
64		CMP r0, r1
65		LDRCS r0, =msg_1
66		BLCS p_throw_runtime_error
67		POP {pc}
68	p_print_int:
69		PUSH {lr}
70		MOV r1, r0
71		LDR r0, =msg_2
72		ADD r0, r0, #4
73		BL printf
74		MOV r0, #0
75		BL fflush
76		POP {pc}
77	p_print_ln:
78		PUSH {lr}
79		LDR r0, =msg_3
80		ADD r0, r0, #4
81		BL puts
82		MOV r0, #0
83		BL fflush
84		POP {pc}
85	p_throw_runtime_error:
86		BL p_print_string
87		MOV r0, #-1
88		BL exit
89	p_print_string:
90		PUSH {lr}
91		LDR r1, [r0]
92		ADD r2, r0, #4
93		LDR r0, =msg_4
94		ADD r0, r0, #4
95		BL printf
96		MOV r0, #0
97		BL fflush
98		POP {pc}
99	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/modifyString.wacc
-- Test: modifyString.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create and modify string as array of characters

# Output:
# hello world!
# Hello world!
# Hi!

# Program:

begin
  char[] str = ['h','e','l','l','o',' ','w','o','r','l','d','!'] ;
  println str ;
  str[0] = 'H' ;
  println str ;
  str = ['H','i','!'] ;
  println str
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
modifyString.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"%.*s\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 44
10		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
11	msg_3:
12		.word 45
13		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r0, =16
22		BL malloc
23		MOV r4, r0
24		MOV r5, #'h'
25		STRB r5, [r4, #4]
26		MOV r5, #'e'
27		STRB r5, [r4, #5]
28		MOV r5, #'l'
29		STRB r5, [r4, #6]
30		MOV r5, #'l'
31		STRB r5, [r4, #7]
32		MOV r5, #'o'
33		STRB r5, [r4, #8]
34		MOV r5, #' '
35		STRB r5, [r4, #9]
36		MOV r5, #'w'
37		STRB r5, [r4, #10]
38		MOV r5, #'o'
39		STRB r5, [r4, #11]
40		MOV r5, #'r'
41		STRB r5, [r4, #12]
42		MOV r5, #'l'
43		STRB r5, [r4, #13]
44		MOV r5, #'d'
45		STRB r5, [r4, #14]
46		MOV r5, #'!'
47		STRB r5, [r4, #15]
48		LDR r5, =12
49		STR r5, [r4]
50		STR r4, [sp]
51		LDR r4, [sp]
52		MOV r0, r4
53		BL p_print_string
54		BL p_print_ln
55		MOV r4, #'H'
56		ADD r5, sp, #0
57		LDR r6, =0
58		LDR r5, [r5]
59		MOV r0, r6
60		MOV r1, r5
61		BL p_check_array_bounds
62		ADD r5, r5, #4
63		ADD r5, r5, r6
64		STRB r4, [r5]
65		LDR r4, [sp]
66		MOV r0, r4
67		BL p_print_string
68		BL p_print_ln
69		LDR r0, =7
70		BL malloc
71		MOV r4, r0
72		MOV r6, #'H'
73		STRB r6, [r4, #4]
74		MOV r6, #'i'
75		STRB r6, [r4, #5]
76		MOV r6, #'!'
77		STRB r6, [r4, #6]
78		LDR r6, =3
79		STR r6, [r4]
80		STR r4, [sp]
81		LDR r4, [sp]
82		MOV r0, r4
83		BL p_print_string
84		BL p_print_ln
85		ADD sp, sp, #4
86		LDR r0, =0
87		POP {pc}
88		.ltorg
89	p_print_string:
90		PUSH {lr}
91		LDR r1, [r0]
92		ADD r2, r0, #4
93		LDR r0, =msg_0
94		ADD r0, r0, #4
95		BL printf
96		MOV r0, #0
97		BL fflush
98		POP {pc}
99	p_print_ln:
100		PUSH {lr}
101		LDR r0, =msg_1
102		ADD r0, r0, #4
103		BL puts
104		MOV r0, #0
105		BL fflush
106		POP {pc}
107	p_check_array_bounds:
108		PUSH {lr}
109		CMP r0, #0
110		LDRLT r0, =msg_2
111		BLLT p_throw_runtime_error
112		LDR r1, [r1]
113		CMP r0, r1
114		LDRCS r0, =msg_3
115		BLCS p_throw_runtime_error
116		POP {pc}
117	p_throw_runtime_error:
118		BL p_print_string
119		MOV r0, #-1
120		BL exit
121	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/array/printRef.wacc
-- Test: printRef.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic array (reference) printing

# Output:
# Printing an array variable gives an address, such as #addrs#

# Program:

begin
  print "Printing an array variable gives an address, such as " ;
  int[] a = [1,2,3] ;
  println a
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printRef.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 53
4		.ascii	"Printing an array variable gives an address, such as "
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 3
10		.ascii	"%p\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =msg_0
22		MOV r0, r4
23		BL p_print_string
24		LDR r0, =16
25		BL malloc
26		MOV r4, r0
27		LDR r5, =1
28		STR r5, [r4, #4]
29		LDR r5, =2
30		STR r5, [r4, #8]
31		LDR r5, =3
32		STR r5, [r4, #12]
33		LDR r5, =3
34		STR r5, [r4]
35		STR r4, [sp]
36		LDR r4, [sp]
37		MOV r0, r4
38		BL p_print_reference
39		BL p_print_ln
40		ADD sp, sp, #4
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_string:
45		PUSH {lr}
46		LDR r1, [r0]
47		ADD r2, r0, #4
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_reference:
55		PUSH {lr}
56		MOV r1, r0
57		LDR r0, =msg_2
58		ADD r0, r0, #4
59		BL printf
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	p_print_ln:
64		PUSH {lr}
65		LDR r0, =msg_3
66		ADD r0, r0, #4
67		BL puts
68		MOV r0, #0
69		BL fflush
70		POP {pc}
71	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/exit/exit-1.wacc
-- Test: exit-1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# common error exit statement

# Output:
# #empty#

# Exit:
# 255

# Program:

begin
  exit -1
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
exit-1.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r4, =-1
6		MOV r0, r4
7		BL exit
8		LDR r0, =0
9		POP {pc}
10		.ltorg
11	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/exit/exitBasic.wacc
-- Test: exitBasic.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic exit statement

# Output:
# #empty#

# Exit:
# 7

# Program:

begin
  exit 7
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
exitBasic.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r4, =7
6		MOV r0, r4
7		BL exit
8		LDR r0, =0
9		POP {pc}
10		.ltorg
11	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/exit/exitBasic2.wacc
-- Test: exitBasic2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic exit statement

# Output:
# #empty#

# Exit:
# 42

# Program:

begin
  exit 42
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
exitBasic2.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r4, =42
6		MOV r0, r4
7		BL exit
8		LDR r0, =0
9		POP {pc}
10		.ltorg
11	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/exit/exitBigNum.wacc
-- Test: exitBigNum.wacc

-- Uploaded file: 
---------------------------------------------------------------
# exit with wrapped int 

# Output:
# #empty#

# Observations:
# exit 1024 --> exit: 0
# exit 1023 --> exit: 255
# exit 4096 --> exit: 0
# exit 4095 --> exit: 255
# exit 256 --> exit: 0
# exit 255 --> exit: 255

# Exit:
# 0

# Program:

begin
  exit 4096
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
exitBigNum.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r4, =4096
6		MOV r0, r4
7		BL exit
8		LDR r0, =0
9		POP {pc}
10		.ltorg
11	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/exit/exitWrap.wacc
-- Test: exitWrap.wacc

-- Uploaded file: 
---------------------------------------------------------------
# exit with wrapped int 

# Output:
# #empty#

# Exit:
# 0

# Program:

begin
  exit 256
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
exitWrap.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r4, =256
6		MOV r0, r4
7		BL exit
8		LDR r0, =0
9		POP {pc}
10		.ltorg
11	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/skip/comment.wacc
-- Test: comment.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple skip program with comment line

# Output:
# #empty#

# Program:

begin 
  # I can write stuff on a comment line
  skip 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
comment.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/skip/commentInLine.wacc
-- Test: commentInLine.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple skip program with in-line comment

# Output:
# #empty#

# Program:

begin 
  skip # I can write comments in-line 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
commentInLine.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/basic/skip/skip.wacc
-- Test: skip.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple skip program

# Output:
# #empty#

# Program:

begin skip end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
skip.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/andExpr.wacc
-- Test: andExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating and

# Output:
# false
# true
# false

# Program:

begin
  bool a = true ;
  bool b = false ;
  println a && b ;
  println a && true ;
  println b && false
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
andExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #2
18		MOV r4, #1
19		STRB r4, [sp, #1]
20		MOV r4, #0
21		STRB r4, [sp]
22		LDRSB r4, [sp, #1]
23		LDRSB r5, [sp]
24		AND r4, r4, r5
25		MOV r0, r4
26		BL p_print_bool
27		BL p_print_ln
28		LDRSB r4, [sp, #1]
29		MOV r5, #1
30		AND r4, r4, r5
31		MOV r0, r4
32		BL p_print_bool
33		BL p_print_ln
34		LDRSB r4, [sp]
35		MOV r5, #0
36		AND r4, r4, r5
37		MOV r0, r4
38		BL p_print_bool
39		BL p_print_ln
40		ADD sp, sp, #2
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_bool:
45		PUSH {lr}
46		CMP r0, #0
47		LDRNE r0, =msg_0
48		LDREQ r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/boolCalc.wacc
-- Test: boolCalc.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple boolean calculation

# Output:
# false

# Program:

begin
  bool b1 = true ;
  bool b2 = false ;
  bool b3 = b1 && b2 ;
  println b3
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
boolCalc.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #3
18		MOV r4, #1
19		STRB r4, [sp, #2]
20		MOV r4, #0
21		STRB r4, [sp, #1]
22		LDRSB r4, [sp, #2]
23		LDRSB r5, [sp, #1]
24		AND r4, r4, r5
25		STRB r4, [sp]
26		LDRSB r4, [sp]
27		MOV r0, r4
28		BL p_print_bool
29		BL p_print_ln
30		ADD sp, sp, #3
31		LDR r0, =0
32		POP {pc}
33		.ltorg
34	p_print_bool:
35		PUSH {lr}
36		CMP r0, #0
37		LDRNE r0, =msg_0
38		LDREQ r0, =msg_1
39		ADD r0, r0, #4
40		BL printf
41		MOV r0, #0
42		BL fflush
43		POP {pc}
44	p_print_ln:
45		PUSH {lr}
46		LDR r0, =msg_2
47		ADD r0, r0, #4
48		BL puts
49		MOV r0, #0
50		BL fflush
51		POP {pc}
52	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/boolExpr1.wacc
-- Test: boolExpr1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating a moderately complex boolean expression

# Output:
# Correct

# Program:

begin
  bool b = ! ( ( true && false) || (true && false) );
  if b == true then
    println "Correct"
  else
    println "Wrong"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
boolExpr1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"Correct"
5	msg_1:
6		.word 5
7		.ascii	"Wrong"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #1
21		MOV r4, #1
22		MOV r5, #0
23		AND r4, r4, r5
24		MOV r5, #1
25		MOV r6, #0
26		AND r5, r5, r6
27		ORR r4, r4, r5
28		EOR r4, r4, #1
29		STRB r4, [sp]
30		LDRSB r4, [sp]
31		MOV r5, #1
32		CMP r4, r5
33		MOVEQ r4, #1
34		MOVNE r4, #0
35		CMP r4, #0
36		BEQ L0
37		LDR r4, =msg_0
38		MOV r0, r4
39		BL p_print_string
40		BL p_print_ln
41		B L1
42	L0:
43		LDR r4, =msg_1
44		MOV r0, r4
45		BL p_print_string
46		BL p_print_ln
47	L1:
48		ADD sp, sp, #1
49		LDR r0, =0
50		POP {pc}
51		.ltorg
52	p_print_string:
53		PUSH {lr}
54		LDR r1, [r0]
55		ADD r2, r0, #4
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL printf
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_print_ln:
63		PUSH {lr}
64		LDR r0, =msg_3
65		ADD r0, r0, #4
66		BL puts
67		MOV r0, #0
68		BL fflush
69		POP {pc}
70	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/charComparisonExpr.wacc
-- Test: charComparisonExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# detailed battery of character comparison tests

# Output:
# false
# true
# true
# true
# false
# false

# Program:

begin
  char c1 = 'a' ;
  char c2 = 'z' ;
  println c1 == c2 ;
  println c1 != c2 ;
  println c1 < c2 ;
  println c1 <= c2 ;
  println c1 > c2 ;
  println c1 >= c2
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
charComparisonExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #2
18		MOV r4, #'a'
19		STRB r4, [sp, #1]
20		MOV r4, #'z'
21		STRB r4, [sp]
22		LDRSB r4, [sp, #1]
23		LDRSB r5, [sp]
24		CMP r4, r5
25		MOVEQ r4, #1
26		MOVNE r4, #0
27		MOV r0, r4
28		BL p_print_bool
29		BL p_print_ln
30		LDRSB r4, [sp, #1]
31		LDRSB r5, [sp]
32		CMP r4, r5
33		MOVNE r4, #1
34		MOVEQ r4, #0
35		MOV r0, r4
36		BL p_print_bool
37		BL p_print_ln
38		LDRSB r4, [sp, #1]
39		LDRSB r5, [sp]
40		CMP r4, r5
41		MOVLT r4, #1
42		MOVGE r4, #0
43		MOV r0, r4
44		BL p_print_bool
45		BL p_print_ln
46		LDRSB r4, [sp, #1]
47		LDRSB r5, [sp]
48		CMP r4, r5
49		MOVLE r4, #1
50		MOVGT r4, #0
51		MOV r0, r4
52		BL p_print_bool
53		BL p_print_ln
54		LDRSB r4, [sp, #1]
55		LDRSB r5, [sp]
56		CMP r4, r5
57		MOVGT r4, #1
58		MOVLE r4, #0
59		MOV r0, r4
60		BL p_print_bool
61		BL p_print_ln
62		LDRSB r4, [sp, #1]
63		LDRSB r5, [sp]
64		CMP r4, r5
65		MOVGE r4, #1
66		MOVLT r4, #0
67		MOV r0, r4
68		BL p_print_bool
69		BL p_print_ln
70		ADD sp, sp, #2
71		LDR r0, =0
72		POP {pc}
73		.ltorg
74	p_print_bool:
75		PUSH {lr}
76		CMP r0, #0
77		LDRNE r0, =msg_0
78		LDREQ r0, =msg_1
79		ADD r0, r0, #4
80		BL printf
81		MOV r0, #0
82		BL fflush
83		POP {pc}
84	p_print_ln:
85		PUSH {lr}
86		LDR r0, =msg_2
87		ADD r0, r0, #4
88		BL puts
89		MOV r0, #0
90		BL fflush
91		POP {pc}
92	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/divExpr.wacc
-- Test: divExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating integer division

# Output:
# 1

# Program:

begin
  int x = 5 ;
  int y = 3 ;
  println x / y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
divExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =5
22		STR r4, [sp, #4]
23		LDR r4, =3
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idiv
31		MOV r4, r0
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/equalsExpr.wacc
-- Test: equalsExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating equality

# Output:
# false
# false
# true

# Program:

begin
  int x = 2 ;
  int y = 4 ;
  int z = 4 ;
  bool b = x == y ;
  println b ;
  println x == y ;
  println y == z
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
equalsExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #13
18		LDR r4, =2
19		STR r4, [sp, #9]
20		LDR r4, =4
21		STR r4, [sp, #5]
22		LDR r4, =4
23		STR r4, [sp, #1]
24		LDR r4, [sp, #9]
25		LDR r5, [sp, #5]
26		CMP r4, r5
27		MOVEQ r4, #1
28		MOVNE r4, #0
29		STRB r4, [sp]
30		LDRSB r4, [sp]
31		MOV r0, r4
32		BL p_print_bool
33		BL p_print_ln
34		LDR r4, [sp, #9]
35		LDR r5, [sp, #5]
36		CMP r4, r5
37		MOVEQ r4, #1
38		MOVNE r4, #0
39		MOV r0, r4
40		BL p_print_bool
41		BL p_print_ln
42		LDR r4, [sp, #5]
43		LDR r5, [sp, #1]
44		CMP r4, r5
45		MOVEQ r4, #1
46		MOVNE r4, #0
47		MOV r0, r4
48		BL p_print_bool
49		BL p_print_ln
50		ADD sp, sp, #13
51		LDR r0, =0
52		POP {pc}
53		.ltorg
54	p_print_bool:
55		PUSH {lr}
56		CMP r0, #0
57		LDRNE r0, =msg_0
58		LDREQ r0, =msg_1
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	p_print_ln:
65		PUSH {lr}
66		LDR r0, =msg_2
67		ADD r0, r0, #4
68		BL puts
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/greaterEqExpr.wacc
-- Test: greaterEqExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating greater-than

# Output:
# false
# true
# true

# Program:

begin
  int x = 2 ;
  int y = 6 ;
  int z = 4 ;
  int a = 4 ;
  println x >= y ;
  println y >= z ;
  println z >= z
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
greaterEqExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #16
18		LDR r4, =2
19		STR r4, [sp, #12]
20		LDR r4, =6
21		STR r4, [sp, #8]
22		LDR r4, =4
23		STR r4, [sp, #4]
24		LDR r4, =4
25		STR r4, [sp]
26		LDR r4, [sp, #12]
27		LDR r5, [sp, #8]
28		CMP r4, r5
29		MOVGE r4, #1
30		MOVLT r4, #0
31		MOV r0, r4
32		BL p_print_bool
33		BL p_print_ln
34		LDR r4, [sp, #8]
35		LDR r5, [sp, #4]
36		CMP r4, r5
37		MOVGE r4, #1
38		MOVLT r4, #0
39		MOV r0, r4
40		BL p_print_bool
41		BL p_print_ln
42		LDR r4, [sp, #4]
43		LDR r5, [sp, #4]
44		CMP r4, r5
45		MOVGE r4, #1
46		MOVLT r4, #0
47		MOV r0, r4
48		BL p_print_bool
49		BL p_print_ln
50		ADD sp, sp, #16
51		LDR r0, =0
52		POP {pc}
53		.ltorg
54	p_print_bool:
55		PUSH {lr}
56		CMP r0, #0
57		LDRNE r0, =msg_0
58		LDREQ r0, =msg_1
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	p_print_ln:
65		PUSH {lr}
66		LDR r0, =msg_2
67		ADD r0, r0, #4
68		BL puts
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/greaterExpr.wacc
-- Test: greaterExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating greater-than

# Output:
# false
# true

# Program:

begin
  int x = 2 ;
  int y = 6 ;
  int z = 4 ;
  println x > y ;
  println y > z
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
greaterExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #12
18		LDR r4, =2
19		STR r4, [sp, #8]
20		LDR r4, =6
21		STR r4, [sp, #4]
22		LDR r4, =4
23		STR r4, [sp]
24		LDR r4, [sp, #8]
25		LDR r5, [sp, #4]
26		CMP r4, r5
27		MOVGT r4, #1
28		MOVLE r4, #0
29		MOV r0, r4
30		BL p_print_bool
31		BL p_print_ln
32		LDR r4, [sp, #4]
33		LDR r5, [sp]
34		CMP r4, r5
35		MOVGT r4, #1
36		MOVLE r4, #0
37		MOV r0, r4
38		BL p_print_bool
39		BL p_print_ln
40		ADD sp, sp, #12
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_bool:
45		PUSH {lr}
46		CMP r0, #0
47		LDRNE r0, =msg_0
48		LDREQ r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/intCalc.wacc
-- Test: intCalc.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple integer calculation

# Output:
# 72

# Program:

begin
  int x = 42 ;
  int y = 30 ;
  int z = x + y ;
  println z
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intCalc.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #12
21		LDR r4, =42
22		STR r4, [sp, #8]
23		LDR r4, =30
24		STR r4, [sp, #4]
25		LDR r4, [sp, #8]
26		LDR r5, [sp, #4]
27		ADDS r4, r4, r5
28		BLVS p_throw_overflow_error
29		STR r4, [sp]
30		LDR r4, [sp]
31		MOV r0, r4
32		BL p_print_int
33		BL p_print_ln
34		ADD sp, sp, #12
35		LDR r0, =0
36		POP {pc}
37		.ltorg
38	p_throw_overflow_error:
39		LDR r0, =msg_0
40		BL p_throw_runtime_error
41	p_print_int:
42		PUSH {lr}
43		MOV r1, r0
44		LDR r0, =msg_1
45		ADD r0, r0, #4
46		BL printf
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_print_ln:
51		PUSH {lr}
52		LDR r0, =msg_2
53		ADD r0, r0, #4
54		BL puts
55		MOV r0, #0
56		BL fflush
57		POP {pc}
58	p_throw_runtime_error:
59		BL p_print_string
60		MOV r0, #-1
61		BL exit
62	p_print_string:
63		PUSH {lr}
64		LDR r1, [r0]
65		ADD r2, r0, #4
66		LDR r0, =msg_3
67		ADD r0, r0, #4
68		BL printf
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/intExpr1.wacc
-- Test: intExpr1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating a moderately complex integer expression

# Output:
# Correct

# Program:

begin
  int a = ( 10 * 1 + 2 * 15 );
  if a == 40 then
    println "Correct"
  else
    println "Wrong"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intExpr1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"Correct"
5	msg_1:
6		.word 5
7		.ascii	"Wrong"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =10
25		LDR r5, =1
26		SMULL r4, r5, r4, r5
27		CMP r5, r4, ASR #31
28		BLNE p_throw_overflow_error
29		LDR r5, =2
30		LDR r6, =15
31		SMULL r5, r6, r5, r6
32		CMP r6, r5, ASR #31
33		BLNE p_throw_overflow_error
34		ADDS r4, r4, r5
35		BLVS p_throw_overflow_error
36		STR r4, [sp]
37		LDR r4, [sp]
38		LDR r5, =40
39		CMP r4, r5
40		MOVEQ r4, #1
41		MOVNE r4, #0
42		CMP r4, #0
43		BEQ L0
44		LDR r4, =msg_0
45		MOV r0, r4
46		BL p_print_string
47		BL p_print_ln
48		B L1
49	L0:
50		LDR r4, =msg_1
51		MOV r0, r4
52		BL p_print_string
53		BL p_print_ln
54	L1:
55		ADD sp, sp, #4
56		LDR r0, =0
57		POP {pc}
58		.ltorg
59	p_throw_overflow_error:
60		LDR r0, =msg_2
61		BL p_throw_runtime_error
62	p_print_string:
63		PUSH {lr}
64		LDR r1, [r0]
65		ADD r2, r0, #4
66		LDR r0, =msg_3
67		ADD r0, r0, #4
68		BL printf
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	p_print_ln:
73		PUSH {lr}
74		LDR r0, =msg_4
75		ADD r0, r0, #4
76		BL puts
77		MOV r0, #0
78		BL fflush
79		POP {pc}
80	p_throw_runtime_error:
81		BL p_print_string
82		MOV r0, #-1
83		BL exit
84	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/lessCharExpr.wacc
-- Test: lessCharExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating less-than on characters

# Output:
# true
# false

# Program:

begin
  char a = 'a' ;
  char e = 'e' ;
  char c = 'c' ;
  println a < e ;
  println e < c
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
lessCharExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #3
18		MOV r4, #'a'
19		STRB r4, [sp, #2]
20		MOV r4, #'e'
21		STRB r4, [sp, #1]
22		MOV r4, #'c'
23		STRB r4, [sp]
24		LDRSB r4, [sp, #2]
25		LDRSB r5, [sp, #1]
26		CMP r4, r5
27		MOVLT r4, #1
28		MOVGE r4, #0
29		MOV r0, r4
30		BL p_print_bool
31		BL p_print_ln
32		LDRSB r4, [sp, #1]
33		LDRSB r5, [sp]
34		CMP r4, r5
35		MOVLT r4, #1
36		MOVGE r4, #0
37		MOV r0, r4
38		BL p_print_bool
39		BL p_print_ln
40		ADD sp, sp, #3
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_bool:
45		PUSH {lr}
46		CMP r0, #0
47		LDRNE r0, =msg_0
48		LDREQ r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/lessEqExpr.wacc
-- Test: lessEqExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating less-than-or-equal-to

# Output:
# true
# false
# true

# Program:

begin
  int x = 2 ;
  int y = 6 ;
  int z = 4 ;
  int a = 4 ;
  println x <= y ;
  println y <= z ;
  println z <= a
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
lessEqExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #16
18		LDR r4, =2
19		STR r4, [sp, #12]
20		LDR r4, =6
21		STR r4, [sp, #8]
22		LDR r4, =4
23		STR r4, [sp, #4]
24		LDR r4, =4
25		STR r4, [sp]
26		LDR r4, [sp, #12]
27		LDR r5, [sp, #8]
28		CMP r4, r5
29		MOVLE r4, #1
30		MOVGT r4, #0
31		MOV r0, r4
32		BL p_print_bool
33		BL p_print_ln
34		LDR r4, [sp, #8]
35		LDR r5, [sp, #4]
36		CMP r4, r5
37		MOVLE r4, #1
38		MOVGT r4, #0
39		MOV r0, r4
40		BL p_print_bool
41		BL p_print_ln
42		LDR r4, [sp, #4]
43		LDR r5, [sp]
44		CMP r4, r5
45		MOVLE r4, #1
46		MOVGT r4, #0
47		MOV r0, r4
48		BL p_print_bool
49		BL p_print_ln
50		ADD sp, sp, #16
51		LDR r0, =0
52		POP {pc}
53		.ltorg
54	p_print_bool:
55		PUSH {lr}
56		CMP r0, #0
57		LDRNE r0, =msg_0
58		LDREQ r0, =msg_1
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	p_print_ln:
65		PUSH {lr}
66		LDR r0, =msg_2
67		ADD r0, r0, #4
68		BL puts
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/lessExpr.wacc
-- Test: lessExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating less-than

# Output:
# true
# false

# Program:

begin
  int x = 2 ;
  int y = 6 ;
  int z = 4 ;
  println x < y ;
  println y < z
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
lessExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #12
18		LDR r4, =2
19		STR r4, [sp, #8]
20		LDR r4, =6
21		STR r4, [sp, #4]
22		LDR r4, =4
23		STR r4, [sp]
24		LDR r4, [sp, #8]
25		LDR r5, [sp, #4]
26		CMP r4, r5
27		MOVLT r4, #1
28		MOVGE r4, #0
29		MOV r0, r4
30		BL p_print_bool
31		BL p_print_ln
32		LDR r4, [sp, #4]
33		LDR r5, [sp]
34		CMP r4, r5
35		MOVLT r4, #1
36		MOVGE r4, #0
37		MOV r0, r4
38		BL p_print_bool
39		BL p_print_ln
40		ADD sp, sp, #12
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_bool:
45		PUSH {lr}
46		CMP r0, #0
47		LDRNE r0, =msg_0
48		LDREQ r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/longExpr.wacc
-- Test: longExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# tests whether the compiler can handle long expressions

# Output:
# #empty#

# Exit:
# 153

begin

  int x = 1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (15 + (16 + 17)))))))))))))));
  exit x

end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
longExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =1
16		LDR r5, =2
17		LDR r6, =3
18		LDR r7, =4
19		LDR r8, =5
20		LDR r9, =6
21		LDR r10, =7
22		PUSH {r10}
23		LDR r10, =8
24		PUSH {r10}
25		LDR r10, =9
26		PUSH {r10}
27		LDR r10, =10
28		PUSH {r10}
29		LDR r10, =11
30		PUSH {r10}
31		LDR r10, =12
32		PUSH {r10}
33		LDR r10, =13
34		PUSH {r10}
35		LDR r10, =14
36		PUSH {r10}
37		LDR r10, =15
38		PUSH {r10}
39		LDR r10, =16
40		PUSH {r10}
41		LDR r10, =17
42		POP {r11}
43		ADDS r10, r11, r10
44		BLVS p_throw_overflow_error
45		POP {r11}
46		ADDS r10, r11, r10
47		BLVS p_throw_overflow_error
48		POP {r11}
49		ADDS r10, r11, r10
50		BLVS p_throw_overflow_error
51		POP {r11}
52		ADDS r10, r11, r10
53		BLVS p_throw_overflow_error
54		POP {r11}
55		ADDS r10, r11, r10
56		BLVS p_throw_overflow_error
57		POP {r11}
58		ADDS r10, r11, r10
59		BLVS p_throw_overflow_error
60		POP {r11}
61		ADDS r10, r11, r10
62		BLVS p_throw_overflow_error
63		POP {r11}
64		ADDS r10, r11, r10
65		BLVS p_throw_overflow_error
66		POP {r11}
67		ADDS r10, r11, r10
68		BLVS p_throw_overflow_error
69		POP {r11}
70		ADDS r10, r11, r10
71		BLVS p_throw_overflow_error
72		ADDS r9, r9, r10
73		BLVS p_throw_overflow_error
74		ADDS r8, r8, r9
75		BLVS p_throw_overflow_error
76		ADDS r7, r7, r8
77		BLVS p_throw_overflow_error
78		ADDS r6, r6, r7
79		BLVS p_throw_overflow_error
80		ADDS r5, r5, r6
81		BLVS p_throw_overflow_error
82		ADDS r4, r4, r5
83		BLVS p_throw_overflow_error
84		STR r4, [sp]
85		LDR r4, [sp]
86		MOV r0, r4
87		BL exit
88		ADD sp, sp, #4
89		LDR r0, =0
90		POP {pc}
91		.ltorg
92	p_throw_overflow_error:
93		LDR r0, =msg_0
94		BL p_throw_runtime_error
95	p_throw_runtime_error:
96		BL p_print_string
97		MOV r0, #-1
98		BL exit
99	p_print_string:
100		PUSH {lr}
101		LDR r1, [r0]
102		ADD r2, r0, #4
103		LDR r0, =msg_1
104		ADD r0, r0, #4
105		BL printf
106		MOV r0, #0
107		BL fflush
108		POP {pc}
109	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/longExpr2.wacc
-- Test: longExpr2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# tests whether the compiler can handle long expressions

# Output:
# #empty#

# Exit:
# 10

begin

  int x = (2 + 3 + 2 + 1 + 1 + 1) - (1 + 2) * (3 - 4 / 6) / ( 2 * (18 - 17) + (3 * 4 / 4 + 6));
  exit x

end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
longExpr2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 45
7		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #4
18		LDR r4, =2
19		LDR r5, =3
20		ADDS r4, r4, r5
21		BLVS p_throw_overflow_error
22		LDR r5, =2
23		ADDS r4, r4, r5
24		BLVS p_throw_overflow_error
25		LDR r5, =1
26		ADDS r4, r4, r5
27		BLVS p_throw_overflow_error
28		LDR r5, =1
29		ADDS r4, r4, r5
30		BLVS p_throw_overflow_error
31		LDR r5, =1
32		ADDS r4, r4, r5
33		BLVS p_throw_overflow_error
34		LDR r5, =1
35		LDR r6, =2
36		ADDS r5, r5, r6
37		BLVS p_throw_overflow_error
38		LDR r6, =3
39		LDR r7, =4
40		LDR r8, =6
41		MOV r0, r7
42		MOV r1, r8
43		BL p_check_divide_by_zero
44		BL __aeabi_idiv
45		MOV r7, r0
46		SUBS r6, r6, r7
47		BLVS p_throw_overflow_error
48		SMULL r5, r6, r5, r6
49		CMP r6, r5, ASR #31
50		BLNE p_throw_overflow_error
51		LDR r6, =2
52		LDR r7, =18
53		LDR r8, =17
54		SUBS r7, r7, r8
55		BLVS p_throw_overflow_error
56		SMULL r6, r7, r6, r7
57		CMP r7, r6, ASR #31
58		BLNE p_throw_overflow_error
59		LDR r7, =3
60		LDR r8, =4
61		SMULL r7, r8, r7, r8
62		CMP r8, r7, ASR #31
63		BLNE p_throw_overflow_error
64		LDR r8, =4
65		MOV r0, r7
66		MOV r1, r8
67		BL p_check_divide_by_zero
68		BL __aeabi_idiv
69		MOV r7, r0
70		LDR r8, =6
71		ADDS r7, r7, r8
72		BLVS p_throw_overflow_error
73		ADDS r6, r6, r7
74		BLVS p_throw_overflow_error
75		MOV r0, r5
76		MOV r1, r6
77		BL p_check_divide_by_zero
78		BL __aeabi_idiv
79		MOV r5, r0
80		SUBS r4, r4, r5
81		BLVS p_throw_overflow_error
82		STR r4, [sp]
83		LDR r4, [sp]
84		MOV r0, r4
85		BL exit
86		ADD sp, sp, #4
87		LDR r0, =0
88		POP {pc}
89		.ltorg
90	p_throw_overflow_error:
91		LDR r0, =msg_0
92		BL p_throw_runtime_error
93	p_check_divide_by_zero:
94		PUSH {lr}
95		CMP r1, #0
96		LDREQ r0, =msg_1
97		BLEQ p_throw_runtime_error
98		POP {pc}
99	p_throw_runtime_error:
100		BL p_print_string
101		MOV r0, #-1
102		BL exit
103	p_print_string:
104		PUSH {lr}
105		LDR r1, [r0]
106		ADD r2, r0, #4
107		LDR r0, =msg_2
108		ADD r0, r0, #4
109		BL printf
110		MOV r0, #0
111		BL fflush
112		POP {pc}
113	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/longExpr3.wacc
-- Test: longExpr3.wacc

-- Uploaded file: 
---------------------------------------------------------------
# tests whether the compiler can handle long expressions

# Output:
# #empty#

# Exit:
# 9

begin

  int x = ((((((((((((((((1 - 2) + 3) - 4) + 5) - 6) + 7) - 8) + 9) - 10) + 11) - 12) + 13) - 14) + 15) - 16) + 17);
  exit x

end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
longExpr3.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =1
16		LDR r5, =2
17		SUBS r4, r4, r5
18		BLVS p_throw_overflow_error
19		LDR r5, =3
20		ADDS r4, r4, r5
21		BLVS p_throw_overflow_error
22		LDR r5, =4
23		SUBS r4, r4, r5
24		BLVS p_throw_overflow_error
25		LDR r5, =5
26		ADDS r4, r4, r5
27		BLVS p_throw_overflow_error
28		LDR r5, =6
29		SUBS r4, r4, r5
30		BLVS p_throw_overflow_error
31		LDR r5, =7
32		ADDS r4, r4, r5
33		BLVS p_throw_overflow_error
34		LDR r5, =8
35		SUBS r4, r4, r5
36		BLVS p_throw_overflow_error
37		LDR r5, =9
38		ADDS r4, r4, r5
39		BLVS p_throw_overflow_error
40		LDR r5, =10
41		SUBS r4, r4, r5
42		BLVS p_throw_overflow_error
43		LDR r5, =11
44		ADDS r4, r4, r5
45		BLVS p_throw_overflow_error
46		LDR r5, =12
47		SUBS r4, r4, r5
48		BLVS p_throw_overflow_error
49		LDR r5, =13
50		ADDS r4, r4, r5
51		BLVS p_throw_overflow_error
52		LDR r5, =14
53		SUBS r4, r4, r5
54		BLVS p_throw_overflow_error
55		LDR r5, =15
56		ADDS r4, r4, r5
57		BLVS p_throw_overflow_error
58		LDR r5, =16
59		SUBS r4, r4, r5
60		BLVS p_throw_overflow_error
61		LDR r5, =17
62		ADDS r4, r4, r5
63		BLVS p_throw_overflow_error
64		STR r4, [sp]
65		LDR r4, [sp]
66		MOV r0, r4
67		BL exit
68		ADD sp, sp, #4
69		LDR r0, =0
70		POP {pc}
71		.ltorg
72	p_throw_overflow_error:
73		LDR r0, =msg_0
74		BL p_throw_runtime_error
75	p_throw_runtime_error:
76		BL p_print_string
77		MOV r0, #-1
78		BL exit
79	p_print_string:
80		PUSH {lr}
81		LDR r1, [r0]
82		ADD r2, r0, #4
83		LDR r0, =msg_1
84		ADD r0, r0, #4
85		BL printf
86		MOV r0, #0
87		BL fflush
88		POP {pc}
89	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/longSplitExpr.wacc
-- Test: longSplitExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# tests whether the compiler can handle long expressions with several variables

# Output:
# #empty#

# Exit:
# 153

begin

  int a = 1 + 2 ;
  int b = 3 + 4 ; 
  int c = 5 + 6 ;
  int d = 7 + 8 ;
  int e = 9 + 10 ;
  int f = 11 + 12 ;
  int g = 13 + 14 ;
  int h = 15 + 16 ;
  int i = 17 ;
  exit a + b + c + d + e + f + g + h + i

end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
longSplitExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #36
15		LDR r4, =1
16		LDR r5, =2
17		ADDS r4, r4, r5
18		BLVS p_throw_overflow_error
19		STR r4, [sp, #32]
20		LDR r4, =3
21		LDR r5, =4
22		ADDS r4, r4, r5
23		BLVS p_throw_overflow_error
24		STR r4, [sp, #28]
25		LDR r4, =5
26		LDR r5, =6
27		ADDS r4, r4, r5
28		BLVS p_throw_overflow_error
29		STR r4, [sp, #24]
30		LDR r4, =7
31		LDR r5, =8
32		ADDS r4, r4, r5
33		BLVS p_throw_overflow_error
34		STR r4, [sp, #20]
35		LDR r4, =9
36		LDR r5, =10
37		ADDS r4, r4, r5
38		BLVS p_throw_overflow_error
39		STR r4, [sp, #16]
40		LDR r4, =11
41		LDR r5, =12
42		ADDS r4, r4, r5
43		BLVS p_throw_overflow_error
44		STR r4, [sp, #12]
45		LDR r4, =13
46		LDR r5, =14
47		ADDS r4, r4, r5
48		BLVS p_throw_overflow_error
49		STR r4, [sp, #8]
50		LDR r4, =15
51		LDR r5, =16
52		ADDS r4, r4, r5
53		BLVS p_throw_overflow_error
54		STR r4, [sp, #4]
55		LDR r4, =17
56		STR r4, [sp]
57		LDR r4, [sp, #32]
58		LDR r5, [sp, #28]
59		ADDS r4, r4, r5
60		BLVS p_throw_overflow_error
61		LDR r5, [sp, #24]
62		ADDS r4, r4, r5
63		BLVS p_throw_overflow_error
64		LDR r5, [sp, #20]
65		ADDS r4, r4, r5
66		BLVS p_throw_overflow_error
67		LDR r5, [sp, #16]
68		ADDS r4, r4, r5
69		BLVS p_throw_overflow_error
70		LDR r5, [sp, #12]
71		ADDS r4, r4, r5
72		BLVS p_throw_overflow_error
73		LDR r5, [sp, #8]
74		ADDS r4, r4, r5
75		BLVS p_throw_overflow_error
76		LDR r5, [sp, #4]
77		ADDS r4, r4, r5
78		BLVS p_throw_overflow_error
79		LDR r5, [sp]
80		ADDS r4, r4, r5
81		BLVS p_throw_overflow_error
82		MOV r0, r4
83		BL exit
84		ADD sp, sp, #36
85		LDR r0, =0
86		POP {pc}
87		.ltorg
88	p_throw_overflow_error:
89		LDR r0, =msg_0
90		BL p_throw_runtime_error
91	p_throw_runtime_error:
92		BL p_print_string
93		MOV r0, #-1
94		BL exit
95	p_print_string:
96		PUSH {lr}
97		LDR r1, [r0]
98		ADD r2, r0, #4
99		LDR r0, =msg_1
100		ADD r0, r0, #4
101		BL printf
102		MOV r0, #0
103		BL fflush
104		POP {pc}
105	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/longSplitExpr2.wacc
-- Test: longSplitExpr2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# tests whether the compiler can handle long expressions with several variables

# Output:
# 362880
# 128

# Exit:
# 128

begin

  int x = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 ;
  int y = -1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 - 13 - 14 - 15 - 16 - 17 ;
  int z = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 ;
  int div = 10 ;
  println x + y + ( z / div ) ;
  println (x + y + ( z / div )) % 256 ;
  exit x + y + ( z / div )

end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
longSplitExpr2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 45
7		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #16
24		LDR r4, =1
25		LDR r5, =2
26		ADDS r4, r4, r5
27		BLVS p_throw_overflow_error
28		LDR r5, =3
29		ADDS r4, r4, r5
30		BLVS p_throw_overflow_error
31		LDR r5, =4
32		ADDS r4, r4, r5
33		BLVS p_throw_overflow_error
34		LDR r5, =5
35		ADDS r4, r4, r5
36		BLVS p_throw_overflow_error
37		LDR r5, =6
38		ADDS r4, r4, r5
39		BLVS p_throw_overflow_error
40		LDR r5, =7
41		ADDS r4, r4, r5
42		BLVS p_throw_overflow_error
43		LDR r5, =8
44		ADDS r4, r4, r5
45		BLVS p_throw_overflow_error
46		LDR r5, =9
47		ADDS r4, r4, r5
48		BLVS p_throw_overflow_error
49		LDR r5, =10
50		ADDS r4, r4, r5
51		BLVS p_throw_overflow_error
52		LDR r5, =11
53		ADDS r4, r4, r5
54		BLVS p_throw_overflow_error
55		LDR r5, =12
56		ADDS r4, r4, r5
57		BLVS p_throw_overflow_error
58		LDR r5, =13
59		ADDS r4, r4, r5
60		BLVS p_throw_overflow_error
61		LDR r5, =14
62		ADDS r4, r4, r5
63		BLVS p_throw_overflow_error
64		LDR r5, =15
65		ADDS r4, r4, r5
66		BLVS p_throw_overflow_error
67		LDR r5, =16
68		ADDS r4, r4, r5
69		BLVS p_throw_overflow_error
70		LDR r5, =17
71		ADDS r4, r4, r5
72		BLVS p_throw_overflow_error
73		STR r4, [sp, #12]
74		LDR r4, =-1
75		LDR r5, =2
76		SUBS r4, r4, r5
77		BLVS p_throw_overflow_error
78		LDR r5, =3
79		SUBS r4, r4, r5
80		BLVS p_throw_overflow_error
81		LDR r5, =4
82		SUBS r4, r4, r5
83		BLVS p_throw_overflow_error
84		LDR r5, =5
85		SUBS r4, r4, r5
86		BLVS p_throw_overflow_error
87		LDR r5, =6
88		SUBS r4, r4, r5
89		BLVS p_throw_overflow_error
90		LDR r5, =7
91		SUBS r4, r4, r5
92		BLVS p_throw_overflow_error
93		LDR r5, =8
94		SUBS r4, r4, r5
95		BLVS p_throw_overflow_error
96		LDR r5, =9
97		SUBS r4, r4, r5
98		BLVS p_throw_overflow_error
99		LDR r5, =10
100		SUBS r4, r4, r5
101		BLVS p_throw_overflow_error
102		LDR r5, =11
103		SUBS r4, r4, r5
104		BLVS p_throw_overflow_error
105		LDR r5, =12
106		SUBS r4, r4, r5
107		BLVS p_throw_overflow_error
108		LDR r5, =13
109		SUBS r4, r4, r5
110		BLVS p_throw_overflow_error
111		LDR r5, =14
112		SUBS r4, r4, r5
113		BLVS p_throw_overflow_error
114		LDR r5, =15
115		SUBS r4, r4, r5
116		BLVS p_throw_overflow_error
117		LDR r5, =16
118		SUBS r4, r4, r5
119		BLVS p_throw_overflow_error
120		LDR r5, =17
121		SUBS r4, r4, r5
122		BLVS p_throw_overflow_error
123		STR r4, [sp, #8]
124		LDR r4, =1
125		LDR r5, =2
126		SMULL r4, r5, r4, r5
127		CMP r5, r4, ASR #31
128		BLNE p_throw_overflow_error
129		LDR r5, =3
130		SMULL r4, r5, r4, r5
131		CMP r5, r4, ASR #31
132		BLNE p_throw_overflow_error
133		LDR r5, =4
134		SMULL r4, r5, r4, r5
135		CMP r5, r4, ASR #31
136		BLNE p_throw_overflow_error
137		LDR r5, =5
138		SMULL r4, r5, r4, r5
139		CMP r5, r4, ASR #31
140		BLNE p_throw_overflow_error
141		LDR r5, =6
142		SMULL r4, r5, r4, r5
143		CMP r5, r4, ASR #31
144		BLNE p_throw_overflow_error
145		LDR r5, =7
146		SMULL r4, r5, r4, r5
147		CMP r5, r4, ASR #31
148		BLNE p_throw_overflow_error
149		LDR r5, =8
150		SMULL r4, r5, r4, r5
151		CMP r5, r4, ASR #31
152		BLNE p_throw_overflow_error
153		LDR r5, =9
154		SMULL r4, r5, r4, r5
155		CMP r5, r4, ASR #31
156		BLNE p_throw_overflow_error
157		LDR r5, =10
158		SMULL r4, r5, r4, r5
159		CMP r5, r4, ASR #31
160		BLNE p_throw_overflow_error
161		STR r4, [sp, #4]
162		LDR r4, =10
163		STR r4, [sp]
164		LDR r4, [sp, #12]
165		LDR r5, [sp, #8]
166		ADDS r4, r4, r5
167		BLVS p_throw_overflow_error
168		LDR r5, [sp, #4]
169		LDR r6, [sp]
170		MOV r0, r5
171		MOV r1, r6
172		BL p_check_divide_by_zero
173		BL __aeabi_idiv
174		MOV r5, r0
175		ADDS r4, r4, r5
176		BLVS p_throw_overflow_error
177		MOV r0, r4
178		BL p_print_int
179		BL p_print_ln
180		LDR r4, [sp, #12]
181		LDR r5, [sp, #8]
182		ADDS r4, r4, r5
183		BLVS p_throw_overflow_error
184		LDR r5, [sp, #4]
185		LDR r6, [sp]
186		MOV r0, r5
187		MOV r1, r6
188		BL p_check_divide_by_zero
189		BL __aeabi_idiv
190		MOV r5, r0
191		ADDS r4, r4, r5
192		BLVS p_throw_overflow_error
193		LDR r5, =256
194		MOV r0, r4
195		MOV r1, r5
196		BL p_check_divide_by_zero
197		BL __aeabi_idivmod
198		MOV r4, r1
199		MOV r0, r4
200		BL p_print_int
201		BL p_print_ln
202		LDR r4, [sp, #12]
203		LDR r5, [sp, #8]
204		ADDS r4, r4, r5
205		BLVS p_throw_overflow_error
206		LDR r5, [sp, #4]
207		LDR r6, [sp]
208		MOV r0, r5
209		MOV r1, r6
210		BL p_check_divide_by_zero
211		BL __aeabi_idiv
212		MOV r5, r0
213		ADDS r4, r4, r5
214		BLVS p_throw_overflow_error
215		MOV r0, r4
216		BL exit
217		ADD sp, sp, #16
218		LDR r0, =0
219		POP {pc}
220		.ltorg
221	p_throw_overflow_error:
222		LDR r0, =msg_0
223		BL p_throw_runtime_error
224	p_check_divide_by_zero:
225		PUSH {lr}
226		CMP r1, #0
227		LDREQ r0, =msg_1
228		BLEQ p_throw_runtime_error
229		POP {pc}
230	p_print_int:
231		PUSH {lr}
232		MOV r1, r0
233		LDR r0, =msg_2
234		ADD r0, r0, #4
235		BL printf
236		MOV r0, #0
237		BL fflush
238		POP {pc}
239	p_print_ln:
240		PUSH {lr}
241		LDR r0, =msg_3
242		ADD r0, r0, #4
243		BL puts
244		MOV r0, #0
245		BL fflush
246		POP {pc}
247	p_throw_runtime_error:
248		BL p_print_string
249		MOV r0, #-1
250		BL exit
251	p_print_string:
252		PUSH {lr}
253		LDR r1, [r0]
254		ADD r2, r0, #4
255		LDR r0, =msg_4
256		ADD r0, r0, #4
257		BL printf
258		MOV r0, #0
259		BL fflush
260		POP {pc}
261	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/minusExpr.wacc
-- Test: minusExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating subtraction

# Output:
# 5

# Program:

begin
  int x = 15 ;
  int y = 20 ;
  println y - x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
minusExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =15
22		STR r4, [sp, #4]
23		LDR r4, =20
24		STR r4, [sp]
25		LDR r4, [sp]
26		LDR r5, [sp, #4]
27		SUBS r4, r4, r5
28		BLVS p_throw_overflow_error
29		MOV r0, r4
30		BL p_print_int
31		BL p_print_ln
32		ADD sp, sp, #8
33		LDR r0, =0
34		POP {pc}
35		.ltorg
36	p_throw_overflow_error:
37		LDR r0, =msg_0
38		BL p_throw_runtime_error
39	p_print_int:
40		PUSH {lr}
41		MOV r1, r0
42		LDR r0, =msg_1
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_2
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	p_throw_runtime_error:
57		BL p_print_string
58		MOV r0, #-1
59		BL exit
60	p_print_string:
61		PUSH {lr}
62		LDR r1, [r0]
63		ADD r2, r0, #4
64		LDR r0, =msg_3
65		ADD r0, r0, #4
66		BL printf
67		MOV r0, #0
68		BL fflush
69		POP {pc}
70	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/minusMinusExpr.wacc
-- Test: minusMinusExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# -- should be recognised as two separate symbols

# Output:
# 3

# Program:

begin
  println 1--2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
minusMinusExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =-2
22		SUBS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_throw_overflow_error:
31		LDR r0, =msg_0
32		BL p_throw_runtime_error
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_2
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_3
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/minusNoWhitespaceExpr.wacc
-- Test: minusNoWhitespaceExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# subtraction expressions should not be whitespace sensitive

# Output:
# -1

# Program:

begin
  println 1-2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
minusNoWhitespaceExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =2
22		SUBS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_throw_overflow_error:
31		LDR r0, =msg_0
32		BL p_throw_runtime_error
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_2
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_3
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/minusPlusExpr.wacc
-- Test: minusPlusExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# -+ should be recognised as two separate symbols

# Output:
# -1

# Program:

begin
  println 1-+2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
minusPlusExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =2
22		SUBS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_throw_overflow_error:
31		LDR r0, =msg_0
32		BL p_throw_runtime_error
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_2
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_3
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/modExpr.wacc
-- Test: modExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating modulus

# Output:
# 2

# Program:

begin
  int x = 5 ;
  int y = 3 ;
  println x % y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
modExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =5
22		STR r4, [sp, #4]
23		LDR r4, =3
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idivmod
31		MOV r4, r1
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/multExpr.wacc
-- Test: multExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating multiplication

# Output:
# 15

# Program:

begin
  int x = 5 ;
  int y = 3 ;
  println x * y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
multExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =5
22		STR r4, [sp, #4]
23		LDR r4, =3
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		SMULL r4, r5, r4, r5
28		CMP r5, r4, ASR #31
29		BLNE p_throw_overflow_error
30		MOV r0, r4
31		BL p_print_int
32		BL p_print_ln
33		ADD sp, sp, #8
34		LDR r0, =0
35		POP {pc}
36		.ltorg
37	p_throw_overflow_error:
38		LDR r0, =msg_0
39		BL p_throw_runtime_error
40	p_print_int:
41		PUSH {lr}
42		MOV r1, r0
43		LDR r0, =msg_1
44		ADD r0, r0, #4
45		BL printf
46		MOV r0, #0
47		BL fflush
48		POP {pc}
49	p_print_ln:
50		PUSH {lr}
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL puts
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_throw_runtime_error:
58		BL p_print_string
59		MOV r0, #-1
60		BL exit
61	p_print_string:
62		PUSH {lr}
63		LDR r1, [r0]
64		ADD r2, r0, #4
65		LDR r0, =msg_3
66		ADD r0, r0, #4
67		BL printf
68		MOV r0, #0
69		BL fflush
70		POP {pc}
71	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/multNoWhitespaceExpr.wacc
-- Test: multNoWhitespaceExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# multiplication expressions should not be whitespace sensitive

# Output:
# 2

# Program:

begin
  println 1*2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
multNoWhitespaceExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =2
22		SMULL r4, r5, r4, r5
23		CMP r5, r4, ASR #31
24		BLNE p_throw_overflow_error
25		MOV r0, r4
26		BL p_print_int
27		BL p_print_ln
28		LDR r0, =0
29		POP {pc}
30		.ltorg
31	p_throw_overflow_error:
32		LDR r0, =msg_0
33		BL p_throw_runtime_error
34	p_print_int:
35		PUSH {lr}
36		MOV r1, r0
37		LDR r0, =msg_1
38		ADD r0, r0, #4
39		BL printf
40		MOV r0, #0
41		BL fflush
42		POP {pc}
43	p_print_ln:
44		PUSH {lr}
45		LDR r0, =msg_2
46		ADD r0, r0, #4
47		BL puts
48		MOV r0, #0
49		BL fflush
50		POP {pc}
51	p_throw_runtime_error:
52		BL p_print_string
53		MOV r0, #-1
54		BL exit
55	p_print_string:
56		PUSH {lr}
57		LDR r1, [r0]
58		ADD r2, r0, #4
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL printf
62		MOV r0, #0
63		BL fflush
64		POP {pc}
65	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negBothDiv.wacc
-- Test: negBothDiv.wacc

-- Uploaded file: 
---------------------------------------------------------------
# division of a negative number by a negative number

# Output:
# 2

# Program:

begin
  int x = -4 ;
  int y = -2 ;
  println x / y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negBothDiv.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =-4
22		STR r4, [sp, #4]
23		LDR r4, =-2
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idiv
31		MOV r4, r0
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negBothMod.wacc
-- Test: negBothMod.wacc

-- Uploaded file: 
---------------------------------------------------------------
# modulus of a negative number by a negative number

# Output:
# -2

# Program:

begin
  int x = -5 ;
  int y = -3 ;
  println x % y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negBothMod.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =-5
22		STR r4, [sp, #4]
23		LDR r4, =-3
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idivmod
31		MOV r4, r1
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negDividendDiv.wacc
-- Test: negDividendDiv.wacc

-- Uploaded file: 
---------------------------------------------------------------
# division of a negative number

# Output:
# -2

# Program:

begin
  int x = -4 ;
  int y = 2 ;
  println x / y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negDividendDiv.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =-4
22		STR r4, [sp, #4]
23		LDR r4, =2
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idiv
31		MOV r4, r0
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negDividendMod.wacc
-- Test: negDividendMod.wacc

-- Uploaded file: 
---------------------------------------------------------------
# modulus of a negative number

# Output:
# -2

# Program:

begin
  int x = -5 ;
  int y = 3 ;
  println x % y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negDividendMod.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =-5
22		STR r4, [sp, #4]
23		LDR r4, =3
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idivmod
31		MOV r4, r1
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negDivisorDiv.wacc
-- Test: negDivisorDiv.wacc

-- Uploaded file: 
---------------------------------------------------------------
# division by a negative number

# Output:
# -2

# Program:

begin
  int x = 4 ;
  int y = -2 ;
  println x / y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negDivisorDiv.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =4
22		STR r4, [sp, #4]
23		LDR r4, =-2
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idiv
31		MOV r4, r0
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negDivisorMod.wacc
-- Test: negDivisorMod.wacc

-- Uploaded file: 
---------------------------------------------------------------
# modulus by a negative number

# Output:
# 2

# Program:

begin
  int x = 5 ;
  int y = -3 ;
  println x % y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negDivisorMod.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =5
22		STR r4, [sp, #4]
23		LDR r4, =-3
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		MOV r0, r4
28		MOV r1, r5
29		BL p_check_divide_by_zero
30		BL __aeabi_idivmod
31		MOV r4, r1
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #8
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_check_divide_by_zero:
40		PUSH {lr}
41		CMP r1, #0
42		LDREQ r0, =msg_0
43		BLEQ p_throw_runtime_error
44		POP {pc}
45	p_print_int:
46		PUSH {lr}
47		MOV r1, r0
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_throw_runtime_error:
63		BL p_print_string
64		MOV r0, #-1
65		BL exit
66	p_print_string:
67		PUSH {lr}
68		LDR r1, [r0]
69		ADD r2, r0, #4
70		LDR r0, =msg_3
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/negExpr.wacc
-- Test: negExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating negation

# Output:
# -42

# Program:

begin
	int x = 42 ;
  println -x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =42
22		STR r4, [sp]
23		LDR r4, [sp]
24		RSBS r4, r4, #0
25		BLVS p_throw_overflow_error
26		MOV r0, r4
27		BL p_print_int
28		BL p_print_ln
29		ADD sp, sp, #4
30		LDR r0, =0
31		POP {pc}
32		.ltorg
33	p_throw_overflow_error:
34		LDR r0, =msg_0
35		BL p_throw_runtime_error
36	p_print_int:
37		PUSH {lr}
38		MOV r1, r0
39		LDR r0, =msg_1
40		ADD r0, r0, #4
41		BL printf
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	p_print_ln:
46		PUSH {lr}
47		LDR r0, =msg_2
48		ADD r0, r0, #4
49		BL puts
50		MOV r0, #0
51		BL fflush
52		POP {pc}
53	p_throw_runtime_error:
54		BL p_print_string
55		MOV r0, #-1
56		BL exit
57	p_print_string:
58		PUSH {lr}
59		LDR r1, [r0]
60		ADD r2, r0, #4
61		LDR r0, =msg_3
62		ADD r0, r0, #4
63		BL printf
64		MOV r0, #0
65		BL fflush
66		POP {pc}
67	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/notequalsExpr.wacc
-- Test: notequalsExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating inequality

# Output:
# true
# true
# false

# Program:

begin
  int x = 2 ;
  int y = 4 ;
  int z = 4 ;
  bool b = x != y ;
  println b ;
  println x != y ;
  println y != z
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
notequalsExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #13
18		LDR r4, =2
19		STR r4, [sp, #9]
20		LDR r4, =4
21		STR r4, [sp, #5]
22		LDR r4, =4
23		STR r4, [sp, #1]
24		LDR r4, [sp, #9]
25		LDR r5, [sp, #5]
26		CMP r4, r5
27		MOVNE r4, #1
28		MOVEQ r4, #0
29		STRB r4, [sp]
30		LDRSB r4, [sp]
31		MOV r0, r4
32		BL p_print_bool
33		BL p_print_ln
34		LDR r4, [sp, #9]
35		LDR r5, [sp, #5]
36		CMP r4, r5
37		MOVNE r4, #1
38		MOVEQ r4, #0
39		MOV r0, r4
40		BL p_print_bool
41		BL p_print_ln
42		LDR r4, [sp, #5]
43		LDR r5, [sp, #1]
44		CMP r4, r5
45		MOVNE r4, #1
46		MOVEQ r4, #0
47		MOV r0, r4
48		BL p_print_bool
49		BL p_print_ln
50		ADD sp, sp, #13
51		LDR r0, =0
52		POP {pc}
53		.ltorg
54	p_print_bool:
55		PUSH {lr}
56		CMP r0, #0
57		LDRNE r0, =msg_0
58		LDREQ r0, =msg_1
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	p_print_ln:
65		PUSH {lr}
66		LDR r0, =msg_2
67		ADD r0, r0, #4
68		BL puts
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/notExpr.wacc
-- Test: notExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating not

# Output:
# false
# true

# Program:

begin
  bool a = true ;
  bool b = false ;
  println !a ;
  println !b
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
notExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #2
18		MOV r4, #1
19		STRB r4, [sp, #1]
20		MOV r4, #0
21		STRB r4, [sp]
22		LDRSB r4, [sp, #1]
23		EOR r4, r4, #1
24		MOV r0, r4
25		BL p_print_bool
26		BL p_print_ln
27		LDRSB r4, [sp]
28		EOR r4, r4, #1
29		MOV r0, r4
30		BL p_print_bool
31		BL p_print_ln
32		ADD sp, sp, #2
33		LDR r0, =0
34		POP {pc}
35		.ltorg
36	p_print_bool:
37		PUSH {lr}
38		CMP r0, #0
39		LDRNE r0, =msg_0
40		LDREQ r0, =msg_1
41		ADD r0, r0, #4
42		BL printf
43		MOV r0, #0
44		BL fflush
45		POP {pc}
46	p_print_ln:
47		PUSH {lr}
48		LDR r0, =msg_2
49		ADD r0, r0, #4
50		BL puts
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/ordAndchrExpr.wacc
-- Test: ordAndchrExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evalutaing ord and chr

# Output:
# a is 97
# 99 is c

# Program:

begin
  char a = 'a' ;
  int i = 99 ;

  print a ;
  print " is " ;
  println ord a ;

  print i ;
  print " is " ;
  println chr i
end


---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ordAndchrExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 4
4		.ascii	" is "
5	msg_1:
6		.word 4
7		.ascii	" is "
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #5
24		MOV r4, #'a'
25		STRB r4, [sp, #4]
26		LDR r4, =99
27		STR r4, [sp]
28		LDRSB r4, [sp, #4]
29		MOV r0, r4
30		BL putchar
31		LDR r4, =msg_0
32		MOV r0, r4
33		BL p_print_string
34		LDRSB r4, [sp, #4]
35		MOV r0, r4
36		BL p_print_int
37		BL p_print_ln
38		LDR r4, [sp]
39		MOV r0, r4
40		BL p_print_int
41		LDR r4, =msg_1
42		MOV r0, r4
43		BL p_print_string
44		LDR r4, [sp]
45		MOV r0, r4
46		BL putchar
47		BL p_print_ln
48		ADD sp, sp, #5
49		LDR r0, =0
50		POP {pc}
51		.ltorg
52	p_print_string:
53		PUSH {lr}
54		LDR r1, [r0]
55		ADD r2, r0, #4
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL printf
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	p_print_int:
63		PUSH {lr}
64		MOV r1, r0
65		LDR r0, =msg_3
66		ADD r0, r0, #4
67		BL printf
68		MOV r0, #0
69		BL fflush
70		POP {pc}
71	p_print_ln:
72		PUSH {lr}
73		LDR r0, =msg_4
74		ADD r0, r0, #4
75		BL puts
76		MOV r0, #0
77		BL fflush
78		POP {pc}
79	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/orExpr.wacc
-- Test: orExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating or

# Output:
# true
# true
# false

# Program:

begin
  bool a = true ;
  bool b = false ;
  println a || b ;
  println a || true ;
  println b || false
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
orExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #2
18		MOV r4, #1
19		STRB r4, [sp, #1]
20		MOV r4, #0
21		STRB r4, [sp]
22		LDRSB r4, [sp, #1]
23		LDRSB r5, [sp]
24		ORR r4, r4, r5
25		MOV r0, r4
26		BL p_print_bool
27		BL p_print_ln
28		LDRSB r4, [sp, #1]
29		MOV r5, #1
30		ORR r4, r4, r5
31		MOV r0, r4
32		BL p_print_bool
33		BL p_print_ln
34		LDRSB r4, [sp]
35		MOV r5, #0
36		ORR r4, r4, r5
37		MOV r0, r4
38		BL p_print_bool
39		BL p_print_ln
40		ADD sp, sp, #2
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_bool:
45		PUSH {lr}
46		CMP r0, #0
47		LDRNE r0, =msg_0
48		LDREQ r0, =msg_1
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_2
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/plusExpr.wacc
-- Test: plusExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating addition

# Output:
# 35

# Program:

begin
  int x = 15 ;
  int y = 20 ;
  println x + y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
plusExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =15
22		STR r4, [sp, #4]
23		LDR r4, =20
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		ADDS r4, r4, r5
28		BLVS p_throw_overflow_error
29		MOV r0, r4
30		BL p_print_int
31		BL p_print_ln
32		ADD sp, sp, #8
33		LDR r0, =0
34		POP {pc}
35		.ltorg
36	p_throw_overflow_error:
37		LDR r0, =msg_0
38		BL p_throw_runtime_error
39	p_print_int:
40		PUSH {lr}
41		MOV r1, r0
42		LDR r0, =msg_1
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_2
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	p_throw_runtime_error:
57		BL p_print_string
58		MOV r0, #-1
59		BL exit
60	p_print_string:
61		PUSH {lr}
62		LDR r1, [r0]
63		ADD r2, r0, #4
64		LDR r0, =msg_3
65		ADD r0, r0, #4
66		BL printf
67		MOV r0, #0
68		BL fflush
69		POP {pc}
70	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/plusMinusExpr.wacc
-- Test: plusMinusExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# +- should be recognised as two separate symbols

# Output:
# -1

# Program:

begin
  println 1+-2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
plusMinusExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =-2
22		ADDS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_throw_overflow_error:
31		LDR r0, =msg_0
32		BL p_throw_runtime_error
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_2
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_3
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/plusNoWhitespaceExpr.wacc
-- Test: plusNoWhitespaceExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# addition expressions should not be whitespace sensitive

# Output:
# 3

# Program:

begin
  println 1+2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
plusNoWhitespaceExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =2
22		ADDS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_throw_overflow_error:
31		LDR r0, =msg_0
32		BL p_throw_runtime_error
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_2
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_3
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/plusPlusExpr.wacc
-- Test: plusPlusExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# ++ should be recognised as two separate symbols

# Output:
# 3

# Program:

begin
  println 1++2
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
plusPlusExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =1
21		LDR r5, =2
22		ADDS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_throw_overflow_error:
31		LDR r0, =msg_0
32		BL p_throw_runtime_error
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_2
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_3
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/sequentialCount.wacc
-- Test: sequentialCount.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple sequential counting

# Output:
# Can you count to 10?
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 10

# Program:

begin
  int i = 1 ;
  println "Can you count to 10?" ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i ;
  i = i + 1 ;
  println i 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
sequentialCount.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 20
4		.ascii	"Can you count to 10?"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 82
16		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =1
25		STR r4, [sp]
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		BL p_print_ln
30		LDR r4, [sp]
31		MOV r0, r4
32		BL p_print_int
33		BL p_print_ln
34		LDR r4, [sp]
35		LDR r5, =1
36		ADDS r4, r4, r5
37		BLVS p_throw_overflow_error
38		STR r4, [sp]
39		LDR r4, [sp]
40		MOV r0, r4
41		BL p_print_int
42		BL p_print_ln
43		LDR r4, [sp]
44		LDR r5, =1
45		ADDS r4, r4, r5
46		BLVS p_throw_overflow_error
47		STR r4, [sp]
48		LDR r4, [sp]
49		MOV r0, r4
50		BL p_print_int
51		BL p_print_ln
52		LDR r4, [sp]
53		LDR r5, =1
54		ADDS r4, r4, r5
55		BLVS p_throw_overflow_error
56		STR r4, [sp]
57		LDR r4, [sp]
58		MOV r0, r4
59		BL p_print_int
60		BL p_print_ln
61		LDR r4, [sp]
62		LDR r5, =1
63		ADDS r4, r4, r5
64		BLVS p_throw_overflow_error
65		STR r4, [sp]
66		LDR r4, [sp]
67		MOV r0, r4
68		BL p_print_int
69		BL p_print_ln
70		LDR r4, [sp]
71		LDR r5, =1
72		ADDS r4, r4, r5
73		BLVS p_throw_overflow_error
74		STR r4, [sp]
75		LDR r4, [sp]
76		MOV r0, r4
77		BL p_print_int
78		BL p_print_ln
79		LDR r4, [sp]
80		LDR r5, =1
81		ADDS r4, r4, r5
82		BLVS p_throw_overflow_error
83		STR r4, [sp]
84		LDR r4, [sp]
85		MOV r0, r4
86		BL p_print_int
87		BL p_print_ln
88		LDR r4, [sp]
89		LDR r5, =1
90		ADDS r4, r4, r5
91		BLVS p_throw_overflow_error
92		STR r4, [sp]
93		LDR r4, [sp]
94		MOV r0, r4
95		BL p_print_int
96		BL p_print_ln
97		LDR r4, [sp]
98		LDR r5, =1
99		ADDS r4, r4, r5
100		BLVS p_throw_overflow_error
101		STR r4, [sp]
102		LDR r4, [sp]
103		MOV r0, r4
104		BL p_print_int
105		BL p_print_ln
106		LDR r4, [sp]
107		LDR r5, =1
108		ADDS r4, r4, r5
109		BLVS p_throw_overflow_error
110		STR r4, [sp]
111		LDR r4, [sp]
112		MOV r0, r4
113		BL p_print_int
114		BL p_print_ln
115		ADD sp, sp, #4
116		LDR r0, =0
117		POP {pc}
118		.ltorg
119	p_print_string:
120		PUSH {lr}
121		LDR r1, [r0]
122		ADD r2, r0, #4
123		LDR r0, =msg_1
124		ADD r0, r0, #4
125		BL printf
126		MOV r0, #0
127		BL fflush
128		POP {pc}
129	p_print_ln:
130		PUSH {lr}
131		LDR r0, =msg_2
132		ADD r0, r0, #4
133		BL puts
134		MOV r0, #0
135		BL fflush
136		POP {pc}
137	p_print_int:
138		PUSH {lr}
139		MOV r1, r0
140		LDR r0, =msg_3
141		ADD r0, r0, #4
142		BL printf
143		MOV r0, #0
144		BL fflush
145		POP {pc}
146	p_throw_overflow_error:
147		LDR r0, =msg_4
148		BL p_throw_runtime_error
149	p_throw_runtime_error:
150		BL p_print_string
151		MOV r0, #-1
152		BL exit
153	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/expressions/stringEqualsExpr.wacc
-- Test: stringEqualsExpr.wacc

-- Uploaded file: 
---------------------------------------------------------------
# evaluating string equality

# Output:
# true
# false
# false

# Program:

begin
  string s1 = "Hello" ;
  string s2 = "foo" ;
  string s3 = "foo" ;
  bool b = s1 == s1 ;
  println b ;
  println s1 == s2 ;
  println s2 == s3
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
stringEqualsExpr.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"Hello"
5	msg_1:
6		.word 3
7		.ascii	"foo"
8	msg_2:
9		.word 3
10		.ascii	"foo"
11	msg_3:
12		.word 5
13		.ascii	"true\0"
14	msg_4:
15		.word 6
16		.ascii	"false\0"
17	msg_5:
18		.word 1
19		.ascii	"\0"
20	
21	.text
22	
23	.global main
24	main:
25		PUSH {lr}
26		SUB sp, sp, #13
27		LDR r4, =msg_0
28		STR r4, [sp, #9]
29		LDR r4, =msg_1
30		STR r4, [sp, #5]
31		LDR r4, =msg_2
32		STR r4, [sp, #1]
33		LDR r4, [sp, #9]
34		LDR r5, [sp, #9]
35		CMP r4, r5
36		MOVEQ r4, #1
37		MOVNE r4, #0
38		STRB r4, [sp]
39		LDRSB r4, [sp]
40		MOV r0, r4
41		BL p_print_bool
42		BL p_print_ln
43		LDR r4, [sp, #9]
44		LDR r5, [sp, #5]
45		CMP r4, r5
46		MOVEQ r4, #1
47		MOVNE r4, #0
48		MOV r0, r4
49		BL p_print_bool
50		BL p_print_ln
51		LDR r4, [sp, #5]
52		LDR r5, [sp, #1]
53		CMP r4, r5
54		MOVEQ r4, #1
55		MOVNE r4, #0
56		MOV r0, r4
57		BL p_print_bool
58		BL p_print_ln
59		ADD sp, sp, #13
60		LDR r0, =0
61		POP {pc}
62		.ltorg
63	p_print_bool:
64		PUSH {lr}
65		CMP r0, #0
66		LDRNE r0, =msg_3
67		LDREQ r0, =msg_4
68		ADD r0, r0, #4
69		BL printf
70		MOV r0, #0
71		BL fflush
72		POP {pc}
73	p_print_ln:
74		PUSH {lr}
75		LDR r0, =msg_5
76		ADD r0, r0, #4
77		BL puts
78		MOV r0, #0
79		BL fflush
80		POP {pc}
81	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/fibonacciFullRec.wacc
-- Test: fibonacciFullRec.wacc

-- Uploaded file: 
---------------------------------------------------------------
# recursively calculate the nth fibonacci number

# Output:
# This program calculates the nth fibonacci number recursively.
# Please enter n (should not be too large): #input#
# The input n is #output#
# The nth fibonacci number is #output#

# Program:

begin
  int fibonacci(int n) is
    if n <= 1
    then
      return n
    else
      skip
    fi ;
    int f1 = call fibonacci(n - 1) ;
    int f2 = call fibonacci(n - 2) ;
    return f1 + f2
  end

  println "This program calculates the nth fibonacci number recursively." ;
  print "Please enter n (should not be too large): " ;
  int n = 0;
  read n ;
  print "The input n is " ;
  println n ;
  print "The nth fibonacci number is " ;
  int result = call fibonacci(n) ;
  println  result
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
fibonacciFullRec.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 61
4		.ascii	"This program calculates the nth fibonacci number recursively."
5	msg_1:
6		.word 42
7		.ascii	"Please enter n (should not be too large): "
8	msg_2:
9		.word 15
10		.ascii	"The input n is "
11	msg_3:
12		.word 28
13		.ascii	"The nth fibonacci number is "
14	msg_4:
15		.word 82
16		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
17	msg_5:
18		.word 5
19		.ascii	"%.*s\0"
20	msg_6:
21		.word 1
22		.ascii	"\0"
23	msg_7:
24		.word 3
25		.ascii	"%d\0"
26	msg_8:
27		.word 3
28		.ascii	"%d\0"
29	
30	.text
31	
32	.global main
33	f_fibonacci:
34		PUSH {lr}
35		SUB sp, sp, #8
36		LDR r4, [sp, #12]
37		LDR r5, =1
38		CMP r4, r5
39		MOVLE r4, #1
40		MOVGT r4, #0
41		CMP r4, #0
42		BEQ L0
43		LDR r4, [sp, #12]
44		MOV r0, r4
45		ADD sp, sp, #8
46		POP {pc}
47		B L1
48	L0:
49	L1:
50		LDR r4, [sp, #12]
51		LDR r5, =1
52		SUBS r4, r4, r5
53		BLVS p_throw_overflow_error
54		STR r4, [sp, #-4]!
55		BL f_fibonacci
56		ADD sp, sp, #4
57		MOV r4, r0
58		STR r4, [sp, #4]
59		LDR r4, [sp, #12]
60		LDR r5, =2
61		SUBS r4, r4, r5
62		BLVS p_throw_overflow_error
63		STR r4, [sp, #-4]!
64		BL f_fibonacci
65		ADD sp, sp, #4
66		MOV r4, r0
67		STR r4, [sp]
68		LDR r4, [sp, #4]
69		LDR r5, [sp]
70		ADDS r4, r4, r5
71		BLVS p_throw_overflow_error
72		MOV r0, r4
73		ADD sp, sp, #8
74		POP {pc}
75		POP {pc}
76		.ltorg
77	main:
78		PUSH {lr}
79		SUB sp, sp, #8
80		LDR r4, =msg_0
81		MOV r0, r4
82		BL p_print_string
83		BL p_print_ln
84		LDR r4, =msg_1
85		MOV r0, r4
86		BL p_print_string
87		LDR r4, =0
88		STR r4, [sp, #4]
89		ADD r4, sp, #4
90		MOV r0, r4
91		BL p_read_int
92		LDR r4, =msg_2
93		MOV r0, r4
94		BL p_print_string
95		LDR r4, [sp, #4]
96		MOV r0, r4
97		BL p_print_int
98		BL p_print_ln
99		LDR r4, =msg_3
100		MOV r0, r4
101		BL p_print_string
102		LDR r4, [sp, #4]
103		STR r4, [sp, #-4]!
104		BL f_fibonacci
105		ADD sp, sp, #4
106		MOV r4, r0
107		STR r4, [sp]
108		LDR r4, [sp]
109		MOV r0, r4
110		BL p_print_int
111		BL p_print_ln
112		ADD sp, sp, #8
113		LDR r0, =0
114		POP {pc}
115		.ltorg
116	p_throw_overflow_error:
117		LDR r0, =msg_4
118		BL p_throw_runtime_error
119	p_print_string:
120		PUSH {lr}
121		LDR r1, [r0]
122		ADD r2, r0, #4
123		LDR r0, =msg_5
124		ADD r0, r0, #4
125		BL printf
126		MOV r0, #0
127		BL fflush
128		POP {pc}
129	p_print_ln:
130		PUSH {lr}
131		LDR r0, =msg_6
132		ADD r0, r0, #4
133		BL puts
134		MOV r0, #0
135		BL fflush
136		POP {pc}
137	p_read_int:
138		PUSH {lr}
139		MOV r1, r0
140		LDR r0, =msg_7
141		ADD r0, r0, #4
142		BL scanf
143		POP {pc}
144	p_print_int:
145		PUSH {lr}
146		MOV r1, r0
147		LDR r0, =msg_8
148		ADD r0, r0, #4
149		BL printf
150		MOV r0, #0
151		BL fflush
152		POP {pc}
153	p_throw_runtime_error:
154		BL p_print_string
155		MOV r0, #-1
156		BL exit
157	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/fibonacciRecursive.wacc
-- Test: fibonacciRecursive.wacc

-- Uploaded file: 
---------------------------------------------------------------
# recursive calculation of the first 20 fibonacci numbers

# Output:
# The first 20 fibonacci numbers are:
# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181...

# Program:

begin
  int fibonacci(int n, bool toPrint) is
    if n <= 1
    then
      return n
    else
      skip
    fi ;
    int f1 = call fibonacci(n - 1, toPrint) ;
    if toPrint
    then
      print f1 ;
      print ", "
    else
      skip
    fi ;
    int f2 = call fibonacci(n - 2, false) ;
    return f1 + f2
  end

  println "The first 20 fibonacci numbers are:" ;
  print "0, " ;
  int result = call fibonacci(19, true) ;
  print result ;
  println "..."
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
fibonacciRecursive.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 2
4		.ascii	", "
5	msg_1:
6		.word 35
7		.ascii	"The first 20 fibonacci numbers are:"
8	msg_2:
9		.word 3
10		.ascii	"0, "
11	msg_3:
12		.word 3
13		.ascii	"..."
14	msg_4:
15		.word 82
16		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 5
22		.ascii	"%.*s\0"
23	msg_7:
24		.word 1
25		.ascii	"\0"
26	
27	.text
28	
29	.global main
30	f_fibonacci:
31		PUSH {lr}
32		SUB sp, sp, #8
33		LDR r4, [sp, #12]
34		LDR r5, =1
35		CMP r4, r5
36		MOVLE r4, #1
37		MOVGT r4, #0
38		CMP r4, #0
39		BEQ L0
40		LDR r4, [sp, #12]
41		MOV r0, r4
42		ADD sp, sp, #8
43		POP {pc}
44		B L1
45	L0:
46	L1:
47		LDRSB r4, [sp, #16]
48		STRB r4, [sp, #-1]!
49		LDR r4, [sp, #13]
50		LDR r5, =1
51		SUBS r4, r4, r5
52		BLVS p_throw_overflow_error
53		STR r4, [sp, #-4]!
54		BL f_fibonacci
55		ADD sp, sp, #5
56		MOV r4, r0
57		STR r4, [sp, #4]
58		LDRSB r4, [sp, #16]
59		CMP r4, #0
60		BEQ L2
61		LDR r4, [sp, #4]
62		MOV r0, r4
63		BL p_print_int
64		LDR r4, =msg_0
65		MOV r0, r4
66		BL p_print_string
67		B L3
68	L2:
69	L3:
70		MOV r4, #0
71		STRB r4, [sp, #-1]!
72		LDR r4, [sp, #13]
73		LDR r5, =2
74		SUBS r4, r4, r5
75		BLVS p_throw_overflow_error
76		STR r4, [sp, #-4]!
77		BL f_fibonacci
78		ADD sp, sp, #5
79		MOV r4, r0
80		STR r4, [sp]
81		LDR r4, [sp, #4]
82		LDR r5, [sp]
83		ADDS r4, r4, r5
84		BLVS p_throw_overflow_error
85		MOV r0, r4
86		ADD sp, sp, #8
87		POP {pc}
88		POP {pc}
89		.ltorg
90	main:
91		PUSH {lr}
92		SUB sp, sp, #4
93		LDR r4, =msg_1
94		MOV r0, r4
95		BL p_print_string
96		BL p_print_ln
97		LDR r4, =msg_2
98		MOV r0, r4
99		BL p_print_string
100		MOV r4, #1
101		STRB r4, [sp, #-1]!
102		LDR r4, =19
103		STR r4, [sp, #-4]!
104		BL f_fibonacci
105		ADD sp, sp, #5
106		MOV r4, r0
107		STR r4, [sp]
108		LDR r4, [sp]
109		MOV r0, r4
110		BL p_print_int
111		LDR r4, =msg_3
112		MOV r0, r4
113		BL p_print_string
114		BL p_print_ln
115		ADD sp, sp, #4
116		LDR r0, =0
117		POP {pc}
118		.ltorg
119	p_throw_overflow_error:
120		LDR r0, =msg_4
121		BL p_throw_runtime_error
122	p_print_int:
123		PUSH {lr}
124		MOV r1, r0
125		LDR r0, =msg_5
126		ADD r0, r0, #4
127		BL printf
128		MOV r0, #0
129		BL fflush
130		POP {pc}
131	p_print_string:
132		PUSH {lr}
133		LDR r1, [r0]
134		ADD r2, r0, #4
135		LDR r0, =msg_6
136		ADD r0, r0, #4
137		BL printf
138		MOV r0, #0
139		BL fflush
140		POP {pc}
141	p_print_ln:
142		PUSH {lr}
143		LDR r0, =msg_7
144		ADD r0, r0, #4
145		BL puts
146		MOV r0, #0
147		BL fflush
148		POP {pc}
149	p_throw_runtime_error:
150		BL p_print_string
151		MOV r0, #-1
152		BL exit
153	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/fixedPointRealArithmetic.wacc
-- Test: fixedPointRealArithmetic.wacc

-- Uploaded file: 
---------------------------------------------------------------
# This program implements floating-point type using integers.
# The details about how it is done can found here: 
# http://www.cse.iitd.ernet.in/~sbansal/csl373/pintos/doc/pintos_7.html#SEC135
# 
# Basically, our integer have 32 bits. We use the first bit for sign, the next 
# 17 bits for value above the decimal digit and the last 14 bits for the values 
# after the decimal digits.
# 
# We call the number 17 above p, and the number 14 above q.
# We have f = 2**q. 
# 

begin
	# Returns the number of bits behind the decimal points.
	int q() is
		return 14
	end
	
	# Because we do not have bitwise shit in the language, we have to calculate it manually.
	int power(int base, int amount) is
		int result = 1 ;
		while amount > 0 do
			result = result * base ;
			amount = amount - 1
		done ;
		return result
	end
	
	int f() is
		int qq = call q() ;
		# f = 2**q
		int f = call power(2, qq) ;
		return f
	end
	
	# The implementation of the following functions are translated from the URI above.
	# Arguments start with 'x' have type fixed-point. Those start with 'n' have type integer.
	
	int intToFixedPoint(int n) is
		int ff = call f() ;
		return n * ff
	end
	
	int fixedPointToIntRoundDown(int x) is
		int ff = call f() ;
		return x / ff
	end

	int fixedPointToIntRoundNear(int x) is
		int ff = call f() ;
		if x >= 0
		then
			return (x + ff / 2) / ff 
		else
			return (x - ff / 2) / ff
		fi
	end

	int add(int x1, int x2) is 
		return x1 + x2
	end
	
	int subtract(int x1, int x2) is
		return x1 - x2
	end
	
	int addByInt(int x, int n) is
		int ff = call f() ;
		return x + n * ff
	end

	int subtractByInt(int x, int n) is
		int ff = call f() ;
		return x - n * ff
	end

	int multiply(int x1, int x2) is
		# We don't have int_64 in our language so we just ignore the overflow
		int ff = call f() ;
		return x1 * x2 / ff 
	end

	int multiplyByInt(int x, int n) is
		return x * n
	end
	
	int divide(int x1, int x2) is
		# We don't have int_64 in our language so we just ignore the overflow
		int ff = call f() ;
		return x1 * ff / x2
	end

	int divideByInt(int x, int n) is
		return x / n
	end

	# Main function
	int n1 = 10 ;
	int n2 = 3 ;
	
	print "Using fixed-point real: " ;
	print n1 ;
	print " / " ;
	print n2 ;
	print " * " ;
	print n2 ;
	print " = " ;
	
	int x = call intToFixedPoint(n1) ;
	x = call divideByInt(x, n2) ;
	x = call multiplyByInt(x, n2) ;
	int result = call fixedPointToIntRoundNear(x) ;
	println result 
end



---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
fixedPointRealArithmetic.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 24
4		.ascii	"Using fixed-point real: "
5	msg_1:
6		.word 3
7		.ascii	" / "
8	msg_2:
9		.word 3
10		.ascii	" * "
11	msg_3:
12		.word 3
13		.ascii	" = "
14	msg_4:
15		.word 82
16		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
17	msg_5:
18		.word 45
19		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
20	msg_6:
21		.word 5
22		.ascii	"%.*s\0"
23	msg_7:
24		.word 3
25		.ascii	"%d\0"
26	msg_8:
27		.word 1
28		.ascii	"\0"
29	
30	.text
31	
32	.global main
33	f_q:
34		PUSH {lr}
35		LDR r4, =14
36		MOV r0, r4
37		POP {pc}
38		POP {pc}
39		.ltorg
40	f_power:
41		PUSH {lr}
42		SUB sp, sp, #4
43		LDR r4, =1
44		STR r4, [sp]
45		B L0
46	L1:
47		LDR r4, [sp]
48		LDR r5, [sp, #8]
49		SMULL r4, r5, r4, r5
50		CMP r5, r4, ASR #31
51		BLNE p_throw_overflow_error
52		STR r4, [sp]
53		LDR r4, [sp, #12]
54		LDR r5, =1
55		SUBS r4, r4, r5
56		BLVS p_throw_overflow_error
57		STR r4, [sp, #12]
58	L0:
59		LDR r4, [sp, #12]
60		LDR r5, =0
61		CMP r4, r5
62		MOVGT r4, #1
63		MOVLE r4, #0
64		CMP r4, #1
65		BEQ L1
66		LDR r4, [sp]
67		MOV r0, r4
68		ADD sp, sp, #4
69		POP {pc}
70		POP {pc}
71		.ltorg
72	f_f:
73		PUSH {lr}
74		SUB sp, sp, #8
75		BL f_q
76		MOV r4, r0
77		STR r4, [sp, #4]
78		LDR r4, [sp, #4]
79		STR r4, [sp, #-4]!
80		LDR r4, =2
81		STR r4, [sp, #-4]!
82		BL f_power
83		ADD sp, sp, #8
84		MOV r4, r0
85		STR r4, [sp]
86		LDR r4, [sp]
87		MOV r0, r4
88		ADD sp, sp, #8
89		POP {pc}
90		POP {pc}
91		.ltorg
92	f_intToFixedPoint:
93		PUSH {lr}
94		SUB sp, sp, #4
95		BL f_f
96		MOV r4, r0
97		STR r4, [sp]
98		LDR r4, [sp, #8]
99		LDR r5, [sp]
100		SMULL r4, r5, r4, r5
101		CMP r5, r4, ASR #31
102		BLNE p_throw_overflow_error
103		MOV r0, r4
104		ADD sp, sp, #4
105		POP {pc}
106		POP {pc}
107		.ltorg
108	f_fixedPointToIntRoundDown:
109		PUSH {lr}
110		SUB sp, sp, #4
111		BL f_f
112		MOV r4, r0
113		STR r4, [sp]
114		LDR r4, [sp, #8]
115		LDR r5, [sp]
116		MOV r0, r4
117		MOV r1, r5
118		BL p_check_divide_by_zero
119		BL __aeabi_idiv
120		MOV r4, r0
121		MOV r0, r4
122		ADD sp, sp, #4
123		POP {pc}
124		POP {pc}
125		.ltorg
126	f_fixedPointToIntRoundNear:
127		PUSH {lr}
128		SUB sp, sp, #4
129		BL f_f
130		MOV r4, r0
131		STR r4, [sp]
132		LDR r4, [sp, #8]
133		LDR r5, =0
134		CMP r4, r5
135		MOVGE r4, #1
136		MOVLT r4, #0
137		CMP r4, #0
138		BEQ L2
139		LDR r4, [sp, #8]
140		LDR r5, [sp]
141		LDR r6, =2
142		MOV r0, r5
143		MOV r1, r6
144		BL p_check_divide_by_zero
145		BL __aeabi_idiv
146		MOV r5, r0
147		ADDS r4, r4, r5
148		BLVS p_throw_overflow_error
149		LDR r5, [sp]
150		MOV r0, r4
151		MOV r1, r5
152		BL p_check_divide_by_zero
153		BL __aeabi_idiv
154		MOV r4, r0
155		MOV r0, r4
156		ADD sp, sp, #4
157		POP {pc}
158		B L3
159	L2:
160		LDR r4, [sp, #8]
161		LDR r5, [sp]
162		LDR r6, =2
163		MOV r0, r5
164		MOV r1, r6
165		BL p_check_divide_by_zero
166		BL __aeabi_idiv
167		MOV r5, r0
168		SUBS r4, r4, r5
169		BLVS p_throw_overflow_error
170		LDR r5, [sp]
171		MOV r0, r4
172		MOV r1, r5
173		BL p_check_divide_by_zero
174		BL __aeabi_idiv
175		MOV r4, r0
176		MOV r0, r4
177		ADD sp, sp, #4
178		POP {pc}
179	L3:
180		POP {pc}
181		.ltorg
182	f_add:
183		PUSH {lr}
184		LDR r4, [sp, #4]
185		LDR r5, [sp, #8]
186		ADDS r4, r4, r5
187		BLVS p_throw_overflow_error
188		MOV r0, r4
189		POP {pc}
190		POP {pc}
191		.ltorg
192	f_subtract:
193		PUSH {lr}
194		LDR r4, [sp, #4]
195		LDR r5, [sp, #8]
196		SUBS r4, r4, r5
197		BLVS p_throw_overflow_error
198		MOV r0, r4
199		POP {pc}
200		POP {pc}
201		.ltorg
202	f_addByInt:
203		PUSH {lr}
204		SUB sp, sp, #4
205		BL f_f
206		MOV r4, r0
207		STR r4, [sp]
208		LDR r4, [sp, #8]
209		LDR r5, [sp, #12]
210		LDR r6, [sp]
211		SMULL r5, r6, r5, r6
212		CMP r6, r5, ASR #31
213		BLNE p_throw_overflow_error
214		ADDS r4, r4, r5
215		BLVS p_throw_overflow_error
216		MOV r0, r4
217		ADD sp, sp, #4
218		POP {pc}
219		POP {pc}
220		.ltorg
221	f_subtractByInt:
222		PUSH {lr}
223		SUB sp, sp, #4
224		BL f_f
225		MOV r4, r0
226		STR r4, [sp]
227		LDR r4, [sp, #8]
228		LDR r5, [sp, #12]
229		LDR r6, [sp]
230		SMULL r5, r6, r5, r6
231		CMP r6, r5, ASR #31
232		BLNE p_throw_overflow_error
233		SUBS r4, r4, r5
234		BLVS p_throw_overflow_error
235		MOV r0, r4
236		ADD sp, sp, #4
237		POP {pc}
238		POP {pc}
239		.ltorg
240	f_multiply:
241		PUSH {lr}
242		SUB sp, sp, #4
243		BL f_f
244		MOV r4, r0
245		STR r4, [sp]
246		LDR r4, [sp, #8]
247		LDR r5, [sp, #12]
248		SMULL r4, r5, r4, r5
249		CMP r5, r4, ASR #31
250		BLNE p_throw_overflow_error
251		LDR r5, [sp]
252		MOV r0, r4
253		MOV r1, r5
254		BL p_check_divide_by_zero
255		BL __aeabi_idiv
256		MOV r4, r0
257		MOV r0, r4
258		ADD sp, sp, #4
259		POP {pc}
260		POP {pc}
261		.ltorg
262	f_multiplyByInt:
263		PUSH {lr}
264		LDR r4, [sp, #4]
265		LDR r5, [sp, #8]
266		SMULL r4, r5, r4, r5
267		CMP r5, r4, ASR #31
268		BLNE p_throw_overflow_error
269		MOV r0, r4
270		POP {pc}
271		POP {pc}
272		.ltorg
273	f_divide:
274		PUSH {lr}
275		SUB sp, sp, #4
276		BL f_f
277		MOV r4, r0
278		STR r4, [sp]
279		LDR r4, [sp, #8]
280		LDR r5, [sp]
281		SMULL r4, r5, r4, r5
282		CMP r5, r4, ASR #31
283		BLNE p_throw_overflow_error
284		LDR r5, [sp, #12]
285		MOV r0, r4
286		MOV r1, r5
287		BL p_check_divide_by_zero
288		BL __aeabi_idiv
289		MOV r4, r0
290		MOV r0, r4
291		ADD sp, sp, #4
292		POP {pc}
293		POP {pc}
294		.ltorg
295	f_divideByInt:
296		PUSH {lr}
297		LDR r4, [sp, #4]
298		LDR r5, [sp, #8]
299		MOV r0, r4
300		MOV r1, r5
301		BL p_check_divide_by_zero
302		BL __aeabi_idiv
303		MOV r4, r0
304		MOV r0, r4
305		POP {pc}
306		POP {pc}
307		.ltorg
308	main:
309		PUSH {lr}
310		SUB sp, sp, #16
311		LDR r4, =10
312		STR r4, [sp, #12]
313		LDR r4, =3
314		STR r4, [sp, #8]
315		LDR r4, =msg_0
316		MOV r0, r4
317		BL p_print_string
318		LDR r4, [sp, #12]
319		MOV r0, r4
320		BL p_print_int
321		LDR r4, =msg_1
322		MOV r0, r4
323		BL p_print_string
324		LDR r4, [sp, #8]
325		MOV r0, r4
326		BL p_print_int
327		LDR r4, =msg_2
328		MOV r0, r4
329		BL p_print_string
330		LDR r4, [sp, #8]
331		MOV r0, r4
332		BL p_print_int
333		LDR r4, =msg_3
334		MOV r0, r4
335		BL p_print_string
336		LDR r4, [sp, #12]
337		STR r4, [sp, #-4]!
338		BL f_intToFixedPoint
339		ADD sp, sp, #4
340		MOV r4, r0
341		STR r4, [sp, #4]
342		LDR r4, [sp, #8]
343		STR r4, [sp, #-4]!
344		LDR r4, [sp, #8]
345		STR r4, [sp, #-4]!
346		BL f_divideByInt
347		ADD sp, sp, #8
348		MOV r4, r0
349		STR r4, [sp, #4]
350		LDR r4, [sp, #8]
351		STR r4, [sp, #-4]!
352		LDR r4, [sp, #8]
353		STR r4, [sp, #-4]!
354		BL f_multiplyByInt
355		ADD sp, sp, #8
356		MOV r4, r0
357		STR r4, [sp, #4]
358		LDR r4, [sp, #4]
359		STR r4, [sp, #-4]!
360		BL f_fixedPointToIntRoundNear
361		ADD sp, sp, #4
362		MOV r4, r0
363		STR r4, [sp]
364		LDR r4, [sp]
365		MOV r0, r4
366		BL p_print_int
367		BL p_print_ln
368		ADD sp, sp, #16
369		LDR r0, =0
370		POP {pc}
371		.ltorg
372	p_throw_overflow_error:
373		LDR r0, =msg_4
374		BL p_throw_runtime_error
375	p_check_divide_by_zero:
376		PUSH {lr}
377		CMP r1, #0
378		LDREQ r0, =msg_5
379		BLEQ p_throw_runtime_error
380		POP {pc}
381	p_print_string:
382		PUSH {lr}
383		LDR r1, [r0]
384		ADD r2, r0, #4
385		LDR r0, =msg_6
386		ADD r0, r0, #4
387		BL printf
388		MOV r0, #0
389		BL fflush
390		POP {pc}
391	p_print_int:
392		PUSH {lr}
393		MOV r1, r0
394		LDR r0, =msg_7
395		ADD r0, r0, #4
396		BL printf
397		MOV r0, #0
398		BL fflush
399		POP {pc}
400	p_print_ln:
401		PUSH {lr}
402		LDR r0, =msg_8
403		ADD r0, r0, #4
404		BL puts
405		MOV r0, #0
406		BL fflush
407		POP {pc}
408	p_throw_runtime_error:
409		BL p_print_string
410		MOV r0, #-1
411		BL exit
412	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/functionConditionalReturn.wacc
-- Test: functionConditionalReturn.wacc

-- Uploaded file: 
---------------------------------------------------------------
# program has function which only contains an if statement and a return in each branch

# Output:
# true

# Program:

begin
  bool f() is 
    if true then
      return true
    else
      return false
    fi
  end
  bool x = call f();
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionConditionalReturn.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	f_f:
16		PUSH {lr}
17		MOV r4, #1
18		CMP r4, #0
19		BEQ L0
20		MOV r4, #1
21		MOV r0, r4
22		POP {pc}
23		B L1
24	L0:
25		MOV r4, #0
26		MOV r0, r4
27		POP {pc}
28	L1:
29		POP {pc}
30		.ltorg
31	main:
32		PUSH {lr}
33		SUB sp, sp, #1
34		BL f_f
35		MOV r4, r0
36		STRB r4, [sp]
37		LDRSB r4, [sp]
38		MOV r0, r4
39		BL p_print_bool
40		BL p_print_ln
41		ADD sp, sp, #1
42		LDR r0, =0
43		POP {pc}
44		.ltorg
45	p_print_bool:
46		PUSH {lr}
47		CMP r0, #0
48		LDRNE r0, =msg_0
49		LDREQ r0, =msg_1
50		ADD r0, r0, #4
51		BL printf
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	p_print_ln:
56		PUSH {lr}
57		LDR r0, =msg_2
58		ADD r0, r0, #4
59		BL puts
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/mutualRecursion.wacc
-- Test: mutualRecursion.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a pair of mutually recursive functions

# Output:
# r1: sending 8
# r2: received 8
# r1: sending 7
# r2: received 7
# r1: sending 6
# r2: received 6
# r1: sending 5
# r2: received 5
# r1: sending 4
# r2: received 4
# r1: sending 3
# r2: received 3
# r1: sending 2
# r2: received 2
# r1: sending 1
# r2: received 1

# Program:

begin
  int r1(int x) is
    if x == 0 
    then
      skip
    else
      print "r1: sending " ;
      println x ;
      int y = call r2(x)
    fi ;
    return 42  
  end

  int r2(int y) is
    print "r2: received " ;
    println y ;
    int z = call r1(y - 1) ; 
    return 44
  end

  int x = 0 ;
  x = call r1(8)
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
mutualRecursion.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 12
4		.ascii	"r1: sending "
5	msg_1:
6		.word 13
7		.ascii	"r2: received "
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	msg_5:
18		.word 82
19		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
20	
21	.text
22	
23	.global main
24	f_r1:
25		PUSH {lr}
26		LDR r4, [sp, #4]
27		LDR r5, =0
28		CMP r4, r5
29		MOVEQ r4, #1
30		MOVNE r4, #0
31		CMP r4, #0
32		BEQ L0
33		B L1
34	L0:
35		SUB sp, sp, #4
36		LDR r4, =msg_0
37		MOV r0, r4
38		BL p_print_string
39		LDR r4, [sp, #8]
40		MOV r0, r4
41		BL p_print_int
42		BL p_print_ln
43		LDR r4, [sp, #8]
44		STR r4, [sp, #-4]!
45		BL f_r2
46		ADD sp, sp, #4
47		MOV r4, r0
48		STR r4, [sp]
49		ADD sp, sp, #4
50	L1:
51		LDR r4, =42
52		MOV r0, r4
53		POP {pc}
54		POP {pc}
55		.ltorg
56	f_r2:
57		PUSH {lr}
58		SUB sp, sp, #4
59		LDR r4, =msg_1
60		MOV r0, r4
61		BL p_print_string
62		LDR r4, [sp, #8]
63		MOV r0, r4
64		BL p_print_int
65		BL p_print_ln
66		LDR r4, [sp, #8]
67		LDR r5, =1
68		SUBS r4, r4, r5
69		BLVS p_throw_overflow_error
70		STR r4, [sp, #-4]!
71		BL f_r1
72		ADD sp, sp, #4
73		MOV r4, r0
74		STR r4, [sp]
75		LDR r4, =44
76		MOV r0, r4
77		ADD sp, sp, #4
78		POP {pc}
79		POP {pc}
80		.ltorg
81	main:
82		PUSH {lr}
83		SUB sp, sp, #4
84		LDR r4, =0
85		STR r4, [sp]
86		LDR r4, =8
87		STR r4, [sp, #-4]!
88		BL f_r1
89		ADD sp, sp, #4
90		MOV r4, r0
91		STR r4, [sp]
92		ADD sp, sp, #4
93		LDR r0, =0
94		POP {pc}
95		.ltorg
96	p_print_string:
97		PUSH {lr}
98		LDR r1, [r0]
99		ADD r2, r0, #4
100		LDR r0, =msg_2
101		ADD r0, r0, #4
102		BL printf
103		MOV r0, #0
104		BL fflush
105		POP {pc}
106	p_print_int:
107		PUSH {lr}
108		MOV r1, r0
109		LDR r0, =msg_3
110		ADD r0, r0, #4
111		BL printf
112		MOV r0, #0
113		BL fflush
114		POP {pc}
115	p_print_ln:
116		PUSH {lr}
117		LDR r0, =msg_4
118		ADD r0, r0, #4
119		BL puts
120		MOV r0, #0
121		BL fflush
122		POP {pc}
123	p_throw_overflow_error:
124		LDR r0, =msg_5
125		BL p_throw_runtime_error
126	p_throw_runtime_error:
127		BL p_print_string
128		MOV r0, #-1
129		BL exit
130	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/printInputTriangle.wacc
-- Test: printInputTriangle.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print a user-specified sized triangle

# Output:
# Please enter the size of the triangle to print:
# #input#
# #output#

# Program:

begin
  int f(int x) is
    if x == 0 then
      skip
    else
      int i = x ;
      while i > 0 do 
        print "-" ;
        i = i - 1
      done ;
      println "" ;
      int s = call f(x - 1)
    fi ;
    return 0
  end

  println "Please enter the size of the triangle to print: " ;
  int x = 0;

  read x;
  int s = call f(x) 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printInputTriangle.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 1
4		.ascii	"-"
5	msg_1:
6		.word 0
7		.ascii	""
8	msg_2:
9		.word 48
10		.ascii	"Please enter the size of the triangle to print: "
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	msg_4:
15		.word 82
16		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
17	msg_5:
18		.word 1
19		.ascii	"\0"
20	msg_6:
21		.word 3
22		.ascii	"%d\0"
23	
24	.text
25	
26	.global main
27	f_f:
28		PUSH {lr}
29		LDR r4, [sp, #4]
30		LDR r5, =0
31		CMP r4, r5
32		MOVEQ r4, #1
33		MOVNE r4, #0
34		CMP r4, #0
35		BEQ L0
36		B L1
37	L0:
38		SUB sp, sp, #8
39		LDR r4, [sp, #12]
40		STR r4, [sp, #4]
41		B L2
42	L3:
43		LDR r4, =msg_0
44		MOV r0, r4
45		BL p_print_string
46		LDR r4, [sp, #4]
47		LDR r5, =1
48		SUBS r4, r4, r5
49		BLVS p_throw_overflow_error
50		STR r4, [sp, #4]
51	L2:
52		LDR r4, [sp, #4]
53		LDR r5, =0
54		CMP r4, r5
55		MOVGT r4, #1
56		MOVLE r4, #0
57		CMP r4, #1
58		BEQ L3
59		LDR r4, =msg_1
60		MOV r0, r4
61		BL p_print_string
62		BL p_print_ln
63		LDR r4, [sp, #12]
64		LDR r5, =1
65		SUBS r4, r4, r5
66		BLVS p_throw_overflow_error
67		STR r4, [sp, #-4]!
68		BL f_f
69		ADD sp, sp, #4
70		MOV r4, r0
71		STR r4, [sp]
72		ADD sp, sp, #8
73	L1:
74		LDR r4, =0
75		MOV r0, r4
76		POP {pc}
77		POP {pc}
78		.ltorg
79	main:
80		PUSH {lr}
81		SUB sp, sp, #8
82		LDR r4, =msg_2
83		MOV r0, r4
84		BL p_print_string
85		BL p_print_ln
86		LDR r4, =0
87		STR r4, [sp, #4]
88		ADD r4, sp, #4
89		MOV r0, r4
90		BL p_read_int
91		LDR r4, [sp, #4]
92		STR r4, [sp, #-4]!
93		BL f_f
94		ADD sp, sp, #4
95		MOV r4, r0
96		STR r4, [sp]
97		ADD sp, sp, #8
98		LDR r0, =0
99		POP {pc}
100		.ltorg
101	p_print_string:
102		PUSH {lr}
103		LDR r1, [r0]
104		ADD r2, r0, #4
105		LDR r0, =msg_3
106		ADD r0, r0, #4
107		BL printf
108		MOV r0, #0
109		BL fflush
110		POP {pc}
111	p_throw_overflow_error:
112		LDR r0, =msg_4
113		BL p_throw_runtime_error
114	p_print_ln:
115		PUSH {lr}
116		LDR r0, =msg_5
117		ADD r0, r0, #4
118		BL puts
119		MOV r0, #0
120		BL fflush
121		POP {pc}
122	p_read_int:
123		PUSH {lr}
124		MOV r1, r0
125		LDR r0, =msg_6
126		ADD r0, r0, #4
127		BL scanf
128		POP {pc}
129	p_throw_runtime_error:
130		BL p_print_string
131		MOV r0, #-1
132		BL exit
133	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/printTriangle.wacc
-- Test: printTriangle.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print a fixed size triangle

# Output:
# --------
# -------
# ------
# -----
# ----
# ---
# --
# -

# Program:

begin
  int f(int x) is
    if x == 0 then
      skip
    else
      int i = x ;
      while i > 0 do 
        print "-" ;
        i = i - 1
      done ;
      println "" ;
      int s = call f(x - 1)
    fi ;
    return 0
  end

  int s = call f(8) 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printTriangle.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 1
4		.ascii	"-"
5	msg_1:
6		.word 0
7		.ascii	""
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 82
13		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	
18	.text
19	
20	.global main
21	f_f:
22		PUSH {lr}
23		LDR r4, [sp, #4]
24		LDR r5, =0
25		CMP r4, r5
26		MOVEQ r4, #1
27		MOVNE r4, #0
28		CMP r4, #0
29		BEQ L0
30		B L1
31	L0:
32		SUB sp, sp, #8
33		LDR r4, [sp, #12]
34		STR r4, [sp, #4]
35		B L2
36	L3:
37		LDR r4, =msg_0
38		MOV r0, r4
39		BL p_print_string
40		LDR r4, [sp, #4]
41		LDR r5, =1
42		SUBS r4, r4, r5
43		BLVS p_throw_overflow_error
44		STR r4, [sp, #4]
45	L2:
46		LDR r4, [sp, #4]
47		LDR r5, =0
48		CMP r4, r5
49		MOVGT r4, #1
50		MOVLE r4, #0
51		CMP r4, #1
52		BEQ L3
53		LDR r4, =msg_1
54		MOV r0, r4
55		BL p_print_string
56		BL p_print_ln
57		LDR r4, [sp, #12]
58		LDR r5, =1
59		SUBS r4, r4, r5
60		BLVS p_throw_overflow_error
61		STR r4, [sp, #-4]!
62		BL f_f
63		ADD sp, sp, #4
64		MOV r4, r0
65		STR r4, [sp]
66		ADD sp, sp, #8
67	L1:
68		LDR r4, =0
69		MOV r0, r4
70		POP {pc}
71		POP {pc}
72		.ltorg
73	main:
74		PUSH {lr}
75		SUB sp, sp, #4
76		LDR r4, =8
77		STR r4, [sp, #-4]!
78		BL f_f
79		ADD sp, sp, #4
80		MOV r4, r0
81		STR r4, [sp]
82		ADD sp, sp, #4
83		LDR r0, =0
84		POP {pc}
85		.ltorg
86	p_print_string:
87		PUSH {lr}
88		LDR r1, [r0]
89		ADD r2, r0, #4
90		LDR r0, =msg_2
91		ADD r0, r0, #4
92		BL printf
93		MOV r0, #0
94		BL fflush
95		POP {pc}
96	p_throw_overflow_error:
97		LDR r0, =msg_3
98		BL p_throw_runtime_error
99	p_print_ln:
100		PUSH {lr}
101		LDR r0, =msg_4
102		ADD r0, r0, #4
103		BL puts
104		MOV r0, #0
105		BL fflush
106		POP {pc}
107	p_throw_runtime_error:
108		BL p_print_string
109		MOV r0, #-1
110		BL exit
111	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/nested_functions/simpleRecursion.wacc
-- Test: simpleRecursion.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a simple recursive function

# Output:
# #empty#

# Program:

begin
  int rec(int x) is
    if x == 0 
    then
      skip
    else
      int y = call rec(x - 1)
    fi ;
    return 42  
  end

  int x = 0 ;
  x = call rec(8)
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
simpleRecursion.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	f_rec:
13		PUSH {lr}
14		LDR r4, [sp, #4]
15		LDR r5, =0
16		CMP r4, r5
17		MOVEQ r4, #1
18		MOVNE r4, #0
19		CMP r4, #0
20		BEQ L0
21		B L1
22	L0:
23		SUB sp, sp, #4
24		LDR r4, [sp, #8]
25		LDR r5, =1
26		SUBS r4, r4, r5
27		BLVS p_throw_overflow_error
28		STR r4, [sp, #-4]!
29		BL f_rec
30		ADD sp, sp, #4
31		MOV r4, r0
32		STR r4, [sp]
33		ADD sp, sp, #4
34	L1:
35		LDR r4, =42
36		MOV r0, r4
37		POP {pc}
38		POP {pc}
39		.ltorg
40	main:
41		PUSH {lr}
42		SUB sp, sp, #4
43		LDR r4, =0
44		STR r4, [sp]
45		LDR r4, =8
46		STR r4, [sp, #-4]!
47		BL f_rec
48		ADD sp, sp, #4
49		MOV r4, r0
50		STR r4, [sp]
51		ADD sp, sp, #4
52		LDR r0, =0
53		POP {pc}
54		.ltorg
55	p_throw_overflow_error:
56		LDR r0, =msg_0
57		BL p_throw_runtime_error
58	p_throw_runtime_error:
59		BL p_print_string
60		MOV r0, #-1
61		BL exit
62	p_print_string:
63		PUSH {lr}
64		LDR r1, [r0]
65		ADD r2, r0, #4
66		LDR r0, =msg_1
67		ADD r0, r0, #4
68		BL printf
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/asciiTable.wacc
-- Test: asciiTable.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print out a lookup table for ascii character representations

# Output:
# Asci character lookup table:
# -------------
# |   32 =    |
# |   33 = !  |
# |   34 = "  |
# |   35 = #  |
# |   36 = $  |
# |   37 = %  |
# |   38 = &  |
# |   39 = '  |
# |   40 = (  |
# |   41 = )  |
# |   42 = *  |
# |   43 = +  |
# |   44 = ,  |
# |   45 = -  |
# |   46 = .  |
# |   47 = /  |
# |   48 = 0  |
# |   49 = 1  |
# |   50 = 2  |
# |   51 = 3  |
# |   52 = 4  |
# |   53 = 5  |
# |   54 = 6  |
# |   55 = 7  |
# |   56 = 8  |
# |   57 = 9  |
# |   58 = :  |
# |   59 = ;  |
# |   60 = <  |
# |   61 = =  |
# |   62 = >  |
# |   63 = ?  |
# |   64 = @  |
# |   65 = A  |
# |   66 = B  |
# |   67 = C  |
# |   68 = D  |
# |   69 = E  |
# |   70 = F  |
# |   71 = G  |
# |   72 = H  |
# |   73 = I  |
# |   74 = J  |
# |   75 = K  |
# |   76 = L  |
# |   77 = M  |
# |   78 = N  |
# |   79 = O  |
# |   80 = P  |
# |   81 = Q  |
# |   82 = R  |
# |   83 = S  |
# |   84 = T  |
# |   85 = U  |
# |   86 = V  |
# |   87 = W  |
# |   88 = X  |
# |   89 = Y  |
# |   90 = Z  |
# |   91 = [  |
# |   92 = \  |
# |   93 = ]  |
# |   94 = ^  |
# |   95 = _  |
# |   96 = `  |
# |   97 = a  |
# |   98 = b  |
# |   99 = c  |
# |  100 = d  |
# |  101 = e  |
# |  102 = f  |
# |  103 = g  |
# |  104 = h  |
# |  105 = i  |
# |  106 = j  |
# |  107 = k  |
# |  108 = l  |
# |  109 = m  |
# |  110 = n  |
# |  111 = o  |
# |  112 = p  |
# |  113 = q  |
# |  114 = r  |
# |  115 = s  |
# |  116 = t  |
# |  117 = u  |
# |  118 = v  |
# |  119 = w  |
# |  120 = x  |
# |  121 = y  |
# |  122 = z  |
# |  123 = {  |
# |  124 = |  |
# |  125 = }  |
# |  126 = ~  |
# -------------


# Program:

begin
  bool printLine(int n) is
    int i = 0 ;
    while i < n do
      print "-" ;
      i = i + 1
    done ;
    println "" ;
    return true
  end

  bool printMap(int n) is
    print "|  " ;
    if n <100 then
      print " "
    else
      skip
    fi ;
    print n ;
    print " = " ;
    print chr n ;
    println "  |" ; 
    return true
  end

  println "Asci character lookup table:" ;
  bool r = call printLine(13) ;
  int num = ord ' ' ;
  while num < 127 do
    r = call printMap(num) ;
    num = num + 1
  done ;
  r = call printLine(13)
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
asciiTable.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 1
4		.ascii	"-"
5	msg_1:
6		.word 0
7		.ascii	""
8	msg_2:
9		.word 3
10		.ascii	"|  "
11	msg_3:
12		.word 1
13		.ascii	" "
14	msg_4:
15		.word 3
16		.ascii	" = "
17	msg_5:
18		.word 3
19		.ascii	"  |"
20	msg_6:
21		.word 28
22		.ascii	"Asci character lookup table:"
23	msg_7:
24		.word 5
25		.ascii	"%.*s\0"
26	msg_8:
27		.word 82
28		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
29	msg_9:
30		.word 1
31		.ascii	"\0"
32	msg_10:
33		.word 3
34		.ascii	"%d\0"
35	
36	.text
37	
38	.global main
39	f_printLine:
40		PUSH {lr}
41		SUB sp, sp, #4
42		LDR r4, =0
43		STR r4, [sp]
44		B L0
45	L1:
46		LDR r4, =msg_0
47		MOV r0, r4
48		BL p_print_string
49		LDR r4, [sp]
50		LDR r5, =1
51		ADDS r4, r4, r5
52		BLVS p_throw_overflow_error
53		STR r4, [sp]
54	L0:
55		LDR r4, [sp]
56		LDR r5, [sp, #8]
57		CMP r4, r5
58		MOVLT r4, #1
59		MOVGE r4, #0
60		CMP r4, #1
61		BEQ L1
62		LDR r4, =msg_1
63		MOV r0, r4
64		BL p_print_string
65		BL p_print_ln
66		MOV r4, #1
67		MOV r0, r4
68		ADD sp, sp, #4
69		POP {pc}
70		POP {pc}
71		.ltorg
72	f_printMap:
73		PUSH {lr}
74		LDR r4, =msg_2
75		MOV r0, r4
76		BL p_print_string
77		LDR r4, [sp, #4]
78		LDR r5, =100
79		CMP r4, r5
80		MOVLT r4, #1
81		MOVGE r4, #0
82		CMP r4, #0
83		BEQ L2
84		LDR r4, =msg_3
85		MOV r0, r4
86		BL p_print_string
87		B L3
88	L2:
89	L3:
90		LDR r4, [sp, #4]
91		MOV r0, r4
92		BL p_print_int
93		LDR r4, =msg_4
94		MOV r0, r4
95		BL p_print_string
96		LDR r4, [sp, #4]
97		MOV r0, r4
98		BL putchar
99		LDR r4, =msg_5
100		MOV r0, r4
101		BL p_print_string
102		BL p_print_ln
103		MOV r4, #1
104		MOV r0, r4
105		POP {pc}
106		POP {pc}
107		.ltorg
108	main:
109		PUSH {lr}
110		SUB sp, sp, #5
111		LDR r4, =msg_6
112		MOV r0, r4
113		BL p_print_string
114		BL p_print_ln
115		LDR r4, =13
116		STR r4, [sp, #-4]!
117		BL f_printLine
118		ADD sp, sp, #4
119		MOV r4, r0
120		STRB r4, [sp, #4]
121		MOV r4, #' '
122		STR r4, [sp]
123		B L4
124	L5:
125		LDR r4, [sp]
126		STR r4, [sp, #-4]!
127		BL f_printMap
128		ADD sp, sp, #4
129		MOV r4, r0
130		STRB r4, [sp, #4]
131		LDR r4, [sp]
132		LDR r5, =1
133		ADDS r4, r4, r5
134		BLVS p_throw_overflow_error
135		STR r4, [sp]
136	L4:
137		LDR r4, [sp]
138		LDR r5, =127
139		CMP r4, r5
140		MOVLT r4, #1
141		MOVGE r4, #0
142		CMP r4, #1
143		BEQ L5
144		LDR r4, =13
145		STR r4, [sp, #-4]!
146		BL f_printLine
147		ADD sp, sp, #4
148		MOV r4, r0
149		STRB r4, [sp, #4]
150		ADD sp, sp, #5
151		LDR r0, =0
152		POP {pc}
153		.ltorg
154	p_print_string:
155		PUSH {lr}
156		LDR r1, [r0]
157		ADD r2, r0, #4
158		LDR r0, =msg_7
159		ADD r0, r0, #4
160		BL printf
161		MOV r0, #0
162		BL fflush
163		POP {pc}
164	p_throw_overflow_error:
165		LDR r0, =msg_8
166		BL p_throw_runtime_error
167	p_print_ln:
168		PUSH {lr}
169		LDR r0, =msg_9
170		ADD r0, r0, #4
171		BL puts
172		MOV r0, #0
173		BL fflush
174		POP {pc}
175	p_print_int:
176		PUSH {lr}
177		MOV r1, r0
178		LDR r0, =msg_10
179		ADD r0, r0, #4
180		BL printf
181		MOV r0, #0
182		BL fflush
183		POP {pc}
184	p_throw_runtime_error:
185		BL p_print_string
186		MOV r0, #-1
187		BL exit
188	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/functionDeclaration.wacc
-- Test: functionDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a simple function is declared, but not called

# Output:
# #empty#

# Program:

begin
  int f() is
    return 0 
  end
  skip
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	f_f:
4		PUSH {lr}
5		LDR r4, =0
6		MOV r0, r4
7		POP {pc}
8		POP {pc}
9		.ltorg
10	main:
11		PUSH {lr}
12		LDR r0, =0
13		POP {pc}
14		.ltorg
15	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/functionManyArguments.wacc
-- Test: functionManyArguments.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a function with varied inputs

# Output:
# a is 42
# b is true
# c is u
# d is hello
# e is #addrs#
# f is #addrs#
# answer is g

# Program:

begin
  char doSomething(int a, bool b, char c, string d, bool[] e, int[] f) is
    print "a is " ;
    println a ;
    print "b is " ;
    println b ;
    print "c is " ;
    println c ;
    print "d is " ;
    println d ;
    print "e is " ;
    println e ;
    print "f is " ;
    println f ;
    return 'g'
  end
  bool[] bools = [ false, true ] ;
  int[] ints = [ 1, 2 ] ;
  char answer = call doSomething(42, true, 'u', "hello", bools, ints) ;
  print "answer is " ;
  println answer
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionManyArguments.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"a is "
5	msg_1:
6		.word 5
7		.ascii	"b is "
8	msg_2:
9		.word 5
10		.ascii	"c is "
11	msg_3:
12		.word 5
13		.ascii	"d is "
14	msg_4:
15		.word 5
16		.ascii	"e is "
17	msg_5:
18		.word 5
19		.ascii	"f is "
20	msg_6:
21		.word 5
22		.ascii	"hello"
23	msg_7:
24		.word 10
25		.ascii	"answer is "
26	msg_8:
27		.word 5
28		.ascii	"%.*s\0"
29	msg_9:
30		.word 3
31		.ascii	"%d\0"
32	msg_10:
33		.word 1
34		.ascii	"\0"
35	msg_11:
36		.word 5
37		.ascii	"true\0"
38	msg_12:
39		.word 6
40		.ascii	"false\0"
41	msg_13:
42		.word 3
43		.ascii	"%p\0"
44	
45	.text
46	
47	.global main
48	f_doSomething:
49		PUSH {lr}
50		LDR r4, =msg_0
51		MOV r0, r4
52		BL p_print_string
53		LDR r4, [sp, #4]
54		MOV r0, r4
55		BL p_print_int
56		BL p_print_ln
57		LDR r4, =msg_1
58		MOV r0, r4
59		BL p_print_string
60		LDRSB r4, [sp, #8]
61		MOV r0, r4
62		BL p_print_bool
63		BL p_print_ln
64		LDR r4, =msg_2
65		MOV r0, r4
66		BL p_print_string
67		LDRSB r4, [sp, #9]
68		MOV r0, r4
69		BL putchar
70		BL p_print_ln
71		LDR r4, =msg_3
72		MOV r0, r4
73		BL p_print_string
74		LDR r4, [sp, #10]
75		MOV r0, r4
76		BL p_print_string
77		BL p_print_ln
78		LDR r4, =msg_4
79		MOV r0, r4
80		BL p_print_string
81		LDR r4, [sp, #14]
82		MOV r0, r4
83		BL p_print_reference
84		BL p_print_ln
85		LDR r4, =msg_5
86		MOV r0, r4
87		BL p_print_string
88		LDR r4, [sp, #18]
89		MOV r0, r4
90		BL p_print_reference
91		BL p_print_ln
92		MOV r4, #'g'
93		MOV r0, r4
94		POP {pc}
95		POP {pc}
96		.ltorg
97	main:
98		PUSH {lr}
99		SUB sp, sp, #9
100		LDR r0, =6
101		BL malloc
102		MOV r4, r0
103		MOV r5, #0
104		STRB r5, [r4, #4]
105		MOV r5, #1
106		STRB r5, [r4, #5]
107		LDR r5, =2
108		STR r5, [r4]
109		STR r4, [sp, #5]
110		LDR r0, =12
111		BL malloc
112		MOV r4, r0
113		LDR r5, =1
114		STR r5, [r4, #4]
115		LDR r5, =2
116		STR r5, [r4, #8]
117		LDR r5, =2
118		STR r5, [r4]
119		STR r4, [sp, #1]
120		LDR r4, [sp, #1]
121		STR r4, [sp, #-4]!
122		LDR r4, [sp, #9]
123		STR r4, [sp, #-4]!
124		LDR r4, =msg_6
125		STR r4, [sp, #-4]!
126		MOV r4, #'u'
127		STRB r4, [sp, #-1]!
128		MOV r4, #1
129		STRB r4, [sp, #-1]!
130		LDR r4, =42
131		STR r4, [sp, #-4]!
132		BL f_doSomething
133		ADD sp, sp, #18
134		MOV r4, r0
135		STRB r4, [sp]
136		LDR r4, =msg_7
137		MOV r0, r4
138		BL p_print_string
139		LDRSB r4, [sp]
140		MOV r0, r4
141		BL putchar
142		BL p_print_ln
143		ADD sp, sp, #9
144		LDR r0, =0
145		POP {pc}
146		.ltorg
147	p_print_string:
148		PUSH {lr}
149		LDR r1, [r0]
150		ADD r2, r0, #4
151		LDR r0, =msg_8
152		ADD r0, r0, #4
153		BL printf
154		MOV r0, #0
155		BL fflush
156		POP {pc}
157	p_print_int:
158		PUSH {lr}
159		MOV r1, r0
160		LDR r0, =msg_9
161		ADD r0, r0, #4
162		BL printf
163		MOV r0, #0
164		BL fflush
165		POP {pc}
166	p_print_ln:
167		PUSH {lr}
168		LDR r0, =msg_10
169		ADD r0, r0, #4
170		BL puts
171		MOV r0, #0
172		BL fflush
173		POP {pc}
174	p_print_bool:
175		PUSH {lr}
176		CMP r0, #0
177		LDRNE r0, =msg_11
178		LDREQ r0, =msg_12
179		ADD r0, r0, #4
180		BL printf
181		MOV r0, #0
182		BL fflush
183		POP {pc}
184	p_print_reference:
185		PUSH {lr}
186		MOV r1, r0
187		LDR r0, =msg_13
188		ADD r0, r0, #4
189		BL printf
190		MOV r0, #0
191		BL fflush
192		POP {pc}
193	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/functionReturnPair.wacc
-- Test: functionReturnPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# creates a pair which is returned from a function

# Output:
# 10

# Program:

begin

  pair(int, int) getPair() is
    pair(int, int) p = newpair(10,15);
    return p
  end

  pair(int, int) p = call getPair();
  int x = fst p;
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionReturnPair.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	f_getPair:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r0, =8
22		BL malloc
23		MOV r4, r0
24		LDR r5, =10
25		LDR r0, =4
26		BL malloc
27		STR r5, [r0]
28		STR r0, [r4]
29		LDR r5, =15
30		LDR r0, =4
31		BL malloc
32		STR r5, [r0]
33		STR r0, [r4, #4]
34		STR r4, [sp]
35		LDR r4, [sp]
36		MOV r0, r4
37		ADD sp, sp, #4
38		POP {pc}
39		POP {pc}
40		.ltorg
41	main:
42		PUSH {lr}
43		SUB sp, sp, #8
44		BL f_getPair
45		MOV r4, r0
46		STR r4, [sp, #4]
47		LDR r4, [sp, #4]
48		MOV r0, r4
49		BL p_check_null_pointer
50		LDR r4, [r4]
51		LDR r4, [r4]
52		STR r4, [sp]
53		LDR r4, [sp]
54		MOV r0, r4
55		BL p_print_int
56		BL p_print_ln
57		ADD sp, sp, #8
58		LDR r0, =0
59		POP {pc}
60		.ltorg
61	p_check_null_pointer:
62		PUSH {lr}
63		CMP r0, #0
64		LDREQ r0, =msg_0
65		BLEQ p_throw_runtime_error
66		POP {pc}
67	p_print_int:
68		PUSH {lr}
69		MOV r1, r0
70		LDR r0, =msg_1
71		ADD r0, r0, #4
72		BL printf
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	p_print_ln:
77		PUSH {lr}
78		LDR r0, =msg_2
79		ADD r0, r0, #4
80		BL puts
81		MOV r0, #0
82		BL fflush
83		POP {pc}
84	p_throw_runtime_error:
85		BL p_print_string
86		MOV r0, #-1
87		BL exit
88	p_print_string:
89		PUSH {lr}
90		LDR r1, [r0]
91		ADD r2, r0, #4
92		LDR r0, =msg_3
93		ADD r0, r0, #4
94		BL printf
95		MOV r0, #0
96		BL fflush
97		POP {pc}
98	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/functionSimple.wacc
-- Test: functionSimple.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a simple function definition and call

# Output:
# 0

# Program:

begin
  int f() is
    return 0 
  end
  int x = call f() ;
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionSimple.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	f_f:
13		PUSH {lr}
14		LDR r4, =0
15		MOV r0, r4
16		POP {pc}
17		POP {pc}
18		.ltorg
19	main:
20		PUSH {lr}
21		SUB sp, sp, #4
22		BL f_f
23		MOV r4, r0
24		STR r4, [sp]
25		LDR r4, [sp]
26		MOV r0, r4
27		BL p_print_int
28		BL p_print_ln
29		ADD sp, sp, #4
30		LDR r0, =0
31		POP {pc}
32		.ltorg
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_0
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_1
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/functionSimpleLoop.wacc
-- Test: functionSimpleLoop.wacc

-- Uploaded file: 
---------------------------------------------------------------
# define and call a function with a simple loop

# Output:
# 10

# Program:

begin
  int f(int n) is
    int i = 0;
    while i < n do
      i = i + 1
    done;
    return i 
  end
  int x = call f(10) ;
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionSimpleLoop.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	f_f:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =0
22		STR r4, [sp]
23		B L0
24	L1:
25		LDR r4, [sp]
26		LDR r5, =1
27		ADDS r4, r4, r5
28		BLVS p_throw_overflow_error
29		STR r4, [sp]
30	L0:
31		LDR r4, [sp]
32		LDR r5, [sp, #8]
33		CMP r4, r5
34		MOVLT r4, #1
35		MOVGE r4, #0
36		CMP r4, #1
37		BEQ L1
38		LDR r4, [sp]
39		MOV r0, r4
40		ADD sp, sp, #4
41		POP {pc}
42		POP {pc}
43		.ltorg
44	main:
45		PUSH {lr}
46		SUB sp, sp, #4
47		LDR r4, =10
48		STR r4, [sp, #-4]!
49		BL f_f
50		ADD sp, sp, #4
51		MOV r4, r0
52		STR r4, [sp]
53		LDR r4, [sp]
54		MOV r0, r4
55		BL p_print_int
56		BL p_print_ln
57		ADD sp, sp, #4
58		LDR r0, =0
59		POP {pc}
60		.ltorg
61	p_throw_overflow_error:
62		LDR r0, =msg_0
63		BL p_throw_runtime_error
64	p_print_int:
65		PUSH {lr}
66		MOV r1, r0
67		LDR r0, =msg_1
68		ADD r0, r0, #4
69		BL printf
70		MOV r0, #0
71		BL fflush
72		POP {pc}
73	p_print_ln:
74		PUSH {lr}
75		LDR r0, =msg_2
76		ADD r0, r0, #4
77		BL puts
78		MOV r0, #0
79		BL fflush
80		POP {pc}
81	p_throw_runtime_error:
82		BL p_print_string
83		MOV r0, #-1
84		BL exit
85	p_print_string:
86		PUSH {lr}
87		LDR r1, [r0]
88		ADD r2, r0, #4
89		LDR r0, =msg_3
90		ADD r0, r0, #4
91		BL printf
92		MOV r0, #0
93		BL fflush
94		POP {pc}
95	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/functionUpdateParameter.wacc
-- Test: functionUpdateParameter.wacc

-- Uploaded file: 
---------------------------------------------------------------
# test that the passed parameter can be updated and used
# and that y remains the same

# Output:
# y is 1
# x is 1
# x is now 5
# y is still 1

# Program:

begin

  int f(int x) is
    print "x is ";
    println x;
    x = 5;
    print "x is now ";
    println x;
    return x
  end

  int y = 1;
  print "y is ";
  println y;
  int x = call f(y);
  print "y is still ";
  println y
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
functionUpdateParameter.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"x is "
5	msg_1:
6		.word 9
7		.ascii	"x is now "
8	msg_2:
9		.word 5
10		.ascii	"y is "
11	msg_3:
12		.word 11
13		.ascii	"y is still "
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 1
22		.ascii	"\0"
23	
24	.text
25	
26	.global main
27	f_f:
28		PUSH {lr}
29		LDR r4, =msg_0
30		MOV r0, r4
31		BL p_print_string
32		LDR r4, [sp, #4]
33		MOV r0, r4
34		BL p_print_int
35		BL p_print_ln
36		LDR r4, =5
37		STR r4, [sp, #4]
38		LDR r4, =msg_1
39		MOV r0, r4
40		BL p_print_string
41		LDR r4, [sp, #4]
42		MOV r0, r4
43		BL p_print_int
44		BL p_print_ln
45		LDR r4, [sp, #4]
46		MOV r0, r4
47		POP {pc}
48		POP {pc}
49		.ltorg
50	main:
51		PUSH {lr}
52		SUB sp, sp, #8
53		LDR r4, =1
54		STR r4, [sp, #4]
55		LDR r4, =msg_2
56		MOV r0, r4
57		BL p_print_string
58		LDR r4, [sp, #4]
59		MOV r0, r4
60		BL p_print_int
61		BL p_print_ln
62		LDR r4, [sp, #4]
63		STR r4, [sp, #-4]!
64		BL f_f
65		ADD sp, sp, #4
66		MOV r4, r0
67		STR r4, [sp]
68		LDR r4, =msg_3
69		MOV r0, r4
70		BL p_print_string
71		LDR r4, [sp, #4]
72		MOV r0, r4
73		BL p_print_int
74		BL p_print_ln
75		ADD sp, sp, #8
76		LDR r0, =0
77		POP {pc}
78		.ltorg
79	p_print_string:
80		PUSH {lr}
81		LDR r1, [r0]
82		ADD r2, r0, #4
83		LDR r0, =msg_4
84		ADD r0, r0, #4
85		BL printf
86		MOV r0, #0
87		BL fflush
88		POP {pc}
89	p_print_int:
90		PUSH {lr}
91		MOV r1, r0
92		LDR r0, =msg_5
93		ADD r0, r0, #4
94		BL printf
95		MOV r0, #0
96		BL fflush
97		POP {pc}
98	p_print_ln:
99		PUSH {lr}
100		LDR r0, =msg_6
101		ADD r0, r0, #4
102		BL puts
103		MOV r0, #0
104		BL fflush
105		POP {pc}
106	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/incFunction.wacc
-- Test: incFunction.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a simple increment function definition and usage

# Output:
# 1
# 4

# Program:

begin
  int inc(int x) is
    return x + 1
  end
  int x = 0 ;
  x = call inc(x) ;
  println x ;
  x = call inc(x) ;
  x = call inc(x) ;
  x = call inc(x) ;
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
incFunction.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 82
4		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	f_inc:
19		PUSH {lr}
20		LDR r4, [sp, #4]
21		LDR r5, =1
22		ADDS r4, r4, r5
23		BLVS p_throw_overflow_error
24		MOV r0, r4
25		POP {pc}
26		POP {pc}
27		.ltorg
28	main:
29		PUSH {lr}
30		SUB sp, sp, #4
31		LDR r4, =0
32		STR r4, [sp]
33		LDR r4, [sp]
34		STR r4, [sp, #-4]!
35		BL f_inc
36		ADD sp, sp, #4
37		MOV r4, r0
38		STR r4, [sp]
39		LDR r4, [sp]
40		MOV r0, r4
41		BL p_print_int
42		BL p_print_ln
43		LDR r4, [sp]
44		STR r4, [sp, #-4]!
45		BL f_inc
46		ADD sp, sp, #4
47		MOV r4, r0
48		STR r4, [sp]
49		LDR r4, [sp]
50		STR r4, [sp, #-4]!
51		BL f_inc
52		ADD sp, sp, #4
53		MOV r4, r0
54		STR r4, [sp]
55		LDR r4, [sp]
56		STR r4, [sp, #-4]!
57		BL f_inc
58		ADD sp, sp, #4
59		MOV r4, r0
60		STR r4, [sp]
61		LDR r4, [sp]
62		MOV r0, r4
63		BL p_print_int
64		BL p_print_ln
65		ADD sp, sp, #4
66		LDR r0, =0
67		POP {pc}
68		.ltorg
69	p_throw_overflow_error:
70		LDR r0, =msg_0
71		BL p_throw_runtime_error
72	p_print_int:
73		PUSH {lr}
74		MOV r1, r0
75		LDR r0, =msg_1
76		ADD r0, r0, #4
77		BL printf
78		MOV r0, #0
79		BL fflush
80		POP {pc}
81	p_print_ln:
82		PUSH {lr}
83		LDR r0, =msg_2
84		ADD r0, r0, #4
85		BL puts
86		MOV r0, #0
87		BL fflush
88		POP {pc}
89	p_throw_runtime_error:
90		BL p_print_string
91		MOV r0, #-1
92		BL exit
93	p_print_string:
94		PUSH {lr}
95		LDR r1, [r0]
96		ADD r2, r0, #4
97		LDR r0, =msg_3
98		ADD r0, r0, #4
99		BL printf
100		MOV r0, #0
101		BL fflush
102		POP {pc}
103	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/negFunction.wacc
-- Test: negFunction.wacc

-- Uploaded file: 
---------------------------------------------------------------
# a simple negation function definition and usage

# Output:
# true
# false
# true

# Program:

begin
  bool neg(bool b) is
    return !b 
  end
  bool b = true ;
  println b ;
  b = call neg(b) ;
  println b ;
  b = call neg(b) ;
  b = call neg(b) ;
  b = call neg(b) ;
  println b
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negFunction.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	f_neg:
16		PUSH {lr}
17		LDRSB r4, [sp, #4]
18		EOR r4, r4, #1
19		MOV r0, r4
20		POP {pc}
21		POP {pc}
22		.ltorg
23	main:
24		PUSH {lr}
25		SUB sp, sp, #1
26		MOV r4, #1
27		STRB r4, [sp]
28		LDRSB r4, [sp]
29		MOV r0, r4
30		BL p_print_bool
31		BL p_print_ln
32		LDRSB r4, [sp]
33		STRB r4, [sp, #-1]!
34		BL f_neg
35		ADD sp, sp, #1
36		MOV r4, r0
37		STRB r4, [sp]
38		LDRSB r4, [sp]
39		MOV r0, r4
40		BL p_print_bool
41		BL p_print_ln
42		LDRSB r4, [sp]
43		STRB r4, [sp, #-1]!
44		BL f_neg
45		ADD sp, sp, #1
46		MOV r4, r0
47		STRB r4, [sp]
48		LDRSB r4, [sp]
49		STRB r4, [sp, #-1]!
50		BL f_neg
51		ADD sp, sp, #1
52		MOV r4, r0
53		STRB r4, [sp]
54		LDRSB r4, [sp]
55		STRB r4, [sp, #-1]!
56		BL f_neg
57		ADD sp, sp, #1
58		MOV r4, r0
59		STRB r4, [sp]
60		LDRSB r4, [sp]
61		MOV r0, r4
62		BL p_print_bool
63		BL p_print_ln
64		ADD sp, sp, #1
65		LDR r0, =0
66		POP {pc}
67		.ltorg
68	p_print_bool:
69		PUSH {lr}
70		CMP r0, #0
71		LDRNE r0, =msg_0
72		LDREQ r0, =msg_1
73		ADD r0, r0, #4
74		BL printf
75		MOV r0, #0
76		BL fflush
77		POP {pc}
78	p_print_ln:
79		PUSH {lr}
80		LDR r0, =msg_2
81		ADD r0, r0, #4
82		BL puts
83		MOV r0, #0
84		BL fflush
85		POP {pc}
86	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/sameArgName.wacc
-- Test: sameArgName.wacc

-- Uploaded file: 
---------------------------------------------------------------
# program with function that has same parameter name as function

# Output:
# 99

# Program:

begin
  int f(int f) is
    return f
  end
  
  int x = call f(99);
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
sameArgName.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	f_f:
13		PUSH {lr}
14		LDR r4, [sp, #4]
15		MOV r0, r4
16		POP {pc}
17		POP {pc}
18		.ltorg
19	main:
20		PUSH {lr}
21		SUB sp, sp, #4
22		LDR r4, =99
23		STR r4, [sp, #-4]!
24		BL f_f
25		ADD sp, sp, #4
26		MOV r4, r0
27		STR r4, [sp]
28		LDR r4, [sp]
29		MOV r0, r4
30		BL p_print_int
31		BL p_print_ln
32		ADD sp, sp, #4
33		LDR r0, =0
34		POP {pc}
35		.ltorg
36	p_print_int:
37		PUSH {lr}
38		MOV r1, r0
39		LDR r0, =msg_0
40		ADD r0, r0, #4
41		BL printf
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	p_print_ln:
46		PUSH {lr}
47		LDR r0, =msg_1
48		ADD r0, r0, #4
49		BL puts
50		MOV r0, #0
51		BL fflush
52		POP {pc}
53	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/sameArgName2.wacc
-- Test: sameArgName2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# program with function that has same parameter name as function 
# and also returns to same named variable

# Output:
# 99

# Program:

begin
  int f(int f) is
    return f
  end
  
  int f = call f(99);
  println f
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
sameArgName2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	f_f:
13		PUSH {lr}
14		LDR r4, [sp, #4]
15		MOV r0, r4
16		POP {pc}
17		POP {pc}
18		.ltorg
19	main:
20		PUSH {lr}
21		SUB sp, sp, #4
22		LDR r4, =99
23		STR r4, [sp, #-4]!
24		BL f_f
25		ADD sp, sp, #4
26		MOV r4, r0
27		STR r4, [sp]
28		LDR r4, [sp]
29		MOV r0, r4
30		BL p_print_int
31		BL p_print_ln
32		ADD sp, sp, #4
33		LDR r0, =0
34		POP {pc}
35		.ltorg
36	p_print_int:
37		PUSH {lr}
38		MOV r1, r0
39		LDR r0, =msg_0
40		ADD r0, r0, #4
41		BL printf
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	p_print_ln:
46		PUSH {lr}
47		LDR r0, =msg_1
48		ADD r0, r0, #4
49		BL puts
50		MOV r0, #0
51		BL fflush
52		POP {pc}
53	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/function/simple_functions/sameNameAsVar.wacc
-- Test: sameNameAsVar.wacc

-- Uploaded file: 
---------------------------------------------------------------
# program with function that has same name as a variable

# Output:
# 5

# Program:

begin
  int f() is
    return 5
  end
  
  int f = call f();
  println f
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
sameNameAsVar.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	f_f:
13		PUSH {lr}
14		LDR r4, =5
15		MOV r0, r4
16		POP {pc}
17		POP {pc}
18		.ltorg
19	main:
20		PUSH {lr}
21		SUB sp, sp, #4
22		BL f_f
23		MOV r4, r0
24		STR r4, [sp]
25		LDR r4, [sp]
26		MOV r0, r4
27		BL p_print_int
28		BL p_print_ln
29		ADD sp, sp, #4
30		LDR r0, =0
31		POP {pc}
32		.ltorg
33	p_print_int:
34		PUSH {lr}
35		MOV r1, r0
36		LDR r0, =msg_0
37		ADD r0, r0, #4
38		BL printf
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	p_print_ln:
43		PUSH {lr}
44		LDR r0, =msg_1
45		ADD r0, r0, #4
46		BL puts
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/if1.wacc
-- Test: if1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Simple conditional statement with int comparison test

# Output:
# correct

# Program:

begin
  int a = 13;	
  if a == 13 
  then 
    println "correct"
  else 
    println "incorrect"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
if1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"correct"
5	msg_1:
6		.word 9
7		.ascii	"incorrect"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =13
22		STR r4, [sp]
23		LDR r4, [sp]
24		LDR r5, =13
25		CMP r4, r5
26		MOVEQ r4, #1
27		MOVNE r4, #0
28		CMP r4, #0
29		BEQ L0
30		LDR r4, =msg_0
31		MOV r0, r4
32		BL p_print_string
33		BL p_print_ln
34		B L1
35	L0:
36		LDR r4, =msg_1
37		MOV r0, r4
38		BL p_print_string
39		BL p_print_ln
40	L1:
41		ADD sp, sp, #4
42		LDR r0, =0
43		POP {pc}
44		.ltorg
45	p_print_string:
46		PUSH {lr}
47		LDR r1, [r0]
48		ADD r2, r0, #4
49		LDR r0, =msg_2
50		ADD r0, r0, #4
51		BL printf
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	p_print_ln:
56		PUSH {lr}
57		LDR r0, =msg_3
58		ADD r0, r0, #4
59		BL puts
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/if2.wacc
-- Test: if2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Simple conditional statement with int comparison test

# Output:
# correct

# Program:

begin
  int a = 13;	
  if a != 13 
  then 
    println "incorrect"
  else 
    println "correct"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
if2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 9
4		.ascii	"incorrect"
5	msg_1:
6		.word 7
7		.ascii	"correct"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =13
22		STR r4, [sp]
23		LDR r4, [sp]
24		LDR r5, =13
25		CMP r4, r5
26		MOVNE r4, #1
27		MOVEQ r4, #0
28		CMP r4, #0
29		BEQ L0
30		LDR r4, =msg_0
31		MOV r0, r4
32		BL p_print_string
33		BL p_print_ln
34		B L1
35	L0:
36		LDR r4, =msg_1
37		MOV r0, r4
38		BL p_print_string
39		BL p_print_ln
40	L1:
41		ADD sp, sp, #4
42		LDR r0, =0
43		POP {pc}
44		.ltorg
45	p_print_string:
46		PUSH {lr}
47		LDR r1, [r0]
48		ADD r2, r0, #4
49		LDR r0, =msg_2
50		ADD r0, r0, #4
51		BL printf
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	p_print_ln:
56		PUSH {lr}
57		LDR r0, =msg_3
58		ADD r0, r0, #4
59		BL puts
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/if3.wacc
-- Test: if3.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Simple conditional statement with int comparison test

# Output:
# correct

# Program:

begin
  int a = 13;	
  int b = 37;
  if a < b 
  then 
    println "correct"
  else 
    println "incorrect"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
if3.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"correct"
5	msg_1:
6		.word 9
7		.ascii	"incorrect"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r4, =13
22		STR r4, [sp, #4]
23		LDR r4, =37
24		STR r4, [sp]
25		LDR r4, [sp, #4]
26		LDR r5, [sp]
27		CMP r4, r5
28		MOVLT r4, #1
29		MOVGE r4, #0
30		CMP r4, #0
31		BEQ L0
32		LDR r4, =msg_0
33		MOV r0, r4
34		BL p_print_string
35		BL p_print_ln
36		B L1
37	L0:
38		LDR r4, =msg_1
39		MOV r0, r4
40		BL p_print_string
41		BL p_print_ln
42	L1:
43		ADD sp, sp, #8
44		LDR r0, =0
45		POP {pc}
46		.ltorg
47	p_print_string:
48		PUSH {lr}
49		LDR r1, [r0]
50		ADD r2, r0, #4
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL printf
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_print_ln:
58		PUSH {lr}
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL puts
62		MOV r0, #0
63		BL fflush
64		POP {pc}
65	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/if4.wacc
-- Test: if4.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Simple conditional statement with boolen expression test

# Output:
# correct

# Program:

begin
  bool b = true;
  bool c = false;	
  if b && c 
  then 
    println "incorrect"
  else 
    println "correct"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
if4.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 9
4		.ascii	"incorrect"
5	msg_1:
6		.word 7
7		.ascii	"correct"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #2
21		MOV r4, #1
22		STRB r4, [sp, #1]
23		MOV r4, #0
24		STRB r4, [sp]
25		LDRSB r4, [sp, #1]
26		LDRSB r5, [sp]
27		AND r4, r4, r5
28		CMP r4, #0
29		BEQ L0
30		LDR r4, =msg_0
31		MOV r0, r4
32		BL p_print_string
33		BL p_print_ln
34		B L1
35	L0:
36		LDR r4, =msg_1
37		MOV r0, r4
38		BL p_print_string
39		BL p_print_ln
40	L1:
41		ADD sp, sp, #2
42		LDR r0, =0
43		POP {pc}
44		.ltorg
45	p_print_string:
46		PUSH {lr}
47		LDR r1, [r0]
48		ADD r2, r0, #4
49		LDR r0, =msg_2
50		ADD r0, r0, #4
51		BL printf
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	p_print_ln:
56		PUSH {lr}
57		LDR r0, =msg_3
58		ADD r0, r0, #4
59		BL puts
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/if5.wacc
-- Test: if5.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Simple conditional statement with boolen expression test

# Output:
# correct

# Program:

begin
  bool b = true;
  bool c = false;	
  if b || c 
  then 
    println "correct"
  else 
    println "incorrect"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
if5.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"correct"
5	msg_1:
6		.word 9
7		.ascii	"incorrect"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #2
21		MOV r4, #1
22		STRB r4, [sp, #1]
23		MOV r4, #0
24		STRB r4, [sp]
25		LDRSB r4, [sp, #1]
26		LDRSB r5, [sp]
27		ORR r4, r4, r5
28		CMP r4, #0
29		BEQ L0
30		LDR r4, =msg_0
31		MOV r0, r4
32		BL p_print_string
33		BL p_print_ln
34		B L1
35	L0:
36		LDR r4, =msg_1
37		MOV r0, r4
38		BL p_print_string
39		BL p_print_ln
40	L1:
41		ADD sp, sp, #2
42		LDR r0, =0
43		POP {pc}
44		.ltorg
45	p_print_string:
46		PUSH {lr}
47		LDR r1, [r0]
48		ADD r2, r0, #4
49		LDR r0, =msg_2
50		ADD r0, r0, #4
51		BL printf
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	p_print_ln:
56		PUSH {lr}
57		LDR r0, =msg_3
58		ADD r0, r0, #4
59		BL puts
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/if6.wacc
-- Test: if6.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Simple conditional statement with character comparison test

# Output:
# correct

# Program:

begin
  char c1 = 'f';
  char c2 = 'F';	
  if c1 == c2 
  then 
    println "incorrect"
  else 
    println "correct"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
if6.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 9
4		.ascii	"incorrect"
5	msg_1:
6		.word 7
7		.ascii	"correct"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #2
21		MOV r4, #'f'
22		STRB r4, [sp, #1]
23		MOV r4, #'F'
24		STRB r4, [sp]
25		LDRSB r4, [sp, #1]
26		LDRSB r5, [sp]
27		CMP r4, r5
28		MOVEQ r4, #1
29		MOVNE r4, #0
30		CMP r4, #0
31		BEQ L0
32		LDR r4, =msg_0
33		MOV r0, r4
34		BL p_print_string
35		BL p_print_ln
36		B L1
37	L0:
38		LDR r4, =msg_1
39		MOV r0, r4
40		BL p_print_string
41		BL p_print_ln
42	L1:
43		ADD sp, sp, #2
44		LDR r0, =0
45		POP {pc}
46		.ltorg
47	p_print_string:
48		PUSH {lr}
49		LDR r1, [r0]
50		ADD r2, r0, #4
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL printf
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_print_ln:
58		PUSH {lr}
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL puts
62		MOV r0, #0
63		BL fflush
64		POP {pc}
65	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/ifBasic.wacc
-- Test: ifBasic.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple if statement

# Output:
# #empty#

# Program:

begin
  if true 
  then
    skip
  else
    skip
  fi
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ifBasic.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		MOV r4, #1
6		CMP r4, #0
7		BEQ L0
8		B L1
9	L0:
10	L1:
11		LDR r0, =0
12		POP {pc}
13		.ltorg
14	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/ifFalse.wacc
-- Test: ifFalse.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple false if statement 

# Output:
# here

# Program:

begin
  if false
  then
    println "not here"
  else
    println "here"
  fi
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ifFalse.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 8
4		.ascii	"not here"
5	msg_1:
6		.word 4
7		.ascii	"here"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		MOV r4, #0
21		CMP r4, #0
22		BEQ L0
23		LDR r4, =msg_0
24		MOV r0, r4
25		BL p_print_string
26		BL p_print_ln
27		B L1
28	L0:
29		LDR r4, =msg_1
30		MOV r0, r4
31		BL p_print_string
32		BL p_print_ln
33	L1:
34		LDR r0, =0
35		POP {pc}
36		.ltorg
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_2
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	p_print_ln:
48		PUSH {lr}
49		LDR r0, =msg_3
50		ADD r0, r0, #4
51		BL puts
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/ifTrue.wacc
-- Test: ifTrue.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple true if statement

# Output:
# here

# Program:

begin
  if true
  then
    println "here"
  else
    println "not here"
  fi
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ifTrue.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 4
4		.ascii	"here"
5	msg_1:
6		.word 8
7		.ascii	"not here"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		MOV r4, #1
21		CMP r4, #0
22		BEQ L0
23		LDR r4, =msg_0
24		MOV r0, r4
25		BL p_print_string
26		BL p_print_ln
27		B L1
28	L0:
29		LDR r4, =msg_1
30		MOV r0, r4
31		BL p_print_string
32		BL p_print_ln
33	L1:
34		LDR r0, =0
35		POP {pc}
36		.ltorg
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_2
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	p_print_ln:
48		PUSH {lr}
49		LDR r0, =msg_3
50		ADD r0, r0, #4
51		BL puts
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/if/whitespace.wacc
-- Test: whitespace.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Whitespace only important between keyword and variable tokens

# Output:
# 1

# Program:

begin
	int a=13;	
  if a==13then a=1else a=0fi;
  println a
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
whitespace.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =13
16		STR r4, [sp]
17		LDR r4, [sp]
18		LDR r5, =13
19		CMP r4, r5
20		MOVEQ r4, #1
21		MOVNE r4, #0
22		CMP r4, #0
23		BEQ L0
24		LDR r4, =1
25		STR r4, [sp]
26		B L1
27	L0:
28		LDR r4, =0
29		STR r4, [sp]
30	L1:
31		LDR r4, [sp]
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #4
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_print_int:
40		PUSH {lr}
41		MOV r1, r0
42		LDR r0, =msg_0
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_1
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/IOLoop.wacc
-- Test: IOLoop.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple input/output loop

# Output:
# Please input an integer: #input#
# echo input: #output#
# Do you want to continue entering input?
# (enter Y for 'yes' and N for 'no')
# #input#
# ...

# Program:

begin
  char continue = 'Y' ;
  int buff = 0 ;
  while continue != 'N' do
    print "Please input an integer: " ;
    read buff ;
    print "echo input: " ;
    println buff ;
    println "Do you want to continue entering input?" ; 
    println "(enter Y for \'yes\' and N for \'no\')" ;
    read continue
  done
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
IOLoop.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 25
4		.ascii	"Please input an integer: "
5	msg_1:
6		.word 12
7		.ascii	"echo input: "
8	msg_2:
9		.word 39
10		.ascii	"Do you want to continue entering input?"
11	msg_3:
12		.word 34
13		.ascii	"(enter Y for \'yes\' and N for \'no\')"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 3
22		.ascii	"%d\0"
23	msg_7:
24		.word 1
25		.ascii	"\0"
26	msg_8:
27		.word 4
28		.ascii	" %c\0"
29	
30	.text
31	
32	.global main
33	main:
34		PUSH {lr}
35		SUB sp, sp, #5
36		MOV r4, #'Y'
37		STRB r4, [sp, #4]
38		LDR r4, =0
39		STR r4, [sp]
40		B L0
41	L1:
42		LDR r4, =msg_0
43		MOV r0, r4
44		BL p_print_string
45		ADD r4, sp, #0
46		MOV r0, r4
47		BL p_read_int
48		LDR r4, =msg_1
49		MOV r0, r4
50		BL p_print_string
51		LDR r4, [sp]
52		MOV r0, r4
53		BL p_print_int
54		BL p_print_ln
55		LDR r4, =msg_2
56		MOV r0, r4
57		BL p_print_string
58		BL p_print_ln
59		LDR r4, =msg_3
60		MOV r0, r4
61		BL p_print_string
62		BL p_print_ln
63		ADD r4, sp, #4
64		MOV r0, r4
65		BL p_read_char
66	L0:
67		LDRSB r4, [sp, #4]
68		MOV r5, #'N'
69		CMP r4, r5
70		MOVNE r4, #1
71		MOVEQ r4, #0
72		CMP r4, #1
73		BEQ L1
74		ADD sp, sp, #5
75		LDR r0, =0
76		POP {pc}
77		.ltorg
78	p_print_string:
79		PUSH {lr}
80		LDR r1, [r0]
81		ADD r2, r0, #4
82		LDR r0, =msg_4
83		ADD r0, r0, #4
84		BL printf
85		MOV r0, #0
86		BL fflush
87		POP {pc}
88	p_read_int:
89		PUSH {lr}
90		MOV r1, r0
91		LDR r0, =msg_5
92		ADD r0, r0, #4
93		BL scanf
94		POP {pc}
95	p_print_int:
96		PUSH {lr}
97		MOV r1, r0
98		LDR r0, =msg_6
99		ADD r0, r0, #4
100		BL printf
101		MOV r0, #0
102		BL fflush
103		POP {pc}
104	p_print_ln:
105		PUSH {lr}
106		LDR r0, =msg_7
107		ADD r0, r0, #4
108		BL puts
109		MOV r0, #0
110		BL fflush
111		POP {pc}
112	p_read_char:
113		PUSH {lr}
114		MOV r1, r0
115		LDR r0, =msg_8
116		ADD r0, r0, #4
117		BL scanf
118		POP {pc}
119	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/IOSequence.wacc
-- Test: IOSequence.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic input/output sequence

# Output:
# Please input an integer: #input#
# You input: #output#

# Program:

begin 
  int x = 0 ;
  print "Please input an integer: " ;
  read x ;
  print "You input: " ;
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
IOSequence.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 25
4		.ascii	"Please input an integer: "
5	msg_1:
6		.word 11
7		.ascii	"You input: "
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 3
16		.ascii	"%d\0"
17	msg_5:
18		.word 1
19		.ascii	"\0"
20	
21	.text
22	
23	.global main
24	main:
25		PUSH {lr}
26		SUB sp, sp, #4
27		LDR r4, =0
28		STR r4, [sp]
29		LDR r4, =msg_0
30		MOV r0, r4
31		BL p_print_string
32		ADD r4, sp, #0
33		MOV r0, r4
34		BL p_read_int
35		LDR r4, =msg_1
36		MOV r0, r4
37		BL p_print_string
38		LDR r4, [sp]
39		MOV r0, r4
40		BL p_print_int
41		BL p_print_ln
42		ADD sp, sp, #4
43		LDR r0, =0
44		POP {pc}
45		.ltorg
46	p_print_string:
47		PUSH {lr}
48		LDR r1, [r0]
49		ADD r2, r0, #4
50		LDR r0, =msg_2
51		ADD r0, r0, #4
52		BL printf
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	p_read_int:
57		PUSH {lr}
58		MOV r1, r0
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL scanf
62		POP {pc}
63	p_print_int:
64		PUSH {lr}
65		MOV r1, r0
66		LDR r0, =msg_4
67		ADD r0, r0, #4
68		BL printf
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	p_print_ln:
73		PUSH {lr}
74		LDR r0, =msg_5
75		ADD r0, r0, #4
76		BL puts
77		MOV r0, #0
78		BL fflush
79		POP {pc}
80	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/hashInProgram.wacc
-- Test: hashInProgram.wacc

-- Uploaded file: 
---------------------------------------------------------------
# In-line comments and printing #

# Output:
# We can print the hash character: #
# We can also print # when its in a string.

# Program:

begin 
  int x = 0 ; # comments can be in-line
  print "We can print the hash character: " ;
  println '#' ;
  println "We can also print # when its in a string."
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
hashInProgram.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 33
4		.ascii	"We can print the hash character: "
5	msg_1:
6		.word 41
7		.ascii	"We can also print # when its in a string."
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =0
22		STR r4, [sp]
23		LDR r4, =msg_0
24		MOV r0, r4
25		BL p_print_string
26		MOV r4, #'#'
27		MOV r0, r4
28		BL putchar
29		BL p_print_ln
30		LDR r4, =msg_1
31		MOV r0, r4
32		BL p_print_string
33		BL p_print_ln
34		ADD sp, sp, #4
35		LDR r0, =0
36		POP {pc}
37		.ltorg
38	p_print_string:
39		PUSH {lr}
40		LDR r1, [r0]
41		ADD r2, r0, #4
42		LDR r0, =msg_2
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_3
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/multipleStringsAssignment.wacc
-- Test: multipleStringsAssignment.wacc

-- Uploaded file: 
---------------------------------------------------------------
# multiple string assignments and comparisons

# Output:
# s1 is Hi
# s2 is Hi
# They are not the same string.
# Now make s1 = s2
# s1 is hi
# s2 is Hi
# They are the same string.

# Program:

begin
  string s1 = "Hi" ;
  string s2 = "Hi" ;
  print "s1 is " ;
  println s1 ;
  print "s2 is " ;
  println s2 ;
  if s1 == s2 then
    println "They are the same string." 
  else 
    println "They are not the same string."
  fi ;

  println "Now make s1 = s2" ;
  s1 = s2 ;

  print "s1 is " ;
  println s1 ;
  print "s2 is " ;
  println s2 ;
  if s1 == s2 then
    println "They are the same string." 
  else 
    println "They are not the same string."
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
multipleStringsAssignment.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 2
4		.ascii	"Hi"
5	msg_1:
6		.word 2
7		.ascii	"Hi"
8	msg_2:
9		.word 6
10		.ascii	"s1 is "
11	msg_3:
12		.word 6
13		.ascii	"s2 is "
14	msg_4:
15		.word 25
16		.ascii	"They are the same string."
17	msg_5:
18		.word 29
19		.ascii	"They are not the same string."
20	msg_6:
21		.word 16
22		.ascii	"Now make s1 = s2"
23	msg_7:
24		.word 6
25		.ascii	"s1 is "
26	msg_8:
27		.word 6
28		.ascii	"s2 is "
29	msg_9:
30		.word 25
31		.ascii	"They are the same string."
32	msg_10:
33		.word 29
34		.ascii	"They are not the same string."
35	msg_11:
36		.word 5
37		.ascii	"%.*s\0"
38	msg_12:
39		.word 1
40		.ascii	"\0"
41	
42	.text
43	
44	.global main
45	main:
46		PUSH {lr}
47		SUB sp, sp, #8
48		LDR r4, =msg_0
49		STR r4, [sp, #4]
50		LDR r4, =msg_1
51		STR r4, [sp]
52		LDR r4, =msg_2
53		MOV r0, r4
54		BL p_print_string
55		LDR r4, [sp, #4]
56		MOV r0, r4
57		BL p_print_string
58		BL p_print_ln
59		LDR r4, =msg_3
60		MOV r0, r4
61		BL p_print_string
62		LDR r4, [sp]
63		MOV r0, r4
64		BL p_print_string
65		BL p_print_ln
66		LDR r4, [sp, #4]
67		LDR r5, [sp]
68		CMP r4, r5
69		MOVEQ r4, #1
70		MOVNE r4, #0
71		CMP r4, #0
72		BEQ L0
73		LDR r4, =msg_4
74		MOV r0, r4
75		BL p_print_string
76		BL p_print_ln
77		B L1
78	L0:
79		LDR r4, =msg_5
80		MOV r0, r4
81		BL p_print_string
82		BL p_print_ln
83	L1:
84		LDR r4, =msg_6
85		MOV r0, r4
86		BL p_print_string
87		BL p_print_ln
88		LDR r4, [sp]
89		STR r4, [sp, #4]
90		LDR r4, =msg_7
91		MOV r0, r4
92		BL p_print_string
93		LDR r4, [sp, #4]
94		MOV r0, r4
95		BL p_print_string
96		BL p_print_ln
97		LDR r4, =msg_8
98		MOV r0, r4
99		BL p_print_string
100		LDR r4, [sp]
101		MOV r0, r4
102		BL p_print_string
103		BL p_print_ln
104		LDR r4, [sp, #4]
105		LDR r5, [sp]
106		CMP r4, r5
107		MOVEQ r4, #1
108		MOVNE r4, #0
109		CMP r4, #0
110		BEQ L2
111		LDR r4, =msg_9
112		MOV r0, r4
113		BL p_print_string
114		BL p_print_ln
115		B L3
116	L2:
117		LDR r4, =msg_10
118		MOV r0, r4
119		BL p_print_string
120		BL p_print_ln
121	L3:
122		ADD sp, sp, #8
123		LDR r0, =0
124		POP {pc}
125		.ltorg
126	p_print_string:
127		PUSH {lr}
128		LDR r1, [r0]
129		ADD r2, r0, #4
130		LDR r0, =msg_11
131		ADD r0, r0, #4
132		BL printf
133		MOV r0, #0
134		BL fflush
135		POP {pc}
136	p_print_ln:
137		PUSH {lr}
138		LDR r0, =msg_12
139		ADD r0, r0, #4
140		BL puts
141		MOV r0, #0
142		BL fflush
143		POP {pc}
144	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/print-backspace.wacc
-- Test: print-backspace.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple print statement off a string with a backspace character

# Output:
# Hell World!

# Program:

begin  
  print "Hello\b World!\n"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
print-backspace.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 14
4		.ascii	"Hello\b World!\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		LDR r4, =msg_0
15		MOV r0, r4
16		BL p_print_string
17		LDR r0, =0
18		POP {pc}
19		.ltorg
20	p_print_string:
21		PUSH {lr}
22		LDR r1, [r0]
23		ADD r2, r0, #4
24		LDR r0, =msg_1
25		ADD r0, r0, #4
26		BL printf
27		MOV r0, #0
28		BL fflush
29		POP {pc}
30	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/print-carridge-return.wacc
-- Test: print-carridge-return.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple print statement off a string with a carridge-return character

# Output:
#  World!

# Program:

begin
  print "Hello \r World!\n"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
print-carridge-return.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 15
4		.ascii	"Hello \r World!\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		LDR r4, =msg_0
15		MOV r0, r4
16		BL p_print_string
17		LDR r0, =0
18		POP {pc}
19		.ltorg
20	p_print_string:
21		PUSH {lr}
22		LDR r1, [r0]
23		ADD r2, r0, #4
24		LDR r0, =msg_1
25		ADD r0, r0, #4
26		BL printf
27		MOV r0, #0
28		BL fflush
29		POP {pc}
30	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/print.wacc
-- Test: print.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple print statement

# Output:
# Hello World!

# Program:

begin
  print "Hello World!\n"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
print.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 13
4		.ascii	"Hello World!\n"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		LDR r4, =msg_0
15		MOV r0, r4
16		BL p_print_string
17		LDR r0, =0
18		POP {pc}
19		.ltorg
20	p_print_string:
21		PUSH {lr}
22		LDR r1, [r0]
23		ADD r2, r0, #4
24		LDR r0, =msg_1
25		ADD r0, r0, #4
26		BL printf
27		MOV r0, #0
28		BL fflush
29		POP {pc}
30	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/printBool.wacc
-- Test: printBool.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic Boolean printing

# Output:
# True is true
# False is false

# Program:

begin
  print "True is " ;
  println true ;

  print "False is " ;
  println false
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printBool.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 8
4		.ascii	"True is "
5	msg_1:
6		.word 9
7		.ascii	"False is "
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 5
13		.ascii	"true\0"
14	msg_4:
15		.word 6
16		.ascii	"false\0"
17	msg_5:
18		.word 1
19		.ascii	"\0"
20	
21	.text
22	
23	.global main
24	main:
25		PUSH {lr}
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		MOV r4, #1
30		MOV r0, r4
31		BL p_print_bool
32		BL p_print_ln
33		LDR r4, =msg_1
34		MOV r0, r4
35		BL p_print_string
36		MOV r4, #0
37		MOV r0, r4
38		BL p_print_bool
39		BL p_print_ln
40		LDR r0, =0
41		POP {pc}
42		.ltorg
43	p_print_string:
44		PUSH {lr}
45		LDR r1, [r0]
46		ADD r2, r0, #4
47		LDR r0, =msg_2
48		ADD r0, r0, #4
49		BL printf
50		MOV r0, #0
51		BL fflush
52		POP {pc}
53	p_print_bool:
54		PUSH {lr}
55		CMP r0, #0
56		LDRNE r0, =msg_3
57		LDREQ r0, =msg_4
58		ADD r0, r0, #4
59		BL printf
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	p_print_ln:
64		PUSH {lr}
65		LDR r0, =msg_5
66		ADD r0, r0, #4
67		BL puts
68		MOV r0, #0
69		BL fflush
70		POP {pc}
71	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/printChar.wacc
-- Test: printChar.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic character printing

# Output:
# A simple character example is f

# Program:

begin
  print "A simple character example is " ;
  println 'f'
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printChar.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 30
4		.ascii	"A simple character example is "
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		LDR r4, =msg_0
18		MOV r0, r4
19		BL p_print_string
20		MOV r4, #'f'
21		MOV r0, r4
22		BL putchar
23		BL p_print_ln
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_print_string:
28		PUSH {lr}
29		LDR r1, [r0]
30		ADD r2, r0, #4
31		LDR r0, =msg_1
32		ADD r0, r0, #4
33		BL printf
34		MOV r0, #0
35		BL fflush
36		POP {pc}
37	p_print_ln:
38		PUSH {lr}
39		LDR r0, =msg_2
40		ADD r0, r0, #4
41		BL puts
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/printCharArray.wacc
-- Test: printCharArray.wacc

-- Uploaded file: 
---------------------------------------------------------------
# printing the contents of a char[] is possible via an intermediate variable

# Output:
# hi!

# Exit:
# 0

# Program:

begin
  char[] s = ['h','i','!'];
  println s
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printCharArray.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"%.*s\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r0, =7
16		BL malloc
17		MOV r4, r0
18		MOV r5, #'h'
19		STRB r5, [r4, #4]
20		MOV r5, #'i'
21		STRB r5, [r4, #5]
22		MOV r5, #'!'
23		STRB r5, [r4, #6]
24		LDR r5, =3
25		STR r5, [r4]
26		STR r4, [sp]
27		LDR r4, [sp]
28		MOV r0, r4
29		BL p_print_string
30		BL p_print_ln
31		ADD sp, sp, #4
32		LDR r0, =0
33		POP {pc}
34		.ltorg
35	p_print_string:
36		PUSH {lr}
37		LDR r1, [r0]
38		ADD r2, r0, #4
39		LDR r0, =msg_0
40		ADD r0, r0, #4
41		BL printf
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	p_print_ln:
46		PUSH {lr}
47		LDR r0, =msg_1
48		ADD r0, r0, #4
49		BL puts
50		MOV r0, #0
51		BL fflush
52		POP {pc}
53	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/printCharAsString.wacc
-- Test: printCharAsString.wacc

-- Uploaded file: 
---------------------------------------------------------------
# character array treated as a string

# Output:
# foo
# bar

# Program:

begin
  char[] str = ['f','o','o'];
  println str;
  str = ['b','a','r'];
  println str
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printCharAsString.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"%.*s\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r0, =7
16		BL malloc
17		MOV r4, r0
18		MOV r5, #'f'
19		STRB r5, [r4, #4]
20		MOV r5, #'o'
21		STRB r5, [r4, #5]
22		MOV r5, #'o'
23		STRB r5, [r4, #6]
24		LDR r5, =3
25		STR r5, [r4]
26		STR r4, [sp]
27		LDR r4, [sp]
28		MOV r0, r4
29		BL p_print_string
30		BL p_print_ln
31		LDR r0, =7
32		BL malloc
33		MOV r4, r0
34		MOV r5, #'b'
35		STRB r5, [r4, #4]
36		MOV r5, #'a'
37		STRB r5, [r4, #5]
38		MOV r5, #'r'
39		STRB r5, [r4, #6]
40		LDR r5, =3
41		STR r5, [r4]
42		STR r4, [sp]
43		LDR r4, [sp]
44		MOV r0, r4
45		BL p_print_string
46		BL p_print_ln
47		ADD sp, sp, #4
48		LDR r0, =0
49		POP {pc}
50		.ltorg
51	p_print_string:
52		PUSH {lr}
53		LDR r1, [r0]
54		ADD r2, r0, #4
55		LDR r0, =msg_0
56		ADD r0, r0, #4
57		BL printf
58		MOV r0, #0
59		BL fflush
60		POP {pc}
61	p_print_ln:
62		PUSH {lr}
63		LDR r0, =msg_1
64		ADD r0, r0, #4
65		BL puts
66		MOV r0, #0
67		BL fflush
68		POP {pc}
69	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/printEscChar.wacc
-- Test: printEscChar.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic escaped character printing

# Output:
# An escaped character example is "

# Program:

begin
  print "An escaped character example is " ;
  println '\"'
end
---------------------------------------------------------------

-- Compiler Output:
-- Warning: input file extension is '' and not '.wacc'. Check you are targeting a WACC program.
-- Compiling...
-- Printing Assembly...
test.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 32
4		.ascii	"An escaped character example is "
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		LDR r4, =msg_0
18		MOV r0, r4
19		BL p_print_string
20		MOV r4, #'"'
21		MOV r0, r4
22		BL putchar
23		BL p_print_ln
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_print_string:
28		PUSH {lr}
29		LDR r1, [r0]
30		ADD r2, r0, #4
31		LDR r0, =msg_1
32		ADD r0, r0, #4
33		BL printf
34		MOV r0, #0
35		BL fflush
36		POP {pc}
37	p_print_ln:
38		PUSH {lr}
39		LDR r0, =msg_2
40		ADD r0, r0, #4
41		BL puts
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/printInt.wacc
-- Test: printInt.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic Integer printing

# Output:
# An example integer is 189

# Program:

begin
  print "An example integer is " ;
  println 189
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printInt.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 22
4		.ascii	"An example integer is "
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		LDR r4, =msg_0
21		MOV r0, r4
22		BL p_print_string
23		LDR r4, =189
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_print_string:
31		PUSH {lr}
32		LDR r1, [r0]
33		ADD r2, r0, #4
34		LDR r0, =msg_1
35		ADD r0, r0, #4
36		BL printf
37		MOV r0, #0
38		BL fflush
39		POP {pc}
40	p_print_int:
41		PUSH {lr}
42		MOV r1, r0
43		LDR r0, =msg_2
44		ADD r0, r0, #4
45		BL printf
46		MOV r0, #0
47		BL fflush
48		POP {pc}
49	p_print_ln:
50		PUSH {lr}
51		LDR r0, =msg_3
52		ADD r0, r0, #4
53		BL puts
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/print/println.wacc
-- Test: println.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple println statement

# Output:
# Hello World!

# Program:

begin
  println "Hello World!"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
println.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 12
4		.ascii	"Hello World!"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		LDR r4, =msg_0
18		MOV r0, r4
19		BL p_print_string
20		BL p_print_ln
21		LDR r0, =0
22		POP {pc}
23		.ltorg
24	p_print_string:
25		PUSH {lr}
26		LDR r1, [r0]
27		ADD r2, r0, #4
28		LDR r0, =msg_1
29		ADD r0, r0, #4
30		BL printf
31		MOV r0, #0
32		BL fflush
33		POP {pc}
34	p_print_ln:
35		PUSH {lr}
36		LDR r0, =msg_2
37		ADD r0, r0, #4
38		BL puts
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/echoBigInt.wacc
-- Test: echoBigInt.wacc

-- Uploaded file: 
---------------------------------------------------------------
# echo the user's input int

# Output:
# enter an integer to echo
# #input#
# #output#

# Program:

begin
  int x = 1 ;
  println "enter an integer to echo";
  read x ; 
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
echoBigInt.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 24
4		.ascii	"enter an integer to echo"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 3
16		.ascii	"%d\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =1
25		STR r4, [sp]
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		BL p_print_ln
30		ADD r4, sp, #0
31		MOV r0, r4
32		BL p_read_int
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_string:
42		PUSH {lr}
43		LDR r1, [r0]
44		ADD r2, r0, #4
45		LDR r0, =msg_1
46		ADD r0, r0, #4
47		BL printf
48		MOV r0, #0
49		BL fflush
50		POP {pc}
51	p_print_ln:
52		PUSH {lr}
53		LDR r0, =msg_2
54		ADD r0, r0, #4
55		BL puts
56		MOV r0, #0
57		BL fflush
58		POP {pc}
59	p_read_int:
60		PUSH {lr}
61		MOV r1, r0
62		LDR r0, =msg_3
63		ADD r0, r0, #4
64		BL scanf
65		POP {pc}
66	p_print_int:
67		PUSH {lr}
68		MOV r1, r0
69		LDR r0, =msg_4
70		ADD r0, r0, #4
71		BL printf
72		MOV r0, #0
73		BL fflush
74		POP {pc}
75	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/echoBigNegInt.wacc
-- Test: echoBigNegInt.wacc

-- Uploaded file: 
---------------------------------------------------------------
# echo the user's input int

# Output:
# enter an integer to echo
# #input#
# #output#

# Program:

begin
  int x = 1 ;
  println "enter an integer to echo";
  read x ; 
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
echoBigInt.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 24
4		.ascii	"enter an integer to echo"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 3
16		.ascii	"%d\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =1
25		STR r4, [sp]
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		BL p_print_ln
30		ADD r4, sp, #0
31		MOV r0, r4
32		BL p_read_int
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_string:
42		PUSH {lr}
43		LDR r1, [r0]
44		ADD r2, r0, #4
45		LDR r0, =msg_1
46		ADD r0, r0, #4
47		BL printf
48		MOV r0, #0
49		BL fflush
50		POP {pc}
51	p_print_ln:
52		PUSH {lr}
53		LDR r0, =msg_2
54		ADD r0, r0, #4
55		BL puts
56		MOV r0, #0
57		BL fflush
58		POP {pc}
59	p_read_int:
60		PUSH {lr}
61		MOV r1, r0
62		LDR r0, =msg_3
63		ADD r0, r0, #4
64		BL scanf
65		POP {pc}
66	p_print_int:
67		PUSH {lr}
68		MOV r1, r0
69		LDR r0, =msg_4
70		ADD r0, r0, #4
71		BL printf
72		MOV r0, #0
73		BL fflush
74		POP {pc}
75	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/echoChar.wacc
-- Test: echoChar.wacc

-- Uploaded file: 
---------------------------------------------------------------
# echo the user's input char

# Output:
# enter a character to echo
# #input#
# #output#

# Program:

begin
	char c = '\0' ;
  println "enter a character to echo";
	read c ;
	println c 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
echoChar.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 25
4		.ascii	"enter a character to echo"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 4
13		.ascii	" %c\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #1
21		MOV r4, #0
22		STRB r4, [sp]
23		LDR r4, =msg_0
24		MOV r0, r4
25		BL p_print_string
26		BL p_print_ln
27		ADD r4, sp, #0
28		MOV r0, r4
29		BL p_read_char
30		LDRSB r4, [sp]
31		MOV r0, r4
32		BL putchar
33		BL p_print_ln
34		ADD sp, sp, #1
35		LDR r0, =0
36		POP {pc}
37		.ltorg
38	p_print_string:
39		PUSH {lr}
40		LDR r1, [r0]
41		ADD r2, r0, #4
42		LDR r0, =msg_1
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_2
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	p_read_char:
57		PUSH {lr}
58		MOV r1, r0
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL scanf
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/echoInt.wacc
-- Test: echoInt.wacc

-- Uploaded file: 
---------------------------------------------------------------
# echo the user's input int

# Output:
# enter an integer to echo
# #input#
# #output#

# Program:

begin
	int x = 1 ;
  println "enter an integer to echo";
	read x ; 
	println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
echoInt.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 24
4		.ascii	"enter an integer to echo"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 3
16		.ascii	"%d\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =1
25		STR r4, [sp]
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		BL p_print_ln
30		ADD r4, sp, #0
31		MOV r0, r4
32		BL p_read_int
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_string:
42		PUSH {lr}
43		LDR r1, [r0]
44		ADD r2, r0, #4
45		LDR r0, =msg_1
46		ADD r0, r0, #4
47		BL printf
48		MOV r0, #0
49		BL fflush
50		POP {pc}
51	p_print_ln:
52		PUSH {lr}
53		LDR r0, =msg_2
54		ADD r0, r0, #4
55		BL puts
56		MOV r0, #0
57		BL fflush
58		POP {pc}
59	p_read_int:
60		PUSH {lr}
61		MOV r1, r0
62		LDR r0, =msg_3
63		ADD r0, r0, #4
64		BL scanf
65		POP {pc}
66	p_print_int:
67		PUSH {lr}
68		MOV r1, r0
69		LDR r0, =msg_4
70		ADD r0, r0, #4
71		BL printf
72		MOV r0, #0
73		BL fflush
74		POP {pc}
75	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/echoNegInt.wacc
-- Test: echoNegInt.wacc

-- Uploaded file: 
---------------------------------------------------------------
# echo the user's input int

# Output:
# enter an integer to echo
# #input#
# #output#

# Program:

begin
  int x = 1 ;
  println "enter an integer to echo";
  read x ; 
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
echoBigInt.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 24
4		.ascii	"enter an integer to echo"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 3
16		.ascii	"%d\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =1
25		STR r4, [sp]
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		BL p_print_ln
30		ADD r4, sp, #0
31		MOV r0, r4
32		BL p_read_int
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_string:
42		PUSH {lr}
43		LDR r1, [r0]
44		ADD r2, r0, #4
45		LDR r0, =msg_1
46		ADD r0, r0, #4
47		BL printf
48		MOV r0, #0
49		BL fflush
50		POP {pc}
51	p_print_ln:
52		PUSH {lr}
53		LDR r0, =msg_2
54		ADD r0, r0, #4
55		BL puts
56		MOV r0, #0
57		BL fflush
58		POP {pc}
59	p_read_int:
60		PUSH {lr}
61		MOV r1, r0
62		LDR r0, =msg_3
63		ADD r0, r0, #4
64		BL scanf
65		POP {pc}
66	p_print_int:
67		PUSH {lr}
68		MOV r1, r0
69		LDR r0, =msg_4
70		ADD r0, r0, #4
71		BL printf
72		MOV r0, #0
73		BL fflush
74		POP {pc}
75	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/echoPuncChar.wacc
-- Test: echoPuncChar.wacc

-- Uploaded file: 
---------------------------------------------------------------
# echo the user's input char

# Output:
# enter a character to echo
# #input#
# #output#

# Program:

begin
  char c = '\0' ;
  println "enter a character to echo";
  read c ;
  println c 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
echoPuncChar.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 25
4		.ascii	"enter a character to echo"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 4
13		.ascii	" %c\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #1
21		MOV r4, #0
22		STRB r4, [sp]
23		LDR r4, =msg_0
24		MOV r0, r4
25		BL p_print_string
26		BL p_print_ln
27		ADD r4, sp, #0
28		MOV r0, r4
29		BL p_read_char
30		LDRSB r4, [sp]
31		MOV r0, r4
32		BL putchar
33		BL p_print_ln
34		ADD sp, sp, #1
35		LDR r0, =0
36		POP {pc}
37		.ltorg
38	p_print_string:
39		PUSH {lr}
40		LDR r1, [r0]
41		ADD r2, r0, #4
42		LDR r0, =msg_1
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_2
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	p_read_char:
57		PUSH {lr}
58		MOV r1, r0
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL scanf
62		POP {pc}
63	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/IO/read/read.wacc
-- Test: read.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple read statement

# Output:
# input an integer to continue...
# #input#

# Program:

begin
	int x = 10;
  println "input an integer to continue..." ;
	read x
end
---------------------------------------------------------------

-- Compiler Output:
-- Warning: input file extension is '' and not '.wacc'. Check you are targeting a WACC program.
-- Compiling...
-- Printing Assembly...
test.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 31
4		.ascii	"input an integer to continue..."
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =10
22		STR r4, [sp]
23		LDR r4, =msg_0
24		MOV r0, r4
25		BL p_print_string
26		BL p_print_ln
27		ADD r4, sp, #0
28		MOV r0, r4
29		BL p_read_int
30		ADD sp, sp, #4
31		LDR r0, =0
32		POP {pc}
33		.ltorg
34	p_print_string:
35		PUSH {lr}
36		LDR r1, [r0]
37		ADD r2, r0, #4
38		LDR r0, =msg_1
39		ADD r0, r0, #4
40		BL printf
41		MOV r0, #0
42		BL fflush
43		POP {pc}
44	p_print_ln:
45		PUSH {lr}
46		LDR r0, =msg_2
47		ADD r0, r0, #4
48		BL puts
49		MOV r0, #0
50		BL fflush
51		POP {pc}
52	p_read_int:
53		PUSH {lr}
54		MOV r1, r0
55		LDR r0, =msg_3
56		ADD r0, r0, #4
57		BL scanf
58		POP {pc}
59	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/checkRefPair.wacc
-- Test: checkRefPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair(int, char) with a second reference to it and check it works

# Output:
# #addrs#
# #addrs#
# true
# 10
# 10
# true
# a
# a
# true

# Program:

begin
  pair(int, char) p = newpair(10, 'a') ;
  pair(int, char) q = p;
  println p ;
  println q ;
  println p == q ;
  int x = fst p ;
  int y = fst q ;
  println x ;
  println y ;
  println x == y ;
  char c1 = snd p ;
  char c2 = snd q ;
  println c1 ;
  println c2 ;
  println c1 == c2
end
---------------------------------------------------------------

-- Compiler Output:
-- Warning: input file extension is '' and not '.wacc'. Check you are targeting a WACC program.
-- Compiling...
-- Printing Assembly...
test.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%p\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 5
10		.ascii	"true\0"
11	msg_3:
12		.word 6
13		.ascii	"false\0"
14	msg_4:
15		.word 50
16		.ascii	"NullReferenceError: dereference a null reference\n\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 5
22		.ascii	"%.*s\0"
23	
24	.text
25	
26	.global main
27	main:
28		PUSH {lr}
29		SUB sp, sp, #18
30		LDR r0, =8
31		BL malloc
32		MOV r4, r0
33		LDR r5, =10
34		LDR r0, =4
35		BL malloc
36		STR r5, [r0]
37		STR r0, [r4]
38		MOV r5, #'a'
39		LDR r0, =1
40		BL malloc
41		STRB r5, [r0]
42		STR r0, [r4, #4]
43		STR r4, [sp, #14]
44		LDR r4, [sp, #14]
45		STR r4, [sp, #10]
46		LDR r4, [sp, #14]
47		MOV r0, r4
48		BL p_print_reference
49		BL p_print_ln
50		LDR r4, [sp, #10]
51		MOV r0, r4
52		BL p_print_reference
53		BL p_print_ln
54		LDR r4, [sp, #14]
55		LDR r5, [sp, #10]
56		CMP r4, r5
57		MOVEQ r4, #1
58		MOVNE r4, #0
59		MOV r0, r4
60		BL p_print_bool
61		BL p_print_ln
62		LDR r4, [sp, #14]
63		MOV r0, r4
64		BL p_check_null_pointer
65		LDR r4, [r4]
66		LDR r4, [r4]
67		STR r4, [sp, #6]
68		LDR r4, [sp, #10]
69		MOV r0, r4
70		BL p_check_null_pointer
71		LDR r4, [r4]
72		LDR r4, [r4]
73		STR r4, [sp, #2]
74		LDR r4, [sp, #6]
75		MOV r0, r4
76		BL p_print_int
77		BL p_print_ln
78		LDR r4, [sp, #2]
79		MOV r0, r4
80		BL p_print_int
81		BL p_print_ln
82		LDR r4, [sp, #6]
83		LDR r5, [sp, #2]
84		CMP r4, r5
85		MOVEQ r4, #1
86		MOVNE r4, #0
87		MOV r0, r4
88		BL p_print_bool
89		BL p_print_ln
90		LDR r4, [sp, #14]
91		MOV r0, r4
92		BL p_check_null_pointer
93		LDR r4, [r4, #4]
94		LDRSB r4, [r4]
95		STRB r4, [sp, #1]
96		LDR r4, [sp, #10]
97		MOV r0, r4
98		BL p_check_null_pointer
99		LDR r4, [r4, #4]
100		LDRSB r4, [r4]
101		STRB r4, [sp]
102		LDRSB r4, [sp, #1]
103		MOV r0, r4
104		BL putchar
105		BL p_print_ln
106		LDRSB r4, [sp]
107		MOV r0, r4
108		BL putchar
109		BL p_print_ln
110		LDRSB r4, [sp, #1]
111		LDRSB r5, [sp]
112		CMP r4, r5
113		MOVEQ r4, #1
114		MOVNE r4, #0
115		MOV r0, r4
116		BL p_print_bool
117		BL p_print_ln
118		ADD sp, sp, #18
119		LDR r0, =0
120		POP {pc}
121		.ltorg
122	p_print_reference:
123		PUSH {lr}
124		MOV r1, r0
125		LDR r0, =msg_0
126		ADD r0, r0, #4
127		BL printf
128		MOV r0, #0
129		BL fflush
130		POP {pc}
131	p_print_ln:
132		PUSH {lr}
133		LDR r0, =msg_1
134		ADD r0, r0, #4
135		BL puts
136		MOV r0, #0
137		BL fflush
138		POP {pc}
139	p_print_bool:
140		PUSH {lr}
141		CMP r0, #0
142		LDRNE r0, =msg_2
143		LDREQ r0, =msg_3
144		ADD r0, r0, #4
145		BL printf
146		MOV r0, #0
147		BL fflush
148		POP {pc}
149	p_check_null_pointer:
150		PUSH {lr}
151		CMP r0, #0
152		LDREQ r0, =msg_4
153		BLEQ p_throw_runtime_error
154		POP {pc}
155	p_print_int:
156		PUSH {lr}
157		MOV r1, r0
158		LDR r0, =msg_5
159		ADD r0, r0, #4
160		BL printf
161		MOV r0, #0
162		BL fflush
163		POP {pc}
164	p_throw_runtime_error:
165		BL p_print_string
166		MOV r0, #-1
167		BL exit
168	p_print_string:
169		PUSH {lr}
170		LDR r1, [r0]
171		ADD r2, r0, #4
172		LDR r0, =msg_6
173		ADD r0, r0, #4
174		BL printf
175		MOV r0, #0
176		BL fflush
177		POP {pc}
178	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/createPair.wacc
-- Test: createPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair (int, int)

# Output:
# #empty#

# Program:

begin
  pair(int, int) p = newpair(10, 3)
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
createPair.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r0, =8
7		BL malloc
8		MOV r4, r0
9		LDR r5, =10
10		LDR r0, =4
11		BL malloc
12		STR r5, [r0]
13		STR r0, [r4]
14		LDR r5, =3
15		LDR r0, =4
16		BL malloc
17		STR r5, [r0]
18		STR r0, [r4, #4]
19		STR r4, [sp]
20		ADD sp, sp, #4
21		LDR r0, =0
22		POP {pc}
23		.ltorg
24	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/createPair02.wacc
-- Test: createPair02.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair (char, char)

# Output:
# #empty#

# Program:

begin
  pair(char, char) p = newpair('a', 'b')
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
createPair02.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r0, =8
7		BL malloc
8		MOV r4, r0
9		MOV r5, #'a'
10		LDR r0, =1
11		BL malloc
12		STRB r5, [r0]
13		STR r0, [r4]
14		MOV r5, #'b'
15		LDR r0, =1
16		BL malloc
17		STRB r5, [r0]
18		STR r0, [r4, #4]
19		STR r4, [sp]
20		ADD sp, sp, #4
21		LDR r0, =0
22		POP {pc}
23		.ltorg
24	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/createPair03.wacc
-- Test: createPair03.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair (int, char)

# Output:
# #empty#

# Program:

begin
  pair(int, char) p = newpair(10, 'a')
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
createPair03.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r0, =8
7		BL malloc
8		MOV r4, r0
9		LDR r5, =10
10		LDR r0, =4
11		BL malloc
12		STR r5, [r0]
13		STR r0, [r4]
14		MOV r5, #'a'
15		LDR r0, =1
16		BL malloc
17		STRB r5, [r0]
18		STR r0, [r4, #4]
19		STR r4, [sp]
20		ADD sp, sp, #4
21		LDR r0, =0
22		POP {pc}
23		.ltorg
24	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/createRefPair.wacc
-- Test: createRefPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair(int, char) with a second reference to it

# Output:
# #empty#

# Program:

begin
  pair(int, char) p = newpair(10, 'a') ;
  pair(int, char) q = p
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
createRefPair.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #8
6		LDR r0, =8
7		BL malloc
8		MOV r4, r0
9		LDR r5, =10
10		LDR r0, =4
11		BL malloc
12		STR r5, [r0]
13		STR r0, [r4]
14		MOV r5, #'a'
15		LDR r0, =1
16		BL malloc
17		STRB r5, [r0]
18		STR r0, [r4, #4]
19		STR r4, [sp, #4]
20		LDR r4, [sp, #4]
21		STR r4, [sp]
22		ADD sp, sp, #8
23		LDR r0, =0
24		POP {pc}
25		.ltorg
26	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/free.wacc
-- Test: free.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Create and free a simple pair

# Output:
# #empty#

# Program:

begin
  pair(int, char) a = newpair(10, 'a') ;
  free a
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
free.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r0, =8
16		BL malloc
17		MOV r4, r0
18		LDR r5, =10
19		LDR r0, =4
20		BL malloc
21		STR r5, [r0]
22		STR r0, [r4]
23		MOV r5, #'a'
24		LDR r0, =1
25		BL malloc
26		STRB r5, [r0]
27		STR r0, [r4, #4]
28		STR r4, [sp]
29		LDR r4, [sp]
30		MOV r0, r4
31		BL p_free_pair
32		ADD sp, sp, #4
33		LDR r0, =0
34		POP {pc}
35		.ltorg
36	p_free_pair:
37		PUSH {lr}
38		CMP r0, #0
39		LDREQ r0, =msg_0
40		BEQ p_throw_runtime_error
41		PUSH {r0}
42		LDR r0, [r0]
43		BL free
44		LDR r0, [sp]
45		LDR r0, [r0, #4]
46		BL free
47		POP {r0}
48		BL free
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_1
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/linkedList.wacc
-- Test: linkedList.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create and print a linked list using pairs

# Output:
# list = {1, 2, 4, 11}

# Program:

begin
  pair(int, pair) p = newpair(11, null) ;
    pair(int, pair) q = newpair(4, p) ;
    pair(int, pair) r = newpair(2, q) ;
    pair(int, pair) s = newpair(1, r) ;
    print "list = {" ;
    pair(int, pair) x = s ;
    pair(int, pair) y = snd x ;
    int f = 0;
    while y != null do
      f = fst x ;
      print f ;
      print ", " ;
      x = y ;
      y = snd x
    done ;
    f = fst x ;
    print f ;
    println "}"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
linkedList.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 8
4		.ascii	"list = {"
5	msg_1:
6		.word 2
7		.ascii	", "
8	msg_2:
9		.word 1
10		.ascii	"}"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	msg_4:
15		.word 50
16		.ascii	"NullReferenceError: dereference a null reference\n\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 1
22		.ascii	"\0"
23	
24	.text
25	
26	.global main
27	main:
28		PUSH {lr}
29		SUB sp, sp, #28
30		LDR r0, =8
31		BL malloc
32		MOV r4, r0
33		LDR r5, =11
34		LDR r0, =4
35		BL malloc
36		STR r5, [r0]
37		STR r0, [r4]
38		LDR r5, =0
39		LDR r0, =4
40		BL malloc
41		STR r5, [r0]
42		STR r0, [r4, #4]
43		STR r4, [sp, #24]
44		LDR r0, =8
45		BL malloc
46		MOV r4, r0
47		LDR r5, =4
48		LDR r0, =4
49		BL malloc
50		STR r5, [r0]
51		STR r0, [r4]
52		LDR r5, [sp, #24]
53		LDR r0, =4
54		BL malloc
55		STR r5, [r0]
56		STR r0, [r4, #4]
57		STR r4, [sp, #20]
58		LDR r0, =8
59		BL malloc
60		MOV r4, r0
61		LDR r5, =2
62		LDR r0, =4
63		BL malloc
64		STR r5, [r0]
65		STR r0, [r4]
66		LDR r5, [sp, #20]
67		LDR r0, =4
68		BL malloc
69		STR r5, [r0]
70		STR r0, [r4, #4]
71		STR r4, [sp, #16]
72		LDR r0, =8
73		BL malloc
74		MOV r4, r0
75		LDR r5, =1
76		LDR r0, =4
77		BL malloc
78		STR r5, [r0]
79		STR r0, [r4]
80		LDR r5, [sp, #16]
81		LDR r0, =4
82		BL malloc
83		STR r5, [r0]
84		STR r0, [r4, #4]
85		STR r4, [sp, #12]
86		LDR r4, =msg_0
87		MOV r0, r4
88		BL p_print_string
89		LDR r4, [sp, #12]
90		STR r4, [sp, #8]
91		LDR r4, [sp, #8]
92		MOV r0, r4
93		BL p_check_null_pointer
94		LDR r4, [r4, #4]
95		LDR r4, [r4]
96		STR r4, [sp, #4]
97		LDR r4, =0
98		STR r4, [sp]
99		B L0
100	L1:
101		LDR r4, [sp, #8]
102		MOV r0, r4
103		BL p_check_null_pointer
104		LDR r4, [r4]
105		LDR r4, [r4]
106		STR r4, [sp]
107		LDR r4, [sp]
108		MOV r0, r4
109		BL p_print_int
110		LDR r4, =msg_1
111		MOV r0, r4
112		BL p_print_string
113		LDR r4, [sp, #4]
114		STR r4, [sp, #8]
115		LDR r4, [sp, #8]
116		MOV r0, r4
117		BL p_check_null_pointer
118		LDR r4, [r4, #4]
119		LDR r4, [r4]
120		STR r4, [sp, #4]
121	L0:
122		LDR r4, [sp, #4]
123		LDR r5, =0
124		CMP r4, r5
125		MOVNE r4, #1
126		MOVEQ r4, #0
127		CMP r4, #1
128		BEQ L1
129		LDR r4, [sp, #8]
130		MOV r0, r4
131		BL p_check_null_pointer
132		LDR r4, [r4]
133		LDR r4, [r4]
134		STR r4, [sp]
135		LDR r4, [sp]
136		MOV r0, r4
137		BL p_print_int
138		LDR r4, =msg_2
139		MOV r0, r4
140		BL p_print_string
141		BL p_print_ln
142		ADD sp, sp, #28
143		LDR r0, =0
144		POP {pc}
145		.ltorg
146	p_print_string:
147		PUSH {lr}
148		LDR r1, [r0]
149		ADD r2, r0, #4
150		LDR r0, =msg_3
151		ADD r0, r0, #4
152		BL printf
153		MOV r0, #0
154		BL fflush
155		POP {pc}
156	p_check_null_pointer:
157		PUSH {lr}
158		CMP r0, #0
159		LDREQ r0, =msg_4
160		BLEQ p_throw_runtime_error
161		POP {pc}
162	p_print_int:
163		PUSH {lr}
164		MOV r1, r0
165		LDR r0, =msg_5
166		ADD r0, r0, #4
167		BL printf
168		MOV r0, #0
169		BL fflush
170		POP {pc}
171	p_print_ln:
172		PUSH {lr}
173		LDR r0, =msg_6
174		ADD r0, r0, #4
175		BL puts
176		MOV r0, #0
177		BL fflush
178		POP {pc}
179	p_throw_runtime_error:
180		BL p_print_string
181		MOV r0, #-1
182		BL exit
183	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/nestedPair.wacc
-- Test: nestedPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair (int, pair (int, int) )

# Output:
# #empty#

# Program:

begin
  pair(int, int) p = newpair(2, 3) ;
  pair(int, pair) q = newpair(1, p)
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
nestedPair.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #8
6		LDR r0, =8
7		BL malloc
8		MOV r4, r0
9		LDR r5, =2
10		LDR r0, =4
11		BL malloc
12		STR r5, [r0]
13		STR r0, [r4]
14		LDR r5, =3
15		LDR r0, =4
16		BL malloc
17		STR r5, [r0]
18		STR r0, [r4, #4]
19		STR r4, [sp, #4]
20		LDR r0, =8
21		BL malloc
22		MOV r4, r0
23		LDR r5, =1
24		LDR r0, =4
25		BL malloc
26		STR r5, [r0]
27		STR r0, [r4]
28		LDR r5, [sp, #4]
29		LDR r0, =4
30		BL malloc
31		STR r5, [r0]
32		STR r0, [r4, #4]
33		STR r4, [sp]
34		ADD sp, sp, #8
35		LDR r0, =0
36		POP {pc}
37		.ltorg
38	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/null.wacc
-- Test: null.wacc

-- Uploaded file: 
---------------------------------------------------------------
# null pair assignment

# Output:
# (nil)
# (nil)

# Program:

begin
  pair(pair, pair) p = null ;
  println p ;
  p = null ;
  println p
end


---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
null.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%p\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =0
16		STR r4, [sp]
17		LDR r4, [sp]
18		MOV r0, r4
19		BL p_print_reference
20		BL p_print_ln
21		LDR r4, =0
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_reference
26		BL p_print_ln
27		ADD sp, sp, #4
28		LDR r0, =0
29		POP {pc}
30		.ltorg
31	p_print_reference:
32		PUSH {lr}
33		MOV r1, r0
34		LDR r0, =msg_0
35		ADD r0, r0, #4
36		BL printf
37		MOV r0, #0
38		BL fflush
39		POP {pc}
40	p_print_ln:
41		PUSH {lr}
42		LDR r0, =msg_1
43		ADD r0, r0, #4
44		BL puts
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/printNull.wacc
-- Test: printNull.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print the null reference

# Output:
# (nil)

# Program:

begin
  println null
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printNull.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%p\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		LDR r4, =0
15		MOV r0, r4
16		BL p_print_reference
17		BL p_print_ln
18		LDR r0, =0
19		POP {pc}
20		.ltorg
21	p_print_reference:
22		PUSH {lr}
23		MOV r1, r0
24		LDR r0, =msg_0
25		ADD r0, r0, #4
26		BL printf
27		MOV r0, #0
28		BL fflush
29		POP {pc}
30	p_print_ln:
31		PUSH {lr}
32		LDR r0, =msg_1
33		ADD r0, r0, #4
34		BL puts
35		MOV r0, #0
36		BL fflush
37		POP {pc}
38	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/printNullPair.wacc
-- Test: printNullPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print pair a null pair

# Output:
# (nil)

# Program:

begin
  pair(pair, pair) p = null ;
  println p
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printNullPair.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%p\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =0
16		STR r4, [sp]
17		LDR r4, [sp]
18		MOV r0, r4
19		BL p_print_reference
20		BL p_print_ln
21		ADD sp, sp, #4
22		LDR r0, =0
23		POP {pc}
24		.ltorg
25	p_print_reference:
26		PUSH {lr}
27		MOV r1, r0
28		LDR r0, =msg_0
29		ADD r0, r0, #4
30		BL printf
31		MOV r0, #0
32		BL fflush
33		POP {pc}
34	p_print_ln:
35		PUSH {lr}
36		LDR r0, =msg_1
37		ADD r0, r0, #4
38		BL puts
39		MOV r0, #0
40		BL fflush
41		POP {pc}
42	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/printPair.wacc
-- Test: printPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print pair program

# Output:
# #addrs# = (10, a)

# Program:

begin
  pair(int, char) p = newpair(10, 'a') ;
  print p ; 
  print " = (" ;
  int x = fst p ;
  print x ;
  print ", " ;
  char c = snd p ;
  print c ;
  println ')' 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printPair.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 4
4		.ascii	" = ("
5	msg_1:
6		.word 2
7		.ascii	", "
8	msg_2:
9		.word 3
10		.ascii	"%p\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	msg_4:
15		.word 50
16		.ascii	"NullReferenceError: dereference a null reference\n\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 1
22		.ascii	"\0"
23	
24	.text
25	
26	.global main
27	main:
28		PUSH {lr}
29		SUB sp, sp, #9
30		LDR r0, =8
31		BL malloc
32		MOV r4, r0
33		LDR r5, =10
34		LDR r0, =4
35		BL malloc
36		STR r5, [r0]
37		STR r0, [r4]
38		MOV r5, #'a'
39		LDR r0, =1
40		BL malloc
41		STRB r5, [r0]
42		STR r0, [r4, #4]
43		STR r4, [sp, #5]
44		LDR r4, [sp, #5]
45		MOV r0, r4
46		BL p_print_reference
47		LDR r4, =msg_0
48		MOV r0, r4
49		BL p_print_string
50		LDR r4, [sp, #5]
51		MOV r0, r4
52		BL p_check_null_pointer
53		LDR r4, [r4]
54		LDR r4, [r4]
55		STR r4, [sp, #1]
56		LDR r4, [sp, #1]
57		MOV r0, r4
58		BL p_print_int
59		LDR r4, =msg_1
60		MOV r0, r4
61		BL p_print_string
62		LDR r4, [sp, #5]
63		MOV r0, r4
64		BL p_check_null_pointer
65		LDR r4, [r4, #4]
66		LDRSB r4, [r4]
67		STRB r4, [sp]
68		LDRSB r4, [sp]
69		MOV r0, r4
70		BL putchar
71		MOV r4, #')'
72		MOV r0, r4
73		BL putchar
74		BL p_print_ln
75		ADD sp, sp, #9
76		LDR r0, =0
77		POP {pc}
78		.ltorg
79	p_print_reference:
80		PUSH {lr}
81		MOV r1, r0
82		LDR r0, =msg_2
83		ADD r0, r0, #4
84		BL printf
85		MOV r0, #0
86		BL fflush
87		POP {pc}
88	p_print_string:
89		PUSH {lr}
90		LDR r1, [r0]
91		ADD r2, r0, #4
92		LDR r0, =msg_3
93		ADD r0, r0, #4
94		BL printf
95		MOV r0, #0
96		BL fflush
97		POP {pc}
98	p_check_null_pointer:
99		PUSH {lr}
100		CMP r0, #0
101		LDREQ r0, =msg_4
102		BLEQ p_throw_runtime_error
103		POP {pc}
104	p_print_int:
105		PUSH {lr}
106		MOV r1, r0
107		LDR r0, =msg_5
108		ADD r0, r0, #4
109		BL printf
110		MOV r0, #0
111		BL fflush
112		POP {pc}
113	p_print_ln:
114		PUSH {lr}
115		LDR r0, =msg_6
116		ADD r0, r0, #4
117		BL puts
118		MOV r0, #0
119		BL fflush
120		POP {pc}
121	p_throw_runtime_error:
122		BL p_print_string
123		MOV r0, #-1
124		BL exit
125	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/printPairOfNulls.wacc
-- Test: printPairOfNulls.wacc

-- Uploaded file: 
---------------------------------------------------------------
# print a pair of null pairs 

# Output:
# #addrs# = ((nil),(nil))

# Program:

begin
  pair(pair, pair) p = newpair(null, null) ;
  print p ;
  print " = (" ;
  pair(pair, pair) q = fst p ;
  print q ;
  print "," ;
  pair(int, bool) r = snd p ;
  print r ; 
  println ")"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printPairOfNulls.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 4
4		.ascii	" = ("
5	msg_1:
6		.word 1
7		.ascii	","
8	msg_2:
9		.word 1
10		.ascii	")"
11	msg_3:
12		.word 3
13		.ascii	"%p\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 50
19		.ascii	"NullReferenceError: dereference a null reference\n\0"
20	msg_6:
21		.word 1
22		.ascii	"\0"
23	
24	.text
25	
26	.global main
27	main:
28		PUSH {lr}
29		SUB sp, sp, #12
30		LDR r0, =8
31		BL malloc
32		MOV r4, r0
33		LDR r5, =0
34		LDR r0, =4
35		BL malloc
36		STR r5, [r0]
37		STR r0, [r4]
38		LDR r5, =0
39		LDR r0, =4
40		BL malloc
41		STR r5, [r0]
42		STR r0, [r4, #4]
43		STR r4, [sp, #8]
44		LDR r4, [sp, #8]
45		MOV r0, r4
46		BL p_print_reference
47		LDR r4, =msg_0
48		MOV r0, r4
49		BL p_print_string
50		LDR r4, [sp, #8]
51		MOV r0, r4
52		BL p_check_null_pointer
53		LDR r4, [r4]
54		LDR r4, [r4]
55		STR r4, [sp, #4]
56		LDR r4, [sp, #4]
57		MOV r0, r4
58		BL p_print_reference
59		LDR r4, =msg_1
60		MOV r0, r4
61		BL p_print_string
62		LDR r4, [sp, #8]
63		MOV r0, r4
64		BL p_check_null_pointer
65		LDR r4, [r4, #4]
66		LDR r4, [r4]
67		STR r4, [sp]
68		LDR r4, [sp]
69		MOV r0, r4
70		BL p_print_reference
71		LDR r4, =msg_2
72		MOV r0, r4
73		BL p_print_string
74		BL p_print_ln
75		ADD sp, sp, #12
76		LDR r0, =0
77		POP {pc}
78		.ltorg
79	p_print_reference:
80		PUSH {lr}
81		MOV r1, r0
82		LDR r0, =msg_3
83		ADD r0, r0, #4
84		BL printf
85		MOV r0, #0
86		BL fflush
87		POP {pc}
88	p_print_string:
89		PUSH {lr}
90		LDR r1, [r0]
91		ADD r2, r0, #4
92		LDR r0, =msg_4
93		ADD r0, r0, #4
94		BL printf
95		MOV r0, #0
96		BL fflush
97		POP {pc}
98	p_check_null_pointer:
99		PUSH {lr}
100		CMP r0, #0
101		LDREQ r0, =msg_5
102		BLEQ p_throw_runtime_error
103		POP {pc}
104	p_print_ln:
105		PUSH {lr}
106		LDR r0, =msg_6
107		ADD r0, r0, #4
108		BL puts
109		MOV r0, #0
110		BL fflush
111		POP {pc}
112	p_throw_runtime_error:
113		BL p_print_string
114		MOV r0, #-1
115		BL exit
116	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/readPair.wacc
-- Test: readPair.wacc

-- Uploaded file: 
---------------------------------------------------------------
# construct a pair from supplied user input

# Output:
# Please enter the first element (char): #input#
# Please enter the second element (int): #input#
# The first element was #output#
# The second element was #output#

# Program:

begin
	pair(char, int) p = newpair('\0', 0) ;
	print "Please enter the first element (char): " ;
  	char c = '0';
	read c ;
  	fst p = c ;
	print "Please enter the second element (int): " ;
	int i = 0 ;
	read i ;
	snd p = i ;
	# Clear the value for c and i
	c = '\0' ;
	i = -1 ;
	print "The first element was " ;
	c = fst p ;
	println c ;
	print "The second element was " ;
	i = snd p ;
	println i 
end 
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
readPair.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 39
4		.ascii	"Please enter the first element (char): "
5	msg_1:
6		.word 39
7		.ascii	"Please enter the second element (int): "
8	msg_2:
9		.word 22
10		.ascii	"The first element was "
11	msg_3:
12		.word 23
13		.ascii	"The second element was "
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 4
19		.ascii	" %c\0"
20	msg_6:
21		.word 50
22		.ascii	"NullReferenceError: dereference a null reference\n\0"
23	msg_7:
24		.word 3
25		.ascii	"%d\0"
26	msg_8:
27		.word 1
28		.ascii	"\0"
29	msg_9:
30		.word 3
31		.ascii	"%d\0"
32	
33	.text
34	
35	.global main
36	main:
37		PUSH {lr}
38		SUB sp, sp, #9
39		LDR r0, =8
40		BL malloc
41		MOV r4, r0
42		MOV r5, #0
43		LDR r0, =1
44		BL malloc
45		STRB r5, [r0]
46		STR r0, [r4]
47		LDR r5, =0
48		LDR r0, =4
49		BL malloc
50		STR r5, [r0]
51		STR r0, [r4, #4]
52		STR r4, [sp, #5]
53		LDR r4, =msg_0
54		MOV r0, r4
55		BL p_print_string
56		MOV r4, #'0'
57		STRB r4, [sp, #4]
58		ADD r4, sp, #4
59		MOV r0, r4
60		BL p_read_char
61		LDRSB r4, [sp, #4]
62		LDR r5, [sp, #5]
63		MOV r0, r5
64		BL p_check_null_pointer
65		LDR r5, [r5]
66		STRB r4, [r5]
67		LDR r4, =msg_1
68		MOV r0, r4
69		BL p_print_string
70		LDR r4, =0
71		STR r4, [sp]
72		ADD r4, sp, #0
73		MOV r0, r4
74		BL p_read_int
75		LDR r4, [sp]
76		LDR r5, [sp, #5]
77		MOV r0, r5
78		BL p_check_null_pointer
79		LDR r5, [r5, #4]
80		STR r4, [r5]
81		MOV r4, #0
82		STRB r4, [sp, #4]
83		LDR r4, =-1
84		STR r4, [sp]
85		LDR r4, =msg_2
86		MOV r0, r4
87		BL p_print_string
88		LDR r4, [sp, #5]
89		MOV r0, r4
90		BL p_check_null_pointer
91		LDR r4, [r4]
92		LDRSB r4, [r4]
93		STRB r4, [sp, #4]
94		LDRSB r4, [sp, #4]
95		MOV r0, r4
96		BL putchar
97		BL p_print_ln
98		LDR r4, =msg_3
99		MOV r0, r4
100		BL p_print_string
101		LDR r4, [sp, #5]
102		MOV r0, r4
103		BL p_check_null_pointer
104		LDR r4, [r4, #4]
105		LDR r4, [r4]
106		STR r4, [sp]
107		LDR r4, [sp]
108		MOV r0, r4
109		BL p_print_int
110		BL p_print_ln
111		ADD sp, sp, #9
112		LDR r0, =0
113		POP {pc}
114		.ltorg
115	p_print_string:
116		PUSH {lr}
117		LDR r1, [r0]
118		ADD r2, r0, #4
119		LDR r0, =msg_4
120		ADD r0, r0, #4
121		BL printf
122		MOV r0, #0
123		BL fflush
124		POP {pc}
125	p_read_char:
126		PUSH {lr}
127		MOV r1, r0
128		LDR r0, =msg_5
129		ADD r0, r0, #4
130		BL scanf
131		POP {pc}
132	p_check_null_pointer:
133		PUSH {lr}
134		CMP r0, #0
135		LDREQ r0, =msg_6
136		BLEQ p_throw_runtime_error
137		POP {pc}
138	p_read_int:
139		PUSH {lr}
140		MOV r1, r0
141		LDR r0, =msg_7
142		ADD r0, r0, #4
143		BL scanf
144		POP {pc}
145	p_print_ln:
146		PUSH {lr}
147		LDR r0, =msg_8
148		ADD r0, r0, #4
149		BL puts
150		MOV r0, #0
151		BL fflush
152		POP {pc}
153	p_print_int:
154		PUSH {lr}
155		MOV r1, r0
156		LDR r0, =msg_9
157		ADD r0, r0, #4
158		BL printf
159		MOV r0, #0
160		BL fflush
161		POP {pc}
162	p_throw_runtime_error:
163		BL p_print_string
164		MOV r0, #-1
165		BL exit
166	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/writeFst.wacc
-- Test: writeFst.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair and write to its first element

# Output:
# 10
# 42

# Program:

begin
  pair(int, char) p = newpair(10, 'a') ;
  int f = fst p ;
  println f ;
  fst p = 42 ;
  f = fst p ;
  println f
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
writeFst.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #8
21		LDR r0, =8
22		BL malloc
23		MOV r4, r0
24		LDR r5, =10
25		LDR r0, =4
26		BL malloc
27		STR r5, [r0]
28		STR r0, [r4]
29		MOV r5, #'a'
30		LDR r0, =1
31		BL malloc
32		STRB r5, [r0]
33		STR r0, [r4, #4]
34		STR r4, [sp, #4]
35		LDR r4, [sp, #4]
36		MOV r0, r4
37		BL p_check_null_pointer
38		LDR r4, [r4]
39		LDR r4, [r4]
40		STR r4, [sp]
41		LDR r4, [sp]
42		MOV r0, r4
43		BL p_print_int
44		BL p_print_ln
45		LDR r4, =42
46		LDR r5, [sp, #4]
47		MOV r0, r5
48		BL p_check_null_pointer
49		LDR r5, [r5]
50		STR r4, [r5]
51		LDR r4, [sp, #4]
52		MOV r0, r4
53		BL p_check_null_pointer
54		LDR r4, [r4]
55		LDR r4, [r4]
56		STR r4, [sp]
57		LDR r4, [sp]
58		MOV r0, r4
59		BL p_print_int
60		BL p_print_ln
61		ADD sp, sp, #8
62		LDR r0, =0
63		POP {pc}
64		.ltorg
65	p_check_null_pointer:
66		PUSH {lr}
67		CMP r0, #0
68		LDREQ r0, =msg_0
69		BLEQ p_throw_runtime_error
70		POP {pc}
71	p_print_int:
72		PUSH {lr}
73		MOV r1, r0
74		LDR r0, =msg_1
75		ADD r0, r0, #4
76		BL printf
77		MOV r0, #0
78		BL fflush
79		POP {pc}
80	p_print_ln:
81		PUSH {lr}
82		LDR r0, =msg_2
83		ADD r0, r0, #4
84		BL puts
85		MOV r0, #0
86		BL fflush
87		POP {pc}
88	p_throw_runtime_error:
89		BL p_print_string
90		MOV r0, #-1
91		BL exit
92	p_print_string:
93		PUSH {lr}
94		LDR r1, [r0]
95		ADD r2, r0, #4
96		LDR r0, =msg_3
97		ADD r0, r0, #4
98		BL printf
99		MOV r0, #0
100		BL fflush
101		POP {pc}
102	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/pairs/writeSnd.wacc
-- Test: writeSnd.wacc

-- Uploaded file: 
---------------------------------------------------------------
# create a pair and write to its second element

# Output:
# a
# Z

# Program:

begin
  pair(int, char) p = newpair(10, 'a') ;
  char s = snd p ;
  println s ;
  snd p = 'Z' ;
  s = snd p ;
  println s
end
---------------------------------------------------------------

-- Compiler Output:
-- Warning: input file extension is '' and not '.wacc'. Check you are targeting a WACC program.
-- Compiling...
-- Printing Assembly...
test.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #5
18		LDR r0, =8
19		BL malloc
20		MOV r4, r0
21		LDR r5, =10
22		LDR r0, =4
23		BL malloc
24		STR r5, [r0]
25		STR r0, [r4]
26		MOV r5, #'a'
27		LDR r0, =1
28		BL malloc
29		STRB r5, [r0]
30		STR r0, [r4, #4]
31		STR r4, [sp, #1]
32		LDR r4, [sp, #1]
33		MOV r0, r4
34		BL p_check_null_pointer
35		LDR r4, [r4, #4]
36		LDRSB r4, [r4]
37		STRB r4, [sp]
38		LDRSB r4, [sp]
39		MOV r0, r4
40		BL putchar
41		BL p_print_ln
42		MOV r4, #'Z'
43		LDR r5, [sp, #1]
44		MOV r0, r5
45		BL p_check_null_pointer
46		LDR r5, [r5, #4]
47		STRB r4, [r5]
48		LDR r4, [sp, #1]
49		MOV r0, r4
50		BL p_check_null_pointer
51		LDR r4, [r4, #4]
52		LDRSB r4, [r4]
53		STRB r4, [sp]
54		LDRSB r4, [sp]
55		MOV r0, r4
56		BL putchar
57		BL p_print_ln
58		ADD sp, sp, #5
59		LDR r0, =0
60		POP {pc}
61		.ltorg
62	p_check_null_pointer:
63		PUSH {lr}
64		CMP r0, #0
65		LDREQ r0, =msg_0
66		BLEQ p_throw_runtime_error
67		POP {pc}
68	p_print_ln:
69		PUSH {lr}
70		LDR r0, =msg_1
71		ADD r0, r0, #4
72		BL puts
73		MOV r0, #0
74		BL fflush
75		POP {pc}
76	p_throw_runtime_error:
77		BL p_print_string
78		MOV r0, #-1
79		BL exit
80	p_print_string:
81		PUSH {lr}
82		LDR r1, [r0]
83		ADD r2, r0, #4
84		LDR r0, =msg_2
85		ADD r0, r0, #4
86		BL printf
87		MOV r0, #0
88		BL fflush
89		POP {pc}
90	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/arrayOutOfBounds/arrayNegBounds.wacc
-- Test: arrayNegBounds.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt out of bounds array access (this ought to seg fault or similar)

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	int[] a = [43, 2, 18, 1] ;
  int[] b = [1, 2, 3] ;	
  println a[-2]
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayNegBounds.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 44
4		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
5	msg_1:
6		.word 45
7		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #8
24		LDR r0, =20
25		BL malloc
26		MOV r4, r0
27		LDR r5, =43
28		STR r5, [r4, #4]
29		LDR r5, =2
30		STR r5, [r4, #8]
31		LDR r5, =18
32		STR r5, [r4, #12]
33		LDR r5, =1
34		STR r5, [r4, #16]
35		LDR r5, =4
36		STR r5, [r4]
37		STR r4, [sp, #4]
38		LDR r0, =16
39		BL malloc
40		MOV r4, r0
41		LDR r5, =1
42		STR r5, [r4, #4]
43		LDR r5, =2
44		STR r5, [r4, #8]
45		LDR r5, =3
46		STR r5, [r4, #12]
47		LDR r5, =3
48		STR r5, [r4]
49		STR r4, [sp]
50		ADD r4, sp, #4
51		LDR r5, =-2
52		LDR r4, [r4]
53		MOV r0, r5
54		MOV r1, r4
55		BL p_check_array_bounds
56		ADD r4, r4, #4
57		ADD r4, r4, r5, LSL #2
58		LDR r4, [r4]
59		MOV r0, r4
60		BL p_print_int
61		BL p_print_ln
62		ADD sp, sp, #8
63		LDR r0, =0
64		POP {pc}
65		.ltorg
66	p_check_array_bounds:
67		PUSH {lr}
68		CMP r0, #0
69		LDRLT r0, =msg_0
70		BLLT p_throw_runtime_error
71		LDR r1, [r1]
72		CMP r0, r1
73		LDRCS r0, =msg_1
74		BLCS p_throw_runtime_error
75		POP {pc}
76	p_print_int:
77		PUSH {lr}
78		MOV r1, r0
79		LDR r0, =msg_2
80		ADD r0, r0, #4
81		BL printf
82		MOV r0, #0
83		BL fflush
84		POP {pc}
85	p_print_ln:
86		PUSH {lr}
87		LDR r0, =msg_3
88		ADD r0, r0, #4
89		BL puts
90		MOV r0, #0
91		BL fflush
92		POP {pc}
93	p_throw_runtime_error:
94		BL p_print_string
95		MOV r0, #-1
96		BL exit
97	p_print_string:
98		PUSH {lr}
99		LDR r1, [r0]
100		ADD r2, r0, #4
101		LDR r0, =msg_4
102		ADD r0, r0, #4
103		BL printf
104		MOV r0, #0
105		BL fflush
106		POP {pc}
107	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/arrayOutOfBounds/arrayOutOfBounds.wacc
-- Test: arrayOutOfBounds.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt out of bounds array access (this ought to seg fault or similar)

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin

  int[] b = [1, 2, 3] ;
	int[] a = [43, 2, 18, 1] ;
	println a[5]
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayOutOfBounds.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 44
4		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
5	msg_1:
6		.word 45
7		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #8
24		LDR r0, =16
25		BL malloc
26		MOV r4, r0
27		LDR r5, =1
28		STR r5, [r4, #4]
29		LDR r5, =2
30		STR r5, [r4, #8]
31		LDR r5, =3
32		STR r5, [r4, #12]
33		LDR r5, =3
34		STR r5, [r4]
35		STR r4, [sp, #4]
36		LDR r0, =20
37		BL malloc
38		MOV r4, r0
39		LDR r5, =43
40		STR r5, [r4, #4]
41		LDR r5, =2
42		STR r5, [r4, #8]
43		LDR r5, =18
44		STR r5, [r4, #12]
45		LDR r5, =1
46		STR r5, [r4, #16]
47		LDR r5, =4
48		STR r5, [r4]
49		STR r4, [sp]
50		ADD r4, sp, #0
51		LDR r5, =5
52		LDR r4, [r4]
53		MOV r0, r5
54		MOV r1, r4
55		BL p_check_array_bounds
56		ADD r4, r4, #4
57		ADD r4, r4, r5, LSL #2
58		LDR r4, [r4]
59		MOV r0, r4
60		BL p_print_int
61		BL p_print_ln
62		ADD sp, sp, #8
63		LDR r0, =0
64		POP {pc}
65		.ltorg
66	p_check_array_bounds:
67		PUSH {lr}
68		CMP r0, #0
69		LDRLT r0, =msg_0
70		BLLT p_throw_runtime_error
71		LDR r1, [r1]
72		CMP r0, r1
73		LDRCS r0, =msg_1
74		BLCS p_throw_runtime_error
75		POP {pc}
76	p_print_int:
77		PUSH {lr}
78		MOV r1, r0
79		LDR r0, =msg_2
80		ADD r0, r0, #4
81		BL printf
82		MOV r0, #0
83		BL fflush
84		POP {pc}
85	p_print_ln:
86		PUSH {lr}
87		LDR r0, =msg_3
88		ADD r0, r0, #4
89		BL puts
90		MOV r0, #0
91		BL fflush
92		POP {pc}
93	p_throw_runtime_error:
94		BL p_print_string
95		MOV r0, #-1
96		BL exit
97	p_print_string:
98		PUSH {lr}
99		LDR r1, [r0]
100		ADD r2, r0, #4
101		LDR r0, =msg_4
102		ADD r0, r0, #4
103		BL printf
104		MOV r0, #0
105		BL fflush
106		POP {pc}
107	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/arrayOutOfBounds/arrayOutOfBoundsWrite.wacc
-- Test: arrayOutOfBoundsWrite.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt write out of array bounds (gods, this really should not work!)

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin

  int[] b = [1, 2, 3] ;
	int[] a = [43, 2, 18, 1] ;
	a[5] = 100 ;
  println a[5]
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
arrayOutOfBoundsWrite.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 44
4		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
5	msg_1:
6		.word 45
7		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
8	msg_2:
9		.word 3
10		.ascii	"%d\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #8
24		LDR r0, =16
25		BL malloc
26		MOV r4, r0
27		LDR r5, =1
28		STR r5, [r4, #4]
29		LDR r5, =2
30		STR r5, [r4, #8]
31		LDR r5, =3
32		STR r5, [r4, #12]
33		LDR r5, =3
34		STR r5, [r4]
35		STR r4, [sp, #4]
36		LDR r0, =20
37		BL malloc
38		MOV r4, r0
39		LDR r5, =43
40		STR r5, [r4, #4]
41		LDR r5, =2
42		STR r5, [r4, #8]
43		LDR r5, =18
44		STR r5, [r4, #12]
45		LDR r5, =1
46		STR r5, [r4, #16]
47		LDR r5, =4
48		STR r5, [r4]
49		STR r4, [sp]
50		LDR r4, =100
51		ADD r5, sp, #0
52		LDR r6, =5
53		LDR r5, [r5]
54		MOV r0, r6
55		MOV r1, r5
56		BL p_check_array_bounds
57		ADD r5, r5, #4
58		ADD r5, r5, r6, LSL #2
59		STR r4, [r5]
60		ADD r4, sp, #0
61		LDR r6, =5
62		LDR r4, [r4]
63		MOV r0, r6
64		MOV r1, r4
65		BL p_check_array_bounds
66		ADD r4, r4, #4
67		ADD r4, r4, r6, LSL #2
68		LDR r4, [r4]
69		MOV r0, r4
70		BL p_print_int
71		BL p_print_ln
72		ADD sp, sp, #8
73		LDR r0, =0
74		POP {pc}
75		.ltorg
76	p_check_array_bounds:
77		PUSH {lr}
78		CMP r0, #0
79		LDRLT r0, =msg_0
80		BLLT p_throw_runtime_error
81		LDR r1, [r1]
82		CMP r0, r1
83		LDRCS r0, =msg_1
84		BLCS p_throw_runtime_error
85		POP {pc}
86	p_print_int:
87		PUSH {lr}
88		MOV r1, r0
89		LDR r0, =msg_2
90		ADD r0, r0, #4
91		BL printf
92		MOV r0, #0
93		BL fflush
94		POP {pc}
95	p_print_ln:
96		PUSH {lr}
97		LDR r0, =msg_3
98		ADD r0, r0, #4
99		BL puts
100		MOV r0, #0
101		BL fflush
102		POP {pc}
103	p_throw_runtime_error:
104		BL p_print_string
105		MOV r0, #-1
106		BL exit
107	p_print_string:
108		PUSH {lr}
109		LDR r1, [r0]
110		ADD r2, r0, #4
111		LDR r0, =msg_4
112		ADD r0, r0, #4
113		BL printf
114		MOV r0, #0
115		BL fflush
116		POP {pc}
117	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/divideByZero/divideByZero.wacc
-- Test: divideByZero.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt divide by zero

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	int x = 10 ;
	int y = 0 ;
	print x / y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
divideByZero.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #8
18		LDR r4, =10
19		STR r4, [sp, #4]
20		LDR r4, =0
21		STR r4, [sp]
22		LDR r4, [sp, #4]
23		LDR r5, [sp]
24		MOV r0, r4
25		MOV r1, r5
26		BL p_check_divide_by_zero
27		BL __aeabi_idiv
28		MOV r4, r0
29		MOV r0, r4
30		BL p_print_int
31		ADD sp, sp, #8
32		LDR r0, =0
33		POP {pc}
34		.ltorg
35	p_check_divide_by_zero:
36		PUSH {lr}
37		CMP r1, #0
38		LDREQ r0, =msg_0
39		BLEQ p_throw_runtime_error
40		POP {pc}
41	p_print_int:
42		PUSH {lr}
43		MOV r1, r0
44		LDR r0, =msg_1
45		ADD r0, r0, #4
46		BL printf
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_2
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/divideByZero/divZero.wacc
-- Test: divZero.wacc

-- Uploaded file: 
---------------------------------------------------------------
# division by zero

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = 10 / 0 ;
  println "should not reach here"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
divZero.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 21
4		.ascii	"should not reach here"
5	msg_1:
6		.word 45
7		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =10
22		LDR r5, =0
23		MOV r0, r4
24		MOV r1, r5
25		BL p_check_divide_by_zero
26		BL __aeabi_idiv
27		MOV r4, r0
28		STR r4, [sp]
29		LDR r4, =msg_0
30		MOV r0, r4
31		BL p_print_string
32		BL p_print_ln
33		ADD sp, sp, #4
34		LDR r0, =0
35		POP {pc}
36		.ltorg
37	p_check_divide_by_zero:
38		PUSH {lr}
39		CMP r1, #0
40		LDREQ r0, =msg_1
41		BLEQ p_throw_runtime_error
42		POP {pc}
43	p_print_string:
44		PUSH {lr}
45		LDR r1, [r0]
46		ADD r2, r0, #4
47		LDR r0, =msg_2
48		ADD r0, r0, #4
49		BL printf
50		MOV r0, #0
51		BL fflush
52		POP {pc}
53	p_print_ln:
54		PUSH {lr}
55		LDR r0, =msg_3
56		ADD r0, r0, #4
57		BL puts
58		MOV r0, #0
59		BL fflush
60		POP {pc}
61	p_throw_runtime_error:
62		BL p_print_string
63		MOV r0, #-1
64		BL exit
65	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/divideByZero/modByZero.wacc
-- Test: modByZero.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt modulo by zero

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	int x = 10 ;
	int y = 0 ;
	print x % y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
modByZero.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 45
4		.ascii	"DivideByZeroError: divide or modulo by zero\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #8
18		LDR r4, =10
19		STR r4, [sp, #4]
20		LDR r4, =0
21		STR r4, [sp]
22		LDR r4, [sp, #4]
23		LDR r5, [sp]
24		MOV r0, r4
25		MOV r1, r5
26		BL p_check_divide_by_zero
27		BL __aeabi_idivmod
28		MOV r4, r1
29		MOV r0, r4
30		BL p_print_int
31		ADD sp, sp, #8
32		LDR r0, =0
33		POP {pc}
34		.ltorg
35	p_check_divide_by_zero:
36		PUSH {lr}
37		CMP r1, #0
38		LDREQ r0, =msg_0
39		BLEQ p_throw_runtime_error
40		POP {pc}
41	p_print_int:
42		PUSH {lr}
43		MOV r1, r0
44		LDR r0, =msg_1
45		ADD r0, r0, #4
46		BL printf
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_throw_runtime_error:
51		BL p_print_string
52		MOV r0, #-1
53		BL exit
54	p_print_string:
55		PUSH {lr}
56		LDR r1, [r0]
57		ADD r2, r0, #4
58		LDR r0, =msg_2
59		ADD r0, r0, #4
60		BL printf
61		MOV r0, #0
62		BL fflush
63		POP {pc}
64	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intJustOverflow.wacc
-- Test: intJustOverflow.wacc

-- Uploaded file: 
---------------------------------------------------------------
# integer overflow

# Output:
# 2147483646
# 2147483647
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = 2147483646 ;
  println x ;
  x = x + 1 ;
  println x ;
  x = x + 1 ; #err here?
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intJustOverflow.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =2147483646
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =1
29		ADDS r4, r4, r5
30		BLVS p_throw_overflow_error
31		STR r4, [sp]
32		LDR r4, [sp]
33		MOV r0, r4
34		BL p_print_int
35		BL p_print_ln
36		LDR r4, [sp]
37		LDR r5, =1
38		ADDS r4, r4, r5
39		BLVS p_throw_overflow_error
40		STR r4, [sp]
41		LDR r4, [sp]
42		MOV r0, r4
43		BL p_print_int
44		BL p_print_ln
45		ADD sp, sp, #4
46		LDR r0, =0
47		POP {pc}
48		.ltorg
49	p_print_int:
50		PUSH {lr}
51		MOV r1, r0
52		LDR r0, =msg_0
53		ADD r0, r0, #4
54		BL printf
55		MOV r0, #0
56		BL fflush
57		POP {pc}
58	p_print_ln:
59		PUSH {lr}
60		LDR r0, =msg_1
61		ADD r0, r0, #4
62		BL puts
63		MOV r0, #0
64		BL fflush
65		POP {pc}
66	p_throw_overflow_error:
67		LDR r0, =msg_2
68		BL p_throw_runtime_error
69	p_throw_runtime_error:
70		BL p_print_string
71		MOV r0, #-1
72		BL exit
73	p_print_string:
74		PUSH {lr}
75		LDR r1, [r0]
76		ADD r2, r0, #4
77		LDR r0, =msg_3
78		ADD r0, r0, #4
79		BL printf
80		MOV r0, #0
81		BL fflush
82		POP {pc}
83	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intmultOverflow.wacc
-- Test: intmultOverflow.wacc

-- Uploaded file: 
---------------------------------------------------------------
# integer overflow - generates odd assembly error!

# Output:
# 2147483
# 2147483000
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = 2147483 ;
  println x ;
  x = x * 1000 ;
  println x ;
  x = x * 1000 ;
  println x ;
  x = x * 1000 ; #err here?
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intmultOverflow.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =2147483
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =1000
29		SMULL r4, r5, r4, r5
30		CMP r5, r4, ASR #31
31		BLNE p_throw_overflow_error
32		STR r4, [sp]
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		LDR r4, [sp]
38		LDR r5, =1000
39		SMULL r4, r5, r4, r5
40		CMP r5, r4, ASR #31
41		BLNE p_throw_overflow_error
42		STR r4, [sp]
43		LDR r4, [sp]
44		MOV r0, r4
45		BL p_print_int
46		BL p_print_ln
47		LDR r4, [sp]
48		LDR r5, =1000
49		SMULL r4, r5, r4, r5
50		CMP r5, r4, ASR #31
51		BLNE p_throw_overflow_error
52		STR r4, [sp]
53		LDR r4, [sp]
54		MOV r0, r4
55		BL p_print_int
56		BL p_print_ln
57		ADD sp, sp, #4
58		LDR r0, =0
59		POP {pc}
60		.ltorg
61	p_print_int:
62		PUSH {lr}
63		MOV r1, r0
64		LDR r0, =msg_0
65		ADD r0, r0, #4
66		BL printf
67		MOV r0, #0
68		BL fflush
69		POP {pc}
70	p_print_ln:
71		PUSH {lr}
72		LDR r0, =msg_1
73		ADD r0, r0, #4
74		BL puts
75		MOV r0, #0
76		BL fflush
77		POP {pc}
78	p_throw_overflow_error:
79		LDR r0, =msg_2
80		BL p_throw_runtime_error
81	p_throw_runtime_error:
82		BL p_print_string
83		MOV r0, #-1
84		BL exit
85	p_print_string:
86		PUSH {lr}
87		LDR r1, [r0]
88		ADD r2, r0, #4
89		LDR r0, =msg_3
90		ADD r0, r0, #4
91		BL printf
92		MOV r0, #0
93		BL fflush
94		POP {pc}
95	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intnegateOverflow.wacc
-- Test: intnegateOverflow.wacc

-- Uploaded file: 
---------------------------------------------------------------
# negating biggest possible negative integer

# Output:
# -2147483648
# #runtime_error#

# Exit:
# 255 

# Program:

begin
  int x = -2147483648 ;
  println x ;
  x = -x; #err here?
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intnegateOverflow.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =-2147483648
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		RSBS r4, r4, #0
29		BLVS p_throw_overflow_error
30		STR r4, [sp]
31		LDR r4, [sp]
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #4
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_print_int:
40		PUSH {lr}
41		MOV r1, r0
42		LDR r0, =msg_0
43		ADD r0, r0, #4
44		BL printf
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	p_print_ln:
49		PUSH {lr}
50		LDR r0, =msg_1
51		ADD r0, r0, #4
52		BL puts
53		MOV r0, #0
54		BL fflush
55		POP {pc}
56	p_throw_overflow_error:
57		LDR r0, =msg_2
58		BL p_throw_runtime_error
59	p_throw_runtime_error:
60		BL p_print_string
61		MOV r0, #-1
62		BL exit
63	p_print_string:
64		PUSH {lr}
65		LDR r1, [r0]
66		ADD r2, r0, #4
67		LDR r0, =msg_3
68		ADD r0, r0, #4
69		BL printf
70		MOV r0, #0
71		BL fflush
72		POP {pc}
73	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intnegateOverflow2.wacc
-- Test: intnegateOverflow2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# multiplying the biggest possible negative integer

# Output:
# -2147483648
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = -2147483648 ;
  println x ;
  x = x*10; #err here?
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intnegateOverflow2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =-2147483648
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =10
29		SMULL r4, r5, r4, r5
30		CMP r5, r4, ASR #31
31		BLNE p_throw_overflow_error
32		STR r4, [sp]
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_int:
42		PUSH {lr}
43		MOV r1, r0
44		LDR r0, =msg_0
45		ADD r0, r0, #4
46		BL printf
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_print_ln:
51		PUSH {lr}
52		LDR r0, =msg_1
53		ADD r0, r0, #4
54		BL puts
55		MOV r0, #0
56		BL fflush
57		POP {pc}
58	p_throw_overflow_error:
59		LDR r0, =msg_2
60		BL p_throw_runtime_error
61	p_throw_runtime_error:
62		BL p_print_string
63		MOV r0, #-1
64		BL exit
65	p_print_string:
66		PUSH {lr}
67		LDR r1, [r0]
68		ADD r2, r0, #4
69		LDR r0, =msg_3
70		ADD r0, r0, #4
71		BL printf
72		MOV r0, #0
73		BL fflush
74		POP {pc}
75	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intnegateOverflow3.wacc
-- Test: intnegateOverflow3.wacc

-- Uploaded file: 
---------------------------------------------------------------
# multiplying a negative integer

# Output:
# -20000
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = -20000 ;
  println x ;
  x = x*100000000; #err here? 
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intnegateOverflow3.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =-20000
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =100000000
29		SMULL r4, r5, r4, r5
30		CMP r5, r4, ASR #31
31		BLNE p_throw_overflow_error
32		STR r4, [sp]
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_int:
42		PUSH {lr}
43		MOV r1, r0
44		LDR r0, =msg_0
45		ADD r0, r0, #4
46		BL printf
47		MOV r0, #0
48		BL fflush
49		POP {pc}
50	p_print_ln:
51		PUSH {lr}
52		LDR r0, =msg_1
53		ADD r0, r0, #4
54		BL puts
55		MOV r0, #0
56		BL fflush
57		POP {pc}
58	p_throw_overflow_error:
59		LDR r0, =msg_2
60		BL p_throw_runtime_error
61	p_throw_runtime_error:
62		BL p_print_string
63		MOV r0, #-1
64		BL exit
65	p_print_string:
66		PUSH {lr}
67		LDR r1, [r0]
68		ADD r2, r0, #4
69		LDR r0, =msg_3
70		ADD r0, r0, #4
71		BL printf
72		MOV r0, #0
73		BL fflush
74		POP {pc}
75	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intnegateOverflow4.wacc
-- Test: intnegateOverflow4.wacc

-- Uploaded file: 
---------------------------------------------------------------
# negative overflow

# Output:
# -2000000000
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = -2000000000 ;
  println x ;
  x = x - 2000000000; #err here? 
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intnegateOverflow4.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =-2000000000
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =2000000000
29		SUBS r4, r4, r5
30		BLVS p_throw_overflow_error
31		STR r4, [sp]
32		LDR r4, [sp]
33		MOV r0, r4
34		BL p_print_int
35		BL p_print_ln
36		ADD sp, sp, #4
37		LDR r0, =0
38		POP {pc}
39		.ltorg
40	p_print_int:
41		PUSH {lr}
42		MOV r1, r0
43		LDR r0, =msg_0
44		ADD r0, r0, #4
45		BL printf
46		MOV r0, #0
47		BL fflush
48		POP {pc}
49	p_print_ln:
50		PUSH {lr}
51		LDR r0, =msg_1
52		ADD r0, r0, #4
53		BL puts
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_throw_overflow_error:
58		LDR r0, =msg_2
59		BL p_throw_runtime_error
60	p_throw_runtime_error:
61		BL p_print_string
62		MOV r0, #-1
63		BL exit
64	p_print_string:
65		PUSH {lr}
66		LDR r1, [r0]
67		ADD r2, r0, #4
68		LDR r0, =msg_3
69		ADD r0, r0, #4
70		BL printf
71		MOV r0, #0
72		BL fflush
73		POP {pc}
74	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intUnderflow.wacc
-- Test: intUnderflow.wacc

-- Uploaded file: 
---------------------------------------------------------------
# integer underflow

# Output:
# -2147483647
# -2147483648
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = -2147483647 ;
  println x ;
  x = x - 1 ;
  println x ;
  x = x - 1 ; #err here?
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intUnderflow.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =-2147483647
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =1
29		SUBS r4, r4, r5
30		BLVS p_throw_overflow_error
31		STR r4, [sp]
32		LDR r4, [sp]
33		MOV r0, r4
34		BL p_print_int
35		BL p_print_ln
36		LDR r4, [sp]
37		LDR r5, =1
38		SUBS r4, r4, r5
39		BLVS p_throw_overflow_error
40		STR r4, [sp]
41		LDR r4, [sp]
42		MOV r0, r4
43		BL p_print_int
44		BL p_print_ln
45		ADD sp, sp, #4
46		LDR r0, =0
47		POP {pc}
48		.ltorg
49	p_print_int:
50		PUSH {lr}
51		MOV r1, r0
52		LDR r0, =msg_0
53		ADD r0, r0, #4
54		BL printf
55		MOV r0, #0
56		BL fflush
57		POP {pc}
58	p_print_ln:
59		PUSH {lr}
60		LDR r0, =msg_1
61		ADD r0, r0, #4
62		BL puts
63		MOV r0, #0
64		BL fflush
65		POP {pc}
66	p_throw_overflow_error:
67		LDR r0, =msg_2
68		BL p_throw_runtime_error
69	p_throw_runtime_error:
70		BL p_print_string
71		MOV r0, #-1
72		BL exit
73	p_print_string:
74		PUSH {lr}
75		LDR r1, [r0]
76		ADD r2, r0, #4
77		LDR r0, =msg_3
78		ADD r0, r0, #4
79		BL printf
80		MOV r0, #0
81		BL fflush
82		POP {pc}
83	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/integerOverflow/intWayOverflow.wacc
-- Test: intWayOverflow.wacc

-- Uploaded file: 
---------------------------------------------------------------
# positive overflow

# Output:
# 2000000000
# #runtime_error#

# Exit:
# 255

# Program:

begin
  int x = 2000000000 ;
  println x ;
  x = x + 2000000000; #err here?
  println x 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intWayOverflow.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	msg_2:
9		.word 82
10		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =2000000000
22		STR r4, [sp]
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		LDR r4, [sp]
28		LDR r5, =2000000000
29		ADDS r4, r4, r5
30		BLVS p_throw_overflow_error
31		STR r4, [sp]
32		LDR r4, [sp]
33		MOV r0, r4
34		BL p_print_int
35		BL p_print_ln
36		ADD sp, sp, #4
37		LDR r0, =0
38		POP {pc}
39		.ltorg
40	p_print_int:
41		PUSH {lr}
42		MOV r1, r0
43		LDR r0, =msg_0
44		ADD r0, r0, #4
45		BL printf
46		MOV r0, #0
47		BL fflush
48		POP {pc}
49	p_print_ln:
50		PUSH {lr}
51		LDR r0, =msg_1
52		ADD r0, r0, #4
53		BL puts
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_throw_overflow_error:
58		LDR r0, =msg_2
59		BL p_throw_runtime_error
60	p_throw_runtime_error:
61		BL p_print_string
62		MOV r0, #-1
63		BL exit
64	p_print_string:
65		PUSH {lr}
66		LDR r1, [r0]
67		ADD r2, r0, #4
68		LDR r0, =msg_3
69		ADD r0, r0, #4
70		BL printf
71		MOV r0, #0
72		BL fflush
73		POP {pc}
74	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/freeNull.wacc
-- Test: freeNull.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Create and free a null pair

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
  pair(pair, pair) a = null ;
  free a
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
freeNull.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =0
16		STR r4, [sp]
17		LDR r4, [sp]
18		MOV r0, r4
19		BL p_free_pair
20		ADD sp, sp, #4
21		LDR r0, =0
22		POP {pc}
23		.ltorg
24	p_free_pair:
25		PUSH {lr}
26		CMP r0, #0
27		LDREQ r0, =msg_0
28		BEQ p_throw_runtime_error
29		PUSH {r0}
30		LDR r0, [r0]
31		BL free
32		LDR r0, [sp]
33		LDR r0, [r0, #4]
34		BL free
35		POP {r0}
36		BL free
37		POP {pc}
38	p_throw_runtime_error:
39		BL p_print_string
40		MOV r0, #-1
41		BL exit
42	p_print_string:
43		PUSH {lr}
44		LDR r1, [r0]
45		ADD r2, r0, #4
46		LDR r0, =msg_1
47		ADD r0, r0, #4
48		BL printf
49		MOV r0, #0
50		BL fflush
51		POP {pc}
52	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/readNull1.wacc
-- Test: readNull1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt dereference of a null pair by reading into an element of it

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	pair(int, int) p = null ;
	read fst p
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
readNull1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #4
18		LDR r4, =0
19		STR r4, [sp]
20		LDR r4, [sp]
21		MOV r0, r4
22		BL p_check_null_pointer
23		LDR r4, [r4]
24		MOV r0, r4
25		BL p_read_int
26		ADD sp, sp, #4
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_check_null_pointer:
31		PUSH {lr}
32		CMP r0, #0
33		LDREQ r0, =msg_0
34		BLEQ p_throw_runtime_error
35		POP {pc}
36	p_read_int:
37		PUSH {lr}
38		MOV r1, r0
39		LDR r0, =msg_1
40		ADD r0, r0, #4
41		BL scanf
42		POP {pc}
43	p_throw_runtime_error:
44		BL p_print_string
45		MOV r0, #-1
46		BL exit
47	p_print_string:
48		PUSH {lr}
49		LDR r1, [r0]
50		ADD r2, r0, #4
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL printf
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/readNull2.wacc
-- Test: readNull2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt dereference of a null pair by reading into an element of it

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	pair(int, int) p = null ;
	read snd p
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
readNull2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 3
7		.ascii	"%d\0"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		SUB sp, sp, #4
18		LDR r4, =0
19		STR r4, [sp]
20		LDR r4, [sp]
21		MOV r0, r4
22		BL p_check_null_pointer
23		LDR r4, [r4, #4]
24		MOV r0, r4
25		BL p_read_int
26		ADD sp, sp, #4
27		LDR r0, =0
28		POP {pc}
29		.ltorg
30	p_check_null_pointer:
31		PUSH {lr}
32		CMP r0, #0
33		LDREQ r0, =msg_0
34		BLEQ p_throw_runtime_error
35		POP {pc}
36	p_read_int:
37		PUSH {lr}
38		MOV r1, r0
39		LDR r0, =msg_1
40		ADD r0, r0, #4
41		BL scanf
42		POP {pc}
43	p_throw_runtime_error:
44		BL p_print_string
45		MOV r0, #-1
46		BL exit
47	p_print_string:
48		PUSH {lr}
49		LDR r1, [r0]
50		ADD r2, r0, #4
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL printf
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/setNull1.wacc
-- Test: setNull1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt dereference of a null pair by setting an element of it

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	pair(int, int) p = null ;
	fst p = 1
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
setNull1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =0
16		STR r4, [sp]
17		LDR r4, =1
18		LDR r5, [sp]
19		MOV r0, r5
20		BL p_check_null_pointer
21		LDR r5, [r5]
22		STR r4, [r5]
23		ADD sp, sp, #4
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_check_null_pointer:
28		PUSH {lr}
29		CMP r0, #0
30		LDREQ r0, =msg_0
31		BLEQ p_throw_runtime_error
32		POP {pc}
33	p_throw_runtime_error:
34		BL p_print_string
35		MOV r0, #-1
36		BL exit
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_1
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/setNull2.wacc
-- Test: setNull2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt dereference of a null pair by setting an element of it

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	pair(int, int) p = null ;
	snd p = 1
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
setNull2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =0
16		STR r4, [sp]
17		LDR r4, =1
18		LDR r5, [sp]
19		MOV r0, r5
20		BL p_check_null_pointer
21		LDR r5, [r5, #4]
22		STR r4, [r5]
23		ADD sp, sp, #4
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_check_null_pointer:
28		PUSH {lr}
29		CMP r0, #0
30		LDREQ r0, =msg_0
31		BLEQ p_throw_runtime_error
32		POP {pc}
33	p_throw_runtime_error:
34		BL p_print_string
35		MOV r0, #-1
36		BL exit
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_1
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/useNull1.wacc
-- Test: useNull1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt dereference of a null pair by using it

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	pair(int, int) p = null ;
	int x = fst p
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
useNull1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #8
15		LDR r4, =0
16		STR r4, [sp, #4]
17		LDR r4, [sp, #4]
18		MOV r0, r4
19		BL p_check_null_pointer
20		LDR r4, [r4]
21		LDR r4, [r4]
22		STR r4, [sp]
23		ADD sp, sp, #8
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_check_null_pointer:
28		PUSH {lr}
29		CMP r0, #0
30		LDREQ r0, =msg_0
31		BLEQ p_throw_runtime_error
32		POP {pc}
33	p_throw_runtime_error:
34		BL p_print_string
35		MOV r0, #-1
36		BL exit
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_1
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/runtimeErr/nullDereference/useNull2.wacc
-- Test: useNull2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# attempt dereference of a null pair by using it

# Output:
# #runtime_error#

# Exit:
# 255

# Program:

begin
	pair(int, int) p = null ;
	int x = snd p
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
useNull2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 50
4		.ascii	"NullReferenceError: dereference a null reference\n\0"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #8
15		LDR r4, =0
16		STR r4, [sp, #4]
17		LDR r4, [sp, #4]
18		MOV r0, r4
19		BL p_check_null_pointer
20		LDR r4, [r4, #4]
21		LDR r4, [r4]
22		STR r4, [sp]
23		ADD sp, sp, #8
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_check_null_pointer:
28		PUSH {lr}
29		CMP r0, #0
30		LDREQ r0, =msg_0
31		BLEQ p_throw_runtime_error
32		POP {pc}
33	p_throw_runtime_error:
34		BL p_print_string
35		MOV r0, #-1
36		BL exit
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_1
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/ifNested1.wacc
-- Test: ifNested1.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Nested conditional statement

# Output:
# correct

# Program:

begin
  int a = 13;	
  if a == 13 
  then 
    if a > 5
    then
      println "correct"
    else
      println "incorrect"
    fi
  else 
    println "incorrect"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ifNested1.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"correct"
5	msg_1:
6		.word 9
7		.ascii	"incorrect"
8	msg_2:
9		.word 9
10		.ascii	"incorrect"
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =13
25		STR r4, [sp]
26		LDR r4, [sp]
27		LDR r5, =13
28		CMP r4, r5
29		MOVEQ r4, #1
30		MOVNE r4, #0
31		CMP r4, #0
32		BEQ L0
33		LDR r4, [sp]
34		LDR r5, =5
35		CMP r4, r5
36		MOVGT r4, #1
37		MOVLE r4, #0
38		CMP r4, #0
39		BEQ L2
40		LDR r4, =msg_0
41		MOV r0, r4
42		BL p_print_string
43		BL p_print_ln
44		B L3
45	L2:
46		LDR r4, =msg_1
47		MOV r0, r4
48		BL p_print_string
49		BL p_print_ln
50	L3:
51		B L1
52	L0:
53		LDR r4, =msg_2
54		MOV r0, r4
55		BL p_print_string
56		BL p_print_ln
57	L1:
58		ADD sp, sp, #4
59		LDR r0, =0
60		POP {pc}
61		.ltorg
62	p_print_string:
63		PUSH {lr}
64		LDR r1, [r0]
65		ADD r2, r0, #4
66		LDR r0, =msg_3
67		ADD r0, r0, #4
68		BL printf
69		MOV r0, #0
70		BL fflush
71		POP {pc}
72	p_print_ln:
73		PUSH {lr}
74		LDR r0, =msg_4
75		ADD r0, r0, #4
76		BL puts
77		MOV r0, #0
78		BL fflush
79		POP {pc}
80	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/ifNested2.wacc
-- Test: ifNested2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Deeply nested conditional statement

# Output:
# correct

# Program:

begin
  int a = 13;	
  if a == 13 
  then 
    if a > 5
    then
      if a < 10
      then 
        println "incorrect"
      else
        if a > 12
        then
          if a > 13
          then
            println "incorrect"
          else
            println "correct"
          fi
        else 
          println "incorrect"
        fi
      fi
    else
      println "incorrect"
    fi
  else 
    println "incorrect"
  fi
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
ifNested2.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 9
4		.ascii	"incorrect"
5	msg_1:
6		.word 9
7		.ascii	"incorrect"
8	msg_2:
9		.word 7
10		.ascii	"correct"
11	msg_3:
12		.word 9
13		.ascii	"incorrect"
14	msg_4:
15		.word 9
16		.ascii	"incorrect"
17	msg_5:
18		.word 9
19		.ascii	"incorrect"
20	msg_6:
21		.word 5
22		.ascii	"%.*s\0"
23	msg_7:
24		.word 1
25		.ascii	"\0"
26	
27	.text
28	
29	.global main
30	main:
31		PUSH {lr}
32		SUB sp, sp, #4
33		LDR r4, =13
34		STR r4, [sp]
35		LDR r4, [sp]
36		LDR r5, =13
37		CMP r4, r5
38		MOVEQ r4, #1
39		MOVNE r4, #0
40		CMP r4, #0
41		BEQ L0
42		LDR r4, [sp]
43		LDR r5, =5
44		CMP r4, r5
45		MOVGT r4, #1
46		MOVLE r4, #0
47		CMP r4, #0
48		BEQ L2
49		LDR r4, [sp]
50		LDR r5, =10
51		CMP r4, r5
52		MOVLT r4, #1
53		MOVGE r4, #0
54		CMP r4, #0
55		BEQ L4
56		LDR r4, =msg_0
57		MOV r0, r4
58		BL p_print_string
59		BL p_print_ln
60		B L5
61	L4:
62		LDR r4, [sp]
63		LDR r5, =12
64		CMP r4, r5
65		MOVGT r4, #1
66		MOVLE r4, #0
67		CMP r4, #0
68		BEQ L6
69		LDR r4, [sp]
70		LDR r5, =13
71		CMP r4, r5
72		MOVGT r4, #1
73		MOVLE r4, #0
74		CMP r4, #0
75		BEQ L8
76		LDR r4, =msg_1
77		MOV r0, r4
78		BL p_print_string
79		BL p_print_ln
80		B L9
81	L8:
82		LDR r4, =msg_2
83		MOV r0, r4
84		BL p_print_string
85		BL p_print_ln
86	L9:
87		B L7
88	L6:
89		LDR r4, =msg_3
90		MOV r0, r4
91		BL p_print_string
92		BL p_print_ln
93	L7:
94	L5:
95		B L3
96	L2:
97		LDR r4, =msg_4
98		MOV r0, r4
99		BL p_print_string
100		BL p_print_ln
101	L3:
102		B L1
103	L0:
104		LDR r4, =msg_5
105		MOV r0, r4
106		BL p_print_string
107		BL p_print_ln
108	L1:
109		ADD sp, sp, #4
110		LDR r0, =0
111		POP {pc}
112		.ltorg
113	p_print_string:
114		PUSH {lr}
115		LDR r1, [r0]
116		ADD r2, r0, #4
117		LDR r0, =msg_6
118		ADD r0, r0, #4
119		BL printf
120		MOV r0, #0
121		BL fflush
122		POP {pc}
123	p_print_ln:
124		PUSH {lr}
125		LDR r0, =msg_7
126		ADD r0, r0, #4
127		BL puts
128		MOV r0, #0
129		BL fflush
130		POP {pc}
131	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/indentationNotImportant.wacc
-- Test: indentationNotImportant.wacc

-- Uploaded file: 
---------------------------------------------------------------
# consistent indentation is for readability purposes only

# Output:
# #empty#

# Program:

           begin
 while 
false 
         do
    skip
done
                    end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
indentationNotImportant.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		B L0
6	L1:
7	L0:
8		MOV r4, #0
9		CMP r4, #1
10		BEQ L1
11		LDR r0, =0
12		POP {pc}
13		.ltorg
14	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/intsAndKeywords.wacc
-- Test: intsAndKeywords.wacc

-- Uploaded file: 
---------------------------------------------------------------
# checking handling of ints and keywords 

# Output:
# #empty#

# Program:
begin
  begin
    int x = 125end
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intsAndKeywords.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =125
7		STR r4, [sp]
8		ADD sp, sp, #4
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/printAllTypes.wacc
-- Test: printAllTypes.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Tests scoping with most variable types

# Output:
# ( [1, 2, 3] , [a, b, c] )
# [ #addrs# = (a, true), #addrs# = (b, false) ]
# 1, 2
# array, of, strings
# true, false, true
# xyz
# 1, 2, 3
# this is a string
# true
# x
# 5

# Program:

begin

  string comma = ", ";
  int x = 5;
  begin
    char x = 'x';    
    begin
      bool x = true;    
      begin
        string x = "this is a string";    
        begin
          int[] x = [1,2,3];    
          begin
            char[] x = ['x', 'y', 'z'];    
            begin
              bool[] x = [true, false, true];
              begin
                string[] x = ["array", "of", "strings"];
                begin
                  pair(int, int) x = newpair(1, 2);
                  begin
                    pair(char, bool) y = newpair('a', true);
                    pair(char, bool) z = newpair('b', false);
                    pair(char, bool)[] x = [y, z];
                    begin
                      int[] y = [1, 2, 3];
                      char[] z = ['a', 'b', 'c'];
                      pair(int[], char[]) x = newpair(y, z);
                      begin
                        skip
                      end;
                      int[] a = fst x;
                      char[] b = snd x;
                      print "( [";
                      print a[0];
                      print comma;
                      print a[1];
                      print comma;
                      print a[2];
                      print "] , [";
                      print b[0];
                      print comma;
                      print b[1];
                      print comma;
                      print b[2];
                      println "] )" # ( [fst x] , [snd x] )
                    end;
                    pair(char, bool) a = x[0];
                    char aa = fst a;
                    bool ab = snd a;
                    pair(char, bool) b = x[1];
                    char ba = fst b;
                    bool bb = snd b;
                    print "[ ";
                    print a;
                    print " = (";
                    print aa;
                    print comma;
                    print ab;
                    print "), ";
                    print b;
                    print " = (";
                    print ba;
                    print comma;
                    print bb;
                    println ") ]" # [ x[0], x[1] ]
                  end;
                  int y = fst x;
                  int z = snd x;
                  print y; 
                  print comma;
                  println z # fst x, snd x
                end;
                string a = x[0];
                string b = x[1];
                string c = x[2];
                print a;
                print comma;
                print b;
                print comma;
                println c # string[]
              end;
              print x[0];
              print comma;
              print x[1];
              print comma;
              println x[2] # bool[]
            end;
            println x # char[]
          end;
          int a = x[0];
          int b = x[1];
          int c = x[2];
          print a;
          print comma;
          print b;
          print comma;
          println c # int[]
        end;
        println x # string
      end;
      println x # bool
    end;
    println x # char
  end;
  println x # int

end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
printAllTypes.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 2
4		.ascii	", "
5	msg_1:
6		.word 16
7		.ascii	"this is a string"
8	msg_2:
9		.word 5
10		.ascii	"array"
11	msg_3:
12		.word 2
13		.ascii	"of"
14	msg_4:
15		.word 7
16		.ascii	"strings"
17	msg_5:
18		.word 3
19		.ascii	"( ["
20	msg_6:
21		.word 5
22		.ascii	"] , ["
23	msg_7:
24		.word 3
25		.ascii	"] )"
26	msg_8:
27		.word 2
28		.ascii	"[ "
29	msg_9:
30		.word 4
31		.ascii	" = ("
32	msg_10:
33		.word 3
34		.ascii	"), "
35	msg_11:
36		.word 4
37		.ascii	" = ("
38	msg_12:
39		.word 3
40		.ascii	") ]"
41	msg_13:
42		.word 50
43		.ascii	"NullReferenceError: dereference a null reference\n\0"
44	msg_14:
45		.word 5
46		.ascii	"%.*s\0"
47	msg_15:
48		.word 44
49		.ascii	"ArrayIndexOutOfBoundsError: negative index\n\0"
50	msg_16:
51		.word 45
52		.ascii	"ArrayIndexOutOfBoundsError: index too large\n\0"
53	msg_17:
54		.word 3
55		.ascii	"%d\0"
56	msg_18:
57		.word 1
58		.ascii	"\0"
59	msg_19:
60		.word 3
61		.ascii	"%p\0"
62	msg_20:
63		.word 5
64		.ascii	"true\0"
65	msg_21:
66		.word 6
67		.ascii	"false\0"
68	
69	.text
70	
71	.global main
72	main:
73		PUSH {lr}
74		SUB sp, sp, #8
75		LDR r4, =msg_0
76		STR r4, [sp, #4]
77		LDR r4, =5
78		STR r4, [sp]
79		SUB sp, sp, #1
80		MOV r4, #'x'
81		STRB r4, [sp]
82		SUB sp, sp, #1
83		MOV r4, #1
84		STRB r4, [sp]
85		SUB sp, sp, #4
86		LDR r4, =msg_1
87		STR r4, [sp]
88		SUB sp, sp, #16
89		LDR r0, =16
90		BL malloc
91		MOV r4, r0
92		LDR r5, =1
93		STR r5, [r4, #4]
94		LDR r5, =2
95		STR r5, [r4, #8]
96		LDR r5, =3
97		STR r5, [r4, #12]
98		LDR r5, =3
99		STR r5, [r4]
100		STR r4, [sp, #12]
101		SUB sp, sp, #4
102		LDR r0, =7
103		BL malloc
104		MOV r4, r0
105		MOV r5, #'x'
106		STRB r5, [r4, #4]
107		MOV r5, #'y'
108		STRB r5, [r4, #5]
109		MOV r5, #'z'
110		STRB r5, [r4, #6]
111		LDR r5, =3
112		STR r5, [r4]
113		STR r4, [sp]
114		SUB sp, sp, #4
115		LDR r0, =7
116		BL malloc
117		MOV r4, r0
118		MOV r5, #1
119		STRB r5, [r4, #4]
120		MOV r5, #0
121		STRB r5, [r4, #5]
122		MOV r5, #1
123		STRB r5, [r4, #6]
124		LDR r5, =3
125		STR r5, [r4]
126		STR r4, [sp]
127		SUB sp, sp, #16
128		LDR r0, =16
129		BL malloc
130		MOV r4, r0
131		LDR r5, =msg_2
132		STR r5, [r4, #4]
133		LDR r5, =msg_3
134		STR r5, [r4, #8]
135		LDR r5, =msg_4
136		STR r5, [r4, #12]
137		LDR r5, =3
138		STR r5, [r4]
139		STR r4, [sp, #12]
140		SUB sp, sp, #12
141		LDR r0, =8
142		BL malloc
143		MOV r4, r0
144		LDR r5, =1
145		LDR r0, =4
146		BL malloc
147		STR r5, [r0]
148		STR r0, [r4]
149		LDR r5, =2
150		LDR r0, =4
151		BL malloc
152		STR r5, [r0]
153		STR r0, [r4, #4]
154		STR r4, [sp, #8]
155		SUB sp, sp, #24
156		LDR r0, =8
157		BL malloc
158		MOV r4, r0
159		MOV r5, #'a'
160		LDR r0, =1
161		BL malloc
162		STRB r5, [r0]
163		STR r0, [r4]
164		MOV r5, #1
165		LDR r0, =1
166		BL malloc
167		STRB r5, [r0]
168		STR r0, [r4, #4]
169		STR r4, [sp, #20]
170		LDR r0, =8
171		BL malloc
172		MOV r4, r0
173		MOV r5, #'b'
174		LDR r0, =1
175		BL malloc
176		STRB r5, [r0]
177		STR r0, [r4]
178		MOV r5, #0
179		LDR r0, =1
180		BL malloc
181		STRB r5, [r0]
182		STR r0, [r4, #4]
183		STR r4, [sp, #16]
184		LDR r0, =12
185		BL malloc
186		MOV r4, r0
187		LDR r5, [sp, #20]
188		STR r5, [r4, #4]
189		LDR r5, [sp, #16]
190		STR r5, [r4, #8]
191		LDR r5, =2
192		STR r5, [r4]
193		STR r4, [sp, #12]
194		SUB sp, sp, #20
195		LDR r0, =16
196		BL malloc
197		MOV r4, r0
198		LDR r5, =1
199		STR r5, [r4, #4]
200		LDR r5, =2
201		STR r5, [r4, #8]
202		LDR r5, =3
203		STR r5, [r4, #12]
204		LDR r5, =3
205		STR r5, [r4]
206		STR r4, [sp, #16]
207		LDR r0, =7
208		BL malloc
209		MOV r4, r0
210		MOV r5, #'a'
211		STRB r5, [r4, #4]
212		MOV r5, #'b'
213		STRB r5, [r4, #5]
214		MOV r5, #'c'
215		STRB r5, [r4, #6]
216		LDR r5, =3
217		STR r5, [r4]
218		STR r4, [sp, #12]
219		LDR r0, =8
220		BL malloc
221		MOV r4, r0
222		LDR r5, [sp, #16]
223		LDR r0, =4
224		BL malloc
225		STR r5, [r0]
226		STR r0, [r4]
227		LDR r5, [sp, #12]
228		LDR r0, =4
229		BL malloc
230		STR r5, [r0]
231		STR r0, [r4, #4]
232		STR r4, [sp, #8]
233		LDR r4, [sp, #8]
234		MOV r0, r4
235		BL p_check_null_pointer
236		LDR r4, [r4]
237		LDR r4, [r4]
238		STR r4, [sp, #4]
239		LDR r4, [sp, #8]
240		MOV r0, r4
241		BL p_check_null_pointer
242		LDR r4, [r4, #4]
243		LDR r4, [r4]
244		STR r4, [sp]
245		LDR r4, =msg_5
246		MOV r0, r4
247		BL p_print_string
248		ADD r4, sp, #4
249		LDR r5, =0
250		LDR r4, [r4]
251		MOV r0, r5
252		MOV r1, r4
253		BL p_check_array_bounds
254		ADD r4, r4, #4
255		ADD r4, r4, r5, LSL #2
256		LDR r4, [r4]
257		MOV r0, r4
258		BL p_print_int
259		LDR r4, [sp, #106]
260		MOV r0, r4
261		BL p_print_string
262		ADD r4, sp, #4
263		LDR r5, =1
264		LDR r4, [r4]
265		MOV r0, r5
266		MOV r1, r4
267		BL p_check_array_bounds
268		ADD r4, r4, #4
269		ADD r4, r4, r5, LSL #2
270		LDR r4, [r4]
271		MOV r0, r4
272		BL p_print_int
273		LDR r4, [sp, #106]
274		MOV r0, r4
275		BL p_print_string
276		ADD r4, sp, #4
277		LDR r5, =2
278		LDR r4, [r4]
279		MOV r0, r5
280		MOV r1, r4
281		BL p_check_array_bounds
282		ADD r4, r4, #4
283		ADD r4, r4, r5, LSL #2
284		LDR r4, [r4]
285		MOV r0, r4
286		BL p_print_int
287		LDR r4, =msg_6
288		MOV r0, r4
289		BL p_print_string
290		ADD r4, sp, #0
291		LDR r5, =0
292		LDR r4, [r4]
293		MOV r0, r5
294		MOV r1, r4
295		BL p_check_array_bounds
296		ADD r4, r4, #4
297		ADD r4, r4, r5
298		LDRSB r4, [r4]
299		MOV r0, r4
300		BL putchar
301		LDR r4, [sp, #106]
302		MOV r0, r4
303		BL p_print_string
304		ADD r4, sp, #0
305		LDR r5, =1
306		LDR r4, [r4]
307		MOV r0, r5
308		MOV r1, r4
309		BL p_check_array_bounds
310		ADD r4, r4, #4
311		ADD r4, r4, r5
312		LDRSB r4, [r4]
313		MOV r0, r4
314		BL putchar
315		LDR r4, [sp, #106]
316		MOV r0, r4
317		BL p_print_string
318		ADD r4, sp, #0
319		LDR r5, =2
320		LDR r4, [r4]
321		MOV r0, r5
322		MOV r1, r4
323		BL p_check_array_bounds
324		ADD r4, r4, #4
325		ADD r4, r4, r5
326		LDRSB r4, [r4]
327		MOV r0, r4
328		BL putchar
329		LDR r4, =msg_7
330		MOV r0, r4
331		BL p_print_string
332		BL p_print_ln
333		ADD sp, sp, #20
334		ADD r4, sp, #12
335		LDR r5, =0
336		LDR r4, [r4]
337		MOV r0, r5
338		MOV r1, r4
339		BL p_check_array_bounds
340		ADD r4, r4, #4
341		ADD r4, r4, r5, LSL #2
342		LDR r4, [r4]
343		STR r4, [sp, #8]
344		LDR r4, [sp, #8]
345		MOV r0, r4
346		BL p_check_null_pointer
347		LDR r4, [r4]
348		LDRSB r4, [r4]
349		STRB r4, [sp, #7]
350		LDR r4, [sp, #8]
351		MOV r0, r4
352		BL p_check_null_pointer
353		LDR r4, [r4, #4]
354		LDRSB r4, [r4]
355		STRB r4, [sp, #6]
356		ADD r4, sp, #12
357		LDR r5, =1
358		LDR r4, [r4]
359		MOV r0, r5
360		MOV r1, r4
361		BL p_check_array_bounds
362		ADD r4, r4, #4
363		ADD r4, r4, r5, LSL #2
364		LDR r4, [r4]
365		STR r4, [sp, #2]
366		LDR r4, [sp, #2]
367		MOV r0, r4
368		BL p_check_null_pointer
369		LDR r4, [r4]
370		LDRSB r4, [r4]
371		STRB r4, [sp, #1]
372		LDR r4, [sp, #2]
373		MOV r0, r4
374		BL p_check_null_pointer
375		LDR r4, [r4, #4]
376		LDRSB r4, [r4]
377		STRB r4, [sp]
378		LDR r4, =msg_8
379		MOV r0, r4
380		BL p_print_string
381		LDR r4, [sp, #8]
382		MOV r0, r4
383		BL p_print_reference
384		LDR r4, =msg_9
385		MOV r0, r4
386		BL p_print_string
387		LDRSB r4, [sp, #7]
388		MOV r0, r4
389		BL putchar
390		LDR r4, [sp, #86]
391		MOV r0, r4
392		BL p_print_string
393		LDRSB r4, [sp, #6]
394		MOV r0, r4
395		BL p_print_bool
396		LDR r4, =msg_10
397		MOV r0, r4
398		BL p_print_string
399		LDR r4, [sp, #2]
400		MOV r0, r4
401		BL p_print_reference
402		LDR r4, =msg_11
403		MOV r0, r4
404		BL p_print_string
405		LDRSB r4, [sp, #1]
406		MOV r0, r4
407		BL putchar
408		LDR r4, [sp, #86]
409		MOV r0, r4
410		BL p_print_string
411		LDRSB r4, [sp]
412		MOV r0, r4
413		BL p_print_bool
414		LDR r4, =msg_12
415		MOV r0, r4
416		BL p_print_string
417		BL p_print_ln
418		ADD sp, sp, #24
419		LDR r4, [sp, #8]
420		MOV r0, r4
421		BL p_check_null_pointer
422		LDR r4, [r4]
423		LDR r4, [r4]
424		STR r4, [sp, #4]
425		LDR r4, [sp, #8]
426		MOV r0, r4
427		BL p_check_null_pointer
428		LDR r4, [r4, #4]
429		LDR r4, [r4]
430		STR r4, [sp]
431		LDR r4, [sp, #4]
432		MOV r0, r4
433		BL p_print_int
434		LDR r4, [sp, #62]
435		MOV r0, r4
436		BL p_print_string
437		LDR r4, [sp]
438		MOV r0, r4
439		BL p_print_int
440		BL p_print_ln
441		ADD sp, sp, #12
442		ADD r4, sp, #12
443		LDR r5, =0
444		LDR r4, [r4]
445		MOV r0, r5
446		MOV r1, r4
447		BL p_check_array_bounds
448		ADD r4, r4, #4
449		ADD r4, r4, r5, LSL #2
450		LDR r4, [r4]
451		STR r4, [sp, #8]
452		ADD r4, sp, #12
453		LDR r5, =1
454		LDR r4, [r4]
455		MOV r0, r5
456		MOV r1, r4
457		BL p_check_array_bounds
458		ADD r4, r4, #4
459		ADD r4, r4, r5, LSL #2
460		LDR r4, [r4]
461		STR r4, [sp, #4]
462		ADD r4, sp, #12
463		LDR r5, =2
464		LDR r4, [r4]
465		MOV r0, r5
466		MOV r1, r4
467		BL p_check_array_bounds
468		ADD r4, r4, #4
469		ADD r4, r4, r5, LSL #2
470		LDR r4, [r4]
471		STR r4, [sp]
472		LDR r4, [sp, #8]
473		MOV r0, r4
474		BL p_print_string
475		LDR r4, [sp, #50]
476		MOV r0, r4
477		BL p_print_string
478		LDR r4, [sp, #4]
479		MOV r0, r4
480		BL p_print_string
481		LDR r4, [sp, #50]
482		MOV r0, r4
483		BL p_print_string
484		LDR r4, [sp]
485		MOV r0, r4
486		BL p_print_string
487		BL p_print_ln
488		ADD sp, sp, #16
489		ADD r4, sp, #0
490		LDR r5, =0
491		LDR r4, [r4]
492		MOV r0, r5
493		MOV r1, r4
494		BL p_check_array_bounds
495		ADD r4, r4, #4
496		ADD r4, r4, r5
497		LDRSB r4, [r4]
498		MOV r0, r4
499		BL p_print_bool
500		LDR r4, [sp, #34]
501		MOV r0, r4
502		BL p_print_string
503		ADD r4, sp, #0
504		LDR r5, =1
505		LDR r4, [r4]
506		MOV r0, r5
507		MOV r1, r4
508		BL p_check_array_bounds
509		ADD r4, r4, #4
510		ADD r4, r4, r5
511		LDRSB r4, [r4]
512		MOV r0, r4
513		BL p_print_bool
514		LDR r4, [sp, #34]
515		MOV r0, r4
516		BL p_print_string
517		ADD r4, sp, #0
518		LDR r5, =2
519		LDR r4, [r4]
520		MOV r0, r5
521		MOV r1, r4
522		BL p_check_array_bounds
523		ADD r4, r4, #4
524		ADD r4, r4, r5
525		LDRSB r4, [r4]
526		MOV r0, r4
527		BL p_print_bool
528		BL p_print_ln
529		ADD sp, sp, #4
530		LDR r4, [sp]
531		MOV r0, r4
532		BL p_print_string
533		BL p_print_ln
534		ADD sp, sp, #4
535		ADD r4, sp, #12
536		LDR r5, =0
537		LDR r4, [r4]
538		MOV r0, r5
539		MOV r1, r4
540		BL p_check_array_bounds
541		ADD r4, r4, #4
542		ADD r4, r4, r5, LSL #2
543		LDR r4, [r4]
544		STR r4, [sp, #8]
545		ADD r4, sp, #12
546		LDR r5, =1
547		LDR r4, [r4]
548		MOV r0, r5
549		MOV r1, r4
550		BL p_check_array_bounds
551		ADD r4, r4, #4
552		ADD r4, r4, r5, LSL #2
553		LDR r4, [r4]
554		STR r4, [sp, #4]
555		ADD r4, sp, #12
556		LDR r5, =2
557		LDR r4, [r4]
558		MOV r0, r5
559		MOV r1, r4
560		BL p_check_array_bounds
561		ADD r4, r4, #4
562		ADD r4, r4, r5, LSL #2
563		LDR r4, [r4]
564		STR r4, [sp]
565		LDR r4, [sp, #8]
566		MOV r0, r4
567		BL p_print_int
568		LDR r4, [sp, #26]
569		MOV r0, r4
570		BL p_print_string
571		LDR r4, [sp, #4]
572		MOV r0, r4
573		BL p_print_int
574		LDR r4, [sp, #26]
575		MOV r0, r4
576		BL p_print_string
577		LDR r4, [sp]
578		MOV r0, r4
579		BL p_print_int
580		BL p_print_ln
581		ADD sp, sp, #16
582		LDR r4, [sp]
583		MOV r0, r4
584		BL p_print_string
585		BL p_print_ln
586		ADD sp, sp, #4
587		LDRSB r4, [sp]
588		MOV r0, r4
589		BL p_print_bool
590		BL p_print_ln
591		ADD sp, sp, #1
592		LDRSB r4, [sp]
593		MOV r0, r4
594		BL putchar
595		BL p_print_ln
596		ADD sp, sp, #1
597		LDR r4, [sp]
598		MOV r0, r4
599		BL p_print_int
600		BL p_print_ln
601		ADD sp, sp, #8
602		LDR r0, =0
603		POP {pc}
604		.ltorg
605	p_check_null_pointer:
606		PUSH {lr}
607		CMP r0, #0
608		LDREQ r0, =msg_13
609		BLEQ p_throw_runtime_error
610		POP {pc}
611	p_print_string:
612		PUSH {lr}
613		LDR r1, [r0]
614		ADD r2, r0, #4
615		LDR r0, =msg_14
616		ADD r0, r0, #4
617		BL printf
618		MOV r0, #0
619		BL fflush
620		POP {pc}
621	p_check_array_bounds:
622		PUSH {lr}
623		CMP r0, #0
624		LDRLT r0, =msg_15
625		BLLT p_throw_runtime_error
626		LDR r1, [r1]
627		CMP r0, r1
628		LDRCS r0, =msg_16
629		BLCS p_throw_runtime_error
630		POP {pc}
631	p_print_int:
632		PUSH {lr}
633		MOV r1, r0
634		LDR r0, =msg_17
635		ADD r0, r0, #4
636		BL printf
637		MOV r0, #0
638		BL fflush
639		POP {pc}
640	p_print_ln:
641		PUSH {lr}
642		LDR r0, =msg_18
643		ADD r0, r0, #4
644		BL puts
645		MOV r0, #0
646		BL fflush
647		POP {pc}
648	p_print_reference:
649		PUSH {lr}
650		MOV r1, r0
651		LDR r0, =msg_19
652		ADD r0, r0, #4
653		BL printf
654		MOV r0, #0
655		BL fflush
656		POP {pc}
657	p_print_bool:
658		PUSH {lr}
659		CMP r0, #0
660		LDRNE r0, =msg_20
661		LDREQ r0, =msg_21
662		ADD r0, r0, #4
663		BL printf
664		MOV r0, #0
665		BL fflush
666		POP {pc}
667	p_throw_runtime_error:
668		BL p_print_string
669		MOV r0, #-1
670		BL exit
671	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/scope.wacc
-- Test: scope.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple scoping test

# Output:
# #empty#

# Program:

begin
  begin
    begin
      begin
        begin
          skip
        end
      end
    end
  end
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
scope.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/scopeBasic.wacc
-- Test: scopeBasic.wacc

-- Uploaded file: 
---------------------------------------------------------------
# very simple scoping test

# Output:
# #empty#

# Program:

begin
  skip;
  begin
    skip
  end
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
scopeBasic.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/scopeRedefine.wacc
-- Test: scopeRedefine.wacc

-- Uploaded file: 
---------------------------------------------------------------
# more complex variable scoping test that redefines a variable

# Output:
# true
# 2

# Program:

begin
  int x = 1 ;
  begin
    x = 2 ;
    bool x = true ;
    println x
  end ;
  println x 
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
scopeRedefine.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =1
22		STR r4, [sp]
23		SUB sp, sp, #1
24		LDR r4, =2
25		STR r4, [sp, #1]
26		MOV r4, #1
27		STRB r4, [sp]
28		LDRSB r4, [sp]
29		MOV r0, r4
30		BL p_print_bool
31		BL p_print_ln
32		ADD sp, sp, #1
33		LDR r4, [sp]
34		MOV r0, r4
35		BL p_print_int
36		BL p_print_ln
37		ADD sp, sp, #4
38		LDR r0, =0
39		POP {pc}
40		.ltorg
41	p_print_bool:
42		PUSH {lr}
43		CMP r0, #0
44		LDRNE r0, =msg_0
45		LDREQ r0, =msg_1
46		ADD r0, r0, #4
47		BL printf
48		MOV r0, #0
49		BL fflush
50		POP {pc}
51	p_print_ln:
52		PUSH {lr}
53		LDR r0, =msg_2
54		ADD r0, r0, #4
55		BL puts
56		MOV r0, #0
57		BL fflush
58		POP {pc}
59	p_print_int:
60		PUSH {lr}
61		MOV r1, r0
62		LDR r0, =msg_3
63		ADD r0, r0, #4
64		BL printf
65		MOV r0, #0
66		BL fflush
67		POP {pc}
68	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/scopeSimpleRedefine.wacc
-- Test: scopeSimpleRedefine.wacc

-- Uploaded file: 
---------------------------------------------------------------
# variable scoping test that redefines a variable

# Output:
# true
# 12

# Program:

begin
  int x = 12 ;
  begin
    bool x = true ;
    println x
  end ;
  println x 
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
scopeSimpleRedefine.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 5
4		.ascii	"true\0"
5	msg_1:
6		.word 6
7		.ascii	"false\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =12
22		STR r4, [sp]
23		SUB sp, sp, #1
24		MOV r4, #1
25		STRB r4, [sp]
26		LDRSB r4, [sp]
27		MOV r0, r4
28		BL p_print_bool
29		BL p_print_ln
30		ADD sp, sp, #1
31		LDR r4, [sp]
32		MOV r0, r4
33		BL p_print_int
34		BL p_print_ln
35		ADD sp, sp, #4
36		LDR r0, =0
37		POP {pc}
38		.ltorg
39	p_print_bool:
40		PUSH {lr}
41		CMP r0, #0
42		LDRNE r0, =msg_0
43		LDREQ r0, =msg_1
44		ADD r0, r0, #4
45		BL printf
46		MOV r0, #0
47		BL fflush
48		POP {pc}
49	p_print_ln:
50		PUSH {lr}
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL puts
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_print_int:
58		PUSH {lr}
59		MOV r1, r0
60		LDR r0, =msg_3
61		ADD r0, r0, #4
62		BL printf
63		MOV r0, #0
64		BL fflush
65		POP {pc}
66	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/scope/scopeVars.wacc
-- Test: scopeVars.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple variable scoping test

# Output:
# 2
# 4
# 2

# Program:

begin
  int x = 2 ;
  println x ;
  begin
    int x = 4 ;
    println x
  end ;
  println x 
end

---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
scopeVars.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =2
16		STR r4, [sp]
17		LDR r4, [sp]
18		MOV r0, r4
19		BL p_print_int
20		BL p_print_ln
21		SUB sp, sp, #4
22		LDR r4, =4
23		STR r4, [sp]
24		LDR r4, [sp]
25		MOV r0, r4
26		BL p_print_int
27		BL p_print_ln
28		ADD sp, sp, #4
29		LDR r4, [sp]
30		MOV r0, r4
31		BL p_print_int
32		BL p_print_ln
33		ADD sp, sp, #4
34		LDR r0, =0
35		POP {pc}
36		.ltorg
37	p_print_int:
38		PUSH {lr}
39		MOV r1, r0
40		LDR r0, =msg_0
41		ADD r0, r0, #4
42		BL printf
43		MOV r0, #0
44		BL fflush
45		POP {pc}
46	p_print_ln:
47		PUSH {lr}
48		LDR r0, =msg_1
49		ADD r0, r0, #4
50		BL puts
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/basicSeq.wacc
-- Test: basicSeq.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic sequential composition

# Output:
# #empty#

# Program:

begin 
  skip;
  skip 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
basicSeq.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/basicSeq2.wacc
-- Test: basicSeq2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# basic sequential composition

# Output:
# #empty#

# Program:

begin 
  skip;
  skip;
  skip 
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
basicSeq2.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		LDR r0, =0
6		POP {pc}
7		.ltorg
8	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/boolAssignment.wacc
-- Test: boolAssignment.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple boolean variable declaration and assignment

# Output:
# #empty#

# Program:

begin
  bool b = false ;
  b = true
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
boolAssignment.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #0
7		STRB r4, [sp]
8		MOV r4, #1
9		STRB r4, [sp]
10		ADD sp, sp, #1
11		LDR r0, =0
12		POP {pc}
13		.ltorg
14	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/charAssignment.wacc
-- Test: charAssignment.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple character variable declaration and assignment

# Output:
# #empty#

# Program:

begin
  char c = 'a' ;
  c = 'Z'
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
charAssignment.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #'a'
7		STRB r4, [sp]
8		MOV r4, #'Z'
9		STRB r4, [sp]
10		ADD sp, sp, #1
11		LDR r0, =0
12		POP {pc}
13		.ltorg
14	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/exitSimple.wacc
-- Test: exitSimple.wacc

-- Uploaded file: 
---------------------------------------------------------------
# exit with unreachable print

# Output:
# #empty#

# Exit:
# 42

# Program:

begin
  exit 42 ;
  println "Should not print this."
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
exitSimple.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 22
4		.ascii	"Should not print this."
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	
12	.text
13	
14	.global main
15	main:
16		PUSH {lr}
17		LDR r4, =42
18		MOV r0, r4
19		BL exit
20		LDR r4, =msg_0
21		MOV r0, r4
22		BL p_print_string
23		BL p_print_ln
24		LDR r0, =0
25		POP {pc}
26		.ltorg
27	p_print_string:
28		PUSH {lr}
29		LDR r1, [r0]
30		ADD r2, r0, #4
31		LDR r0, =msg_1
32		ADD r0, r0, #4
33		BL printf
34		MOV r0, #0
35		BL fflush
36		POP {pc}
37	p_print_ln:
38		PUSH {lr}
39		LDR r0, =msg_2
40		ADD r0, r0, #4
41		BL puts
42		MOV r0, #0
43		BL fflush
44		POP {pc}
45	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/intAssignment.wacc
-- Test: intAssignment.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple integer variable declaration and assignment

# Output:
# #empty#

# Exit:
# 20

# Program:

begin
  int x = 10 ;
  x = 20 ;
  exit x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intAssignment.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =10
7		STR r4, [sp]
8		LDR r4, =20
9		STR r4, [sp]
10		LDR r4, [sp]
11		MOV r0, r4
12		BL exit
13		ADD sp, sp, #4
14		LDR r0, =0
15		POP {pc}
16		.ltorg
17	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/intLeadingZeros.wacc
-- Test: intLeadingZeros.wacc

-- Uploaded file: 
---------------------------------------------------------------
# integer variable declaration with leading zeroes

# Output:
# 42
# 0

# Program:

begin
  int x = 0000000000000000000000000000000000000042 ;
  int y = 0000000000000000000000000000000000000000 ;
  println x ;
  println y
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intLeadingZeros.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"%d\0"
5	msg_1:
6		.word 1
7		.ascii	"\0"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #8
15		LDR r4, =42
16		STR r4, [sp, #4]
17		LDR r4, =0
18		STR r4, [sp]
19		LDR r4, [sp, #4]
20		MOV r0, r4
21		BL p_print_int
22		BL p_print_ln
23		LDR r4, [sp]
24		MOV r0, r4
25		BL p_print_int
26		BL p_print_ln
27		ADD sp, sp, #8
28		LDR r0, =0
29		POP {pc}
30		.ltorg
31	p_print_int:
32		PUSH {lr}
33		MOV r1, r0
34		LDR r0, =msg_0
35		ADD r0, r0, #4
36		BL printf
37		MOV r0, #0
38		BL fflush
39		POP {pc}
40	p_print_ln:
41		PUSH {lr}
42		LDR r0, =msg_1
43		ADD r0, r0, #4
44		BL puts
45		MOV r0, #0
46		BL fflush
47		POP {pc}
48	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/sequence/stringAssignment.wacc
-- Test: stringAssignment.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple string variable declaration and assignment

# Output:
# #empty#

# Program:

begin
  string s = "foo" ;
  s = "bar"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
stringAssignment.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 3
4		.ascii	"foo"
5	msg_1:
6		.word 3
7		.ascii	"bar"
8	
9	.text
10	
11	.global main
12	main:
13		PUSH {lr}
14		SUB sp, sp, #4
15		LDR r4, =msg_0
16		STR r4, [sp]
17		LDR r4, =msg_1
18		STR r4, [sp]
19		ADD sp, sp, #4
20		LDR r0, =0
21		POP {pc}
22		.ltorg
23	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/boolDeclaration.wacc
-- Test: boolDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple boolean variable declaration

# Output:
# #empty#

# Program:

begin
  bool b = false
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
boolDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #0
7		STRB r4, [sp]
8		ADD sp, sp, #1
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/boolDeclaration2.wacc
-- Test: boolDeclaration2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple true boolean variable declaration

# Output:
# #empty#

# Program:

begin
  bool b = true
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
boolDeclaration2.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #1
7		STRB r4, [sp]
8		ADD sp, sp, #1
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/capCharDeclaration.wacc
-- Test: capCharDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple capital character variable declaration

# Output:
# #empty#

# Program:

begin
  char c = 'M'
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
capCharDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #'M'
7		STRB r4, [sp]
8		ADD sp, sp, #1
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/charDeclaration.wacc
-- Test: charDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple character variable declaration

# Output:
# #empty#

# Program:

begin
  char c = 'a'
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
charDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #'a'
7		STRB r4, [sp]
8		ADD sp, sp, #1
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/charDeclaration2.wacc
-- Test: charDeclaration2.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple character variable declaration

# Output:
# #empty#

# Program:

begin
  char c = 'z'
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
charDeclaration2.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #'z'
7		STRB r4, [sp]
8		ADD sp, sp, #1
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/emptyStringDeclaration.wacc
-- Test: emptyStringDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple empty string variable declaration

# Output:
# #empty#

# Program:

begin
  string s = ""
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
emptyStringDeclaration.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 0
4		.ascii	""
5	
6	.text
7	
8	.global main
9	main:
10		PUSH {lr}
11		SUB sp, sp, #4
12		LDR r4, =msg_0
13		STR r4, [sp]
14		ADD sp, sp, #4
15		LDR r0, =0
16		POP {pc}
17		.ltorg
18	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/intDeclaration.wacc
-- Test: intDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple integer variable declaration

# Output:
# #empty#

# Program:

begin
  int x = 42
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
intDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =42
7		STR r4, [sp]
8		ADD sp, sp, #4
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/longVarNames.wacc
-- Test: longVarNames.wacc

-- Uploaded file: 
---------------------------------------------------------------
# variable can have very long names

# Output:
# #empty#

# Exit:
# 5

# Program:

begin
  int this_variable_has_a_crazy_long_name_but_ought_to_still_be_valid = 5 ;
  exit this_variable_has_a_crazy_long_name_but_ought_to_still_be_valid
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
longVarNames.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =5
7		STR r4, [sp]
8		LDR r4, [sp]
9		MOV r0, r4
10		BL exit
11		ADD sp, sp, #4
12		LDR r0, =0
13		POP {pc}
14		.ltorg
15	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/manyVariables.wacc
-- Test: manyVariables.wacc

-- Uploaded file: 
---------------------------------------------------------------
# creates 257 variables

# Output:
# #empty#

# Program:

begin
int x0 = 0 ;
int x1 = 1 ;
int x2 = 2 ;
int x3 = 3 ;
int x4 = 4 ;
int x5 = 5 ;
int x6 = 6 ;
int x7 = 7 ;
int x8 = 8 ;
int x9 = 9 ;
int x10 = 10 ;
int x11 = 11 ;
int x12 = 12 ;
int x13 = 13 ;
int x14 = 14 ;
int x15 = 15 ;
int x16 = 16 ;
int x17 = 17 ;
int x18 = 18 ;
int x19 = 19 ;
int x20 = 20 ;
int x21 = 21 ;
int x22 = 22 ;
int x23 = 23 ;
int x24 = 24 ;
int x25 = 25 ;
int x26 = 26 ;
int x27 = 27 ;
int x28 = 28 ;
int x29 = 29 ;
int x30 = 30 ;
int x31 = 31 ;
int x32 = 32 ;
int x33 = 33 ;
int x34 = 34 ;
int x35 = 35 ;
int x36 = 36 ;
int x37 = 37 ;
int x38 = 38 ;
int x39 = 39 ;
int x40 = 40 ;
int x41 = 41 ;
int x42 = 42 ;
int x43 = 43 ;
int x44 = 44 ;
int x45 = 45 ;
int x46 = 46 ;
int x47 = 47 ;
int x48 = 48 ;
int x49 = 49 ;
int x50 = 50 ;
int x51 = 51 ;
int x52 = 52 ;
int x53 = 53 ;
int x54 = 54 ;
int x55 = 55 ;
int x56 = 56 ;
int x57 = 57 ;
int x58 = 58 ;
int x59 = 59 ;
int x60 = 60 ;
int x61 = 61 ;
int x62 = 62 ;
int x63 = 63 ;
int x64 = 64 ;
int x65 = 65 ;
int x66 = 66 ;
int x67 = 67 ;
int x68 = 68 ;
int x69 = 69 ;
int x70 = 70 ;
int x71 = 71 ;
int x72 = 72 ;
int x73 = 73 ;
int x74 = 74 ;
int x75 = 75 ;
int x76 = 76 ;
int x77 = 77 ;
int x78 = 78 ;
int x79 = 79 ;
int x80 = 80 ;
int x81 = 81 ;
int x82 = 82 ;
int x83 = 83 ;
int x84 = 84 ;
int x85 = 85 ;
int x86 = 86 ;
int x87 = 87 ;
int x88 = 88 ;
int x89 = 89 ;
int x90 = 90 ;
int x91 = 91 ;
int x92 = 92 ;
int x93 = 93 ;
int x94 = 94 ;
int x95 = 95 ;
int x96 = 96 ;
int x97 = 97 ;
int x98 = 98 ;
int x99 = 99 ;
int x100 = 100 ;
int x101 = 101 ;
int x102 = 102 ;
int x103 = 103 ;
int x104 = 104 ;
int x105 = 105 ;
int x106 = 106 ;
int x107 = 107 ;
int x108 = 108 ;
int x109 = 109 ;
int x110 = 110 ;
int x111 = 111 ;
int x112 = 112 ;
int x113 = 113 ;
int x114 = 114 ;
int x115 = 115 ;
int x116 = 116 ;
int x117 = 117 ;
int x118 = 118 ;
int x119 = 119 ;
int x120 = 120 ;
int x121 = 121 ;
int x122 = 122 ;
int x123 = 123 ;
int x124 = 124 ;
int x125 = 125 ;
int x126 = 126 ;
int x127 = 127 ;
int x128 = 128 ;
int x129 = 129 ;
int x130 = 130 ;
int x131 = 131 ;
int x132 = 132 ;
int x133 = 133 ;
int x134 = 134 ;
int x135 = 135 ;
int x136 = 136 ;
int x137 = 137 ;
int x138 = 138 ;
int x139 = 139 ;
int x140 = 140 ;
int x141 = 141 ;
int x142 = 142 ;
int x143 = 143 ;
int x144 = 144 ;
int x145 = 145 ;
int x146 = 146 ;
int x147 = 147 ;
int x148 = 148 ;
int x149 = 149 ;
int x150 = 150 ;
int x151 = 151 ;
int x152 = 152 ;
int x153 = 153 ;
int x154 = 154 ;
int x155 = 155 ;
int x156 = 156 ;
int x157 = 157 ;
int x158 = 158 ;
int x159 = 159 ;
int x160 = 160 ;
int x161 = 161 ;
int x162 = 162 ;
int x163 = 163 ;
int x164 = 164 ;
int x165 = 165 ;
int x166 = 166 ;
int x167 = 167 ;
int x168 = 168 ;
int x169 = 169 ;
int x170 = 170 ;
int x171 = 171 ;
int x172 = 172 ;
int x173 = 173 ;
int x174 = 174 ;
int x175 = 175 ;
int x176 = 176 ;
int x177 = 177 ;
int x178 = 178 ;
int x179 = 179 ;
int x180 = 180 ;
int x181 = 181 ;
int x182 = 182 ;
int x183 = 183 ;
int x184 = 184 ;
int x185 = 185 ;
int x186 = 186 ;
int x187 = 187 ;
int x188 = 188 ;
int x189 = 189 ;
int x190 = 190 ;
int x191 = 191 ;
int x192 = 192 ;
int x193 = 193 ;
int x194 = 194 ;
int x195 = 195 ;
int x196 = 196 ;
int x197 = 197 ;
int x198 = 198 ;
int x199 = 199 ;
int x200 = 200 ;
int x201 = 201 ;
int x202 = 202 ;
int x203 = 203 ;
int x204 = 204 ;
int x205 = 205 ;
int x206 = 206 ;
int x207 = 207 ;
int x208 = 208 ;
int x209 = 209 ;
int x210 = 210 ;
int x211 = 211 ;
int x212 = 212 ;
int x213 = 213 ;
int x214 = 214 ;
int x215 = 215 ;
int x216 = 216 ;
int x217 = 217 ;
int x218 = 218 ;
int x219 = 219 ;
int x220 = 220 ;
int x221 = 221 ;
int x222 = 222 ;
int x223 = 223 ;
int x224 = 224 ;
int x225 = 225 ;
int x226 = 226 ;
int x227 = 227 ;
int x228 = 228 ;
int x229 = 229 ;
int x230 = 230 ;
int x231 = 231 ;
int x232 = 232 ;
int x233 = 233 ;
int x234 = 234 ;
int x235 = 235 ;
int x236 = 236 ;
int x237 = 237 ;
int x238 = 238 ;
int x239 = 239 ;
int x240 = 240 ;
int x241 = 241 ;
int x242 = 242 ;
int x243 = 243 ;
int x244 = 244 ;
int x245 = 245 ;
int x246 = 246 ;
int x247 = 247 ;
int x248 = 248 ;
int x249 = 249 ;
int x250 = 250 ;
int x251 = 251 ;
int x252 = 252 ;
int x253 = 253 ;
int x254 = 254 ;
int x255 = 255 ;
int x256 = 256
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
manyVariables.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1024
6		SUB sp, sp, #4
7		LDR r4, =0
8		STR r4, [sp, #1024]
9		LDR r4, =1
10		STR r4, [sp, #1020]
11		LDR r4, =2
12		STR r4, [sp, #1016]
13		LDR r4, =3
14		STR r4, [sp, #1012]
15		LDR r4, =4
16		STR r4, [sp, #1008]
17		LDR r4, =5
18		STR r4, [sp, #1004]
19		LDR r4, =6
20		STR r4, [sp, #1000]
21		LDR r4, =7
22		STR r4, [sp, #996]
23		LDR r4, =8
24		STR r4, [sp, #992]
25		LDR r4, =9
26		STR r4, [sp, #988]
27		LDR r4, =10
28		STR r4, [sp, #984]
29		LDR r4, =11
30		STR r4, [sp, #980]
31		LDR r4, =12
32		STR r4, [sp, #976]
33		LDR r4, =13
34		STR r4, [sp, #972]
35		LDR r4, =14
36		STR r4, [sp, #968]
37		LDR r4, =15
38		STR r4, [sp, #964]
39		LDR r4, =16
40		STR r4, [sp, #960]
41		LDR r4, =17
42		STR r4, [sp, #956]
43		LDR r4, =18
44		STR r4, [sp, #952]
45		LDR r4, =19
46		STR r4, [sp, #948]
47		LDR r4, =20
48		STR r4, [sp, #944]
49		LDR r4, =21
50		STR r4, [sp, #940]
51		LDR r4, =22
52		STR r4, [sp, #936]
53		LDR r4, =23
54		STR r4, [sp, #932]
55		LDR r4, =24
56		STR r4, [sp, #928]
57		LDR r4, =25
58		STR r4, [sp, #924]
59		LDR r4, =26
60		STR r4, [sp, #920]
61		LDR r4, =27
62		STR r4, [sp, #916]
63		LDR r4, =28
64		STR r4, [sp, #912]
65		LDR r4, =29
66		STR r4, [sp, #908]
67		LDR r4, =30
68		STR r4, [sp, #904]
69		LDR r4, =31
70		STR r4, [sp, #900]
71		LDR r4, =32
72		STR r4, [sp, #896]
73		LDR r4, =33
74		STR r4, [sp, #892]
75		LDR r4, =34
76		STR r4, [sp, #888]
77		LDR r4, =35
78		STR r4, [sp, #884]
79		LDR r4, =36
80		STR r4, [sp, #880]
81		LDR r4, =37
82		STR r4, [sp, #876]
83		LDR r4, =38
84		STR r4, [sp, #872]
85		LDR r4, =39
86		STR r4, [sp, #868]
87		LDR r4, =40
88		STR r4, [sp, #864]
89		LDR r4, =41
90		STR r4, [sp, #860]
91		LDR r4, =42
92		STR r4, [sp, #856]
93		LDR r4, =43
94		STR r4, [sp, #852]
95		LDR r4, =44
96		STR r4, [sp, #848]
97		LDR r4, =45
98		STR r4, [sp, #844]
99		LDR r4, =46
100		STR r4, [sp, #840]
101		LDR r4, =47
102		STR r4, [sp, #836]
103		LDR r4, =48
104		STR r4, [sp, #832]
105		LDR r4, =49
106		STR r4, [sp, #828]
107		LDR r4, =50
108		STR r4, [sp, #824]
109		LDR r4, =51
110		STR r4, [sp, #820]
111		LDR r4, =52
112		STR r4, [sp, #816]
113		LDR r4, =53
114		STR r4, [sp, #812]
115		LDR r4, =54
116		STR r4, [sp, #808]
117		LDR r4, =55
118		STR r4, [sp, #804]
119		LDR r4, =56
120		STR r4, [sp, #800]
121		LDR r4, =57
122		STR r4, [sp, #796]
123		LDR r4, =58
124		STR r4, [sp, #792]
125		LDR r4, =59
126		STR r4, [sp, #788]
127		LDR r4, =60
128		STR r4, [sp, #784]
129		LDR r4, =61
130		STR r4, [sp, #780]
131		LDR r4, =62
132		STR r4, [sp, #776]
133		LDR r4, =63
134		STR r4, [sp, #772]
135		LDR r4, =64
136		STR r4, [sp, #768]
137		LDR r4, =65
138		STR r4, [sp, #764]
139		LDR r4, =66
140		STR r4, [sp, #760]
141		LDR r4, =67
142		STR r4, [sp, #756]
143		LDR r4, =68
144		STR r4, [sp, #752]
145		LDR r4, =69
146		STR r4, [sp, #748]
147		LDR r4, =70
148		STR r4, [sp, #744]
149		LDR r4, =71
150		STR r4, [sp, #740]
151		LDR r4, =72
152		STR r4, [sp, #736]
153		LDR r4, =73
154		STR r4, [sp, #732]
155		LDR r4, =74
156		STR r4, [sp, #728]
157		LDR r4, =75
158		STR r4, [sp, #724]
159		LDR r4, =76
160		STR r4, [sp, #720]
161		LDR r4, =77
162		STR r4, [sp, #716]
163		LDR r4, =78
164		STR r4, [sp, #712]
165		LDR r4, =79
166		STR r4, [sp, #708]
167		LDR r4, =80
168		STR r4, [sp, #704]
169		LDR r4, =81
170		STR r4, [sp, #700]
171		LDR r4, =82
172		STR r4, [sp, #696]
173		LDR r4, =83
174		STR r4, [sp, #692]
175		LDR r4, =84
176		STR r4, [sp, #688]
177		LDR r4, =85
178		STR r4, [sp, #684]
179		LDR r4, =86
180		STR r4, [sp, #680]
181		LDR r4, =87
182		STR r4, [sp, #676]
183		LDR r4, =88
184		STR r4, [sp, #672]
185		LDR r4, =89
186		STR r4, [sp, #668]
187		LDR r4, =90
188		STR r4, [sp, #664]
189		LDR r4, =91
190		STR r4, [sp, #660]
191		LDR r4, =92
192		STR r4, [sp, #656]
193		LDR r4, =93
194		STR r4, [sp, #652]
195		LDR r4, =94
196		STR r4, [sp, #648]
197		LDR r4, =95
198		STR r4, [sp, #644]
199		LDR r4, =96
200		STR r4, [sp, #640]
201		LDR r4, =97
202		STR r4, [sp, #636]
203		LDR r4, =98
204		STR r4, [sp, #632]
205		LDR r4, =99
206		STR r4, [sp, #628]
207		LDR r4, =100
208		STR r4, [sp, #624]
209		LDR r4, =101
210		STR r4, [sp, #620]
211		LDR r4, =102
212		STR r4, [sp, #616]
213		LDR r4, =103
214		STR r4, [sp, #612]
215		LDR r4, =104
216		STR r4, [sp, #608]
217		LDR r4, =105
218		STR r4, [sp, #604]
219		LDR r4, =106
220		STR r4, [sp, #600]
221		LDR r4, =107
222		STR r4, [sp, #596]
223		LDR r4, =108
224		STR r4, [sp, #592]
225		LDR r4, =109
226		STR r4, [sp, #588]
227		LDR r4, =110
228		STR r4, [sp, #584]
229		LDR r4, =111
230		STR r4, [sp, #580]
231		LDR r4, =112
232		STR r4, [sp, #576]
233		LDR r4, =113
234		STR r4, [sp, #572]
235		LDR r4, =114
236		STR r4, [sp, #568]
237		LDR r4, =115
238		STR r4, [sp, #564]
239		LDR r4, =116
240		STR r4, [sp, #560]
241		LDR r4, =117
242		STR r4, [sp, #556]
243		LDR r4, =118
244		STR r4, [sp, #552]
245		LDR r4, =119
246		STR r4, [sp, #548]
247		LDR r4, =120
248		STR r4, [sp, #544]
249		LDR r4, =121
250		STR r4, [sp, #540]
251		LDR r4, =122
252		STR r4, [sp, #536]
253		LDR r4, =123
254		STR r4, [sp, #532]
255		LDR r4, =124
256		STR r4, [sp, #528]
257		LDR r4, =125
258		STR r4, [sp, #524]
259		LDR r4, =126
260		STR r4, [sp, #520]
261		LDR r4, =127
262		STR r4, [sp, #516]
263		LDR r4, =128
264		STR r4, [sp, #512]
265		LDR r4, =129
266		STR r4, [sp, #508]
267		LDR r4, =130
268		STR r4, [sp, #504]
269		LDR r4, =131
270		STR r4, [sp, #500]
271		LDR r4, =132
272		STR r4, [sp, #496]
273		LDR r4, =133
274		STR r4, [sp, #492]
275		LDR r4, =134
276		STR r4, [sp, #488]
277		LDR r4, =135
278		STR r4, [sp, #484]
279		LDR r4, =136
280		STR r4, [sp, #480]
281		LDR r4, =137
282		STR r4, [sp, #476]
283		LDR r4, =138
284		STR r4, [sp, #472]
285		LDR r4, =139
286		STR r4, [sp, #468]
287		LDR r4, =140
288		STR r4, [sp, #464]
289		LDR r4, =141
290		STR r4, [sp, #460]
291		LDR r4, =142
292		STR r4, [sp, #456]
293		LDR r4, =143
294		STR r4, [sp, #452]
295		LDR r4, =144
296		STR r4, [sp, #448]
297		LDR r4, =145
298		STR r4, [sp, #444]
299		LDR r4, =146
300		STR r4, [sp, #440]
301		LDR r4, =147
302		STR r4, [sp, #436]
303		LDR r4, =148
304		STR r4, [sp, #432]
305		LDR r4, =149
306		STR r4, [sp, #428]
307		LDR r4, =150
308		STR r4, [sp, #424]
309		LDR r4, =151
310		STR r4, [sp, #420]
311		LDR r4, =152
312		STR r4, [sp, #416]
313		LDR r4, =153
314		STR r4, [sp, #412]
315		LDR r4, =154
316		STR r4, [sp, #408]
317		LDR r4, =155
318		STR r4, [sp, #404]
319		LDR r4, =156
320		STR r4, [sp, #400]
321		LDR r4, =157
322		STR r4, [sp, #396]
323		LDR r4, =158
324		STR r4, [sp, #392]
325		LDR r4, =159
326		STR r4, [sp, #388]
327		LDR r4, =160
328		STR r4, [sp, #384]
329		LDR r4, =161
330		STR r4, [sp, #380]
331		LDR r4, =162
332		STR r4, [sp, #376]
333		LDR r4, =163
334		STR r4, [sp, #372]
335		LDR r4, =164
336		STR r4, [sp, #368]
337		LDR r4, =165
338		STR r4, [sp, #364]
339		LDR r4, =166
340		STR r4, [sp, #360]
341		LDR r4, =167
342		STR r4, [sp, #356]
343		LDR r4, =168
344		STR r4, [sp, #352]
345		LDR r4, =169
346		STR r4, [sp, #348]
347		LDR r4, =170
348		STR r4, [sp, #344]
349		LDR r4, =171
350		STR r4, [sp, #340]
351		LDR r4, =172
352		STR r4, [sp, #336]
353		LDR r4, =173
354		STR r4, [sp, #332]
355		LDR r4, =174
356		STR r4, [sp, #328]
357		LDR r4, =175
358		STR r4, [sp, #324]
359		LDR r4, =176
360		STR r4, [sp, #320]
361		LDR r4, =177
362		STR r4, [sp, #316]
363		LDR r4, =178
364		STR r4, [sp, #312]
365		LDR r4, =179
366		STR r4, [sp, #308]
367		LDR r4, =180
368		STR r4, [sp, #304]
369		LDR r4, =181
370		STR r4, [sp, #300]
371		LDR r4, =182
372		STR r4, [sp, #296]
373		LDR r4, =183
374		STR r4, [sp, #292]
375		LDR r4, =184
376		STR r4, [sp, #288]
377		LDR r4, =185
378		STR r4, [sp, #284]
379		LDR r4, =186
380		STR r4, [sp, #280]
381		LDR r4, =187
382		STR r4, [sp, #276]
383		LDR r4, =188
384		STR r4, [sp, #272]
385		LDR r4, =189
386		STR r4, [sp, #268]
387		LDR r4, =190
388		STR r4, [sp, #264]
389		LDR r4, =191
390		STR r4, [sp, #260]
391		LDR r4, =192
392		STR r4, [sp, #256]
393		LDR r4, =193
394		STR r4, [sp, #252]
395		LDR r4, =194
396		STR r4, [sp, #248]
397		LDR r4, =195
398		STR r4, [sp, #244]
399		LDR r4, =196
400		STR r4, [sp, #240]
401		LDR r4, =197
402		STR r4, [sp, #236]
403		LDR r4, =198
404		STR r4, [sp, #232]
405		LDR r4, =199
406		STR r4, [sp, #228]
407		LDR r4, =200
408		STR r4, [sp, #224]
409		LDR r4, =201
410		STR r4, [sp, #220]
411		LDR r4, =202
412		STR r4, [sp, #216]
413		LDR r4, =203
414		STR r4, [sp, #212]
415		LDR r4, =204
416		STR r4, [sp, #208]
417		LDR r4, =205
418		STR r4, [sp, #204]
419		LDR r4, =206
420		STR r4, [sp, #200]
421		LDR r4, =207
422		STR r4, [sp, #196]
423		LDR r4, =208
424		STR r4, [sp, #192]
425		LDR r4, =209
426		STR r4, [sp, #188]
427		LDR r4, =210
428		STR r4, [sp, #184]
429		LDR r4, =211
430		STR r4, [sp, #180]
431		LDR r4, =212
432		STR r4, [sp, #176]
433		LDR r4, =213
434		STR r4, [sp, #172]
435		LDR r4, =214
436		STR r4, [sp, #168]
437		LDR r4, =215
438		STR r4, [sp, #164]
439		LDR r4, =216
440		STR r4, [sp, #160]
441		LDR r4, =217
442		STR r4, [sp, #156]
443		LDR r4, =218
444		STR r4, [sp, #152]
445		LDR r4, =219
446		STR r4, [sp, #148]
447		LDR r4, =220
448		STR r4, [sp, #144]
449		LDR r4, =221
450		STR r4, [sp, #140]
451		LDR r4, =222
452		STR r4, [sp, #136]
453		LDR r4, =223
454		STR r4, [sp, #132]
455		LDR r4, =224
456		STR r4, [sp, #128]
457		LDR r4, =225
458		STR r4, [sp, #124]
459		LDR r4, =226
460		STR r4, [sp, #120]
461		LDR r4, =227
462		STR r4, [sp, #116]
463		LDR r4, =228
464		STR r4, [sp, #112]
465		LDR r4, =229
466		STR r4, [sp, #108]
467		LDR r4, =230
468		STR r4, [sp, #104]
469		LDR r4, =231
470		STR r4, [sp, #100]
471		LDR r4, =232
472		STR r4, [sp, #96]
473		LDR r4, =233
474		STR r4, [sp, #92]
475		LDR r4, =234
476		STR r4, [sp, #88]
477		LDR r4, =235
478		STR r4, [sp, #84]
479		LDR r4, =236
480		STR r4, [sp, #80]
481		LDR r4, =237
482		STR r4, [sp, #76]
483		LDR r4, =238
484		STR r4, [sp, #72]
485		LDR r4, =239
486		STR r4, [sp, #68]
487		LDR r4, =240
488		STR r4, [sp, #64]
489		LDR r4, =241
490		STR r4, [sp, #60]
491		LDR r4, =242
492		STR r4, [sp, #56]
493		LDR r4, =243
494		STR r4, [sp, #52]
495		LDR r4, =244
496		STR r4, [sp, #48]
497		LDR r4, =245
498		STR r4, [sp, #44]
499		LDR r4, =246
500		STR r4, [sp, #40]
501		LDR r4, =247
502		STR r4, [sp, #36]
503		LDR r4, =248
504		STR r4, [sp, #32]
505		LDR r4, =249
506		STR r4, [sp, #28]
507		LDR r4, =250
508		STR r4, [sp, #24]
509		LDR r4, =251
510		STR r4, [sp, #20]
511		LDR r4, =252
512		STR r4, [sp, #16]
513		LDR r4, =253
514		STR r4, [sp, #12]
515		LDR r4, =254
516		STR r4, [sp, #8]
517		LDR r4, =255
518		STR r4, [sp, #4]
519		LDR r4, =256
520		STR r4, [sp]
521		ADD sp, sp, #1024
522		ADD sp, sp, #4
523		LDR r0, =0
524		POP {pc}
525		.ltorg
526	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/negIntDeclaration.wacc
-- Test: negIntDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple negative integer variable declaration

# Output:
# #empty#

# Program:

begin
  int x = -1
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
negIntDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =-1
7		STR r4, [sp]
8		ADD sp, sp, #4
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/puncCharDeclaration.wacc
-- Test: puncCharDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple punctuation character variable declaration

# Output:
# #empty#

# Program:

begin
  char c = '!'
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
puncCharDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #1
6		MOV r4, #'!'
7		STRB r4, [sp]
8		ADD sp, sp, #1
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/stringDeclaration.wacc
-- Test: stringDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple string variable declaration

# Output:
# #empty#

# Program:

begin
  string s = "Hello World!"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
stringDeclaration.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 12
4		.ascii	"Hello World!"
5	
6	.text
7	
8	.global main
9	main:
10		PUSH {lr}
11		SUB sp, sp, #4
12		LDR r4, =msg_0
13		STR r4, [sp]
14		ADD sp, sp, #4
15		LDR r0, =0
16		POP {pc}
17		.ltorg
18	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/zeroIntDeclaration.wacc
-- Test: zeroIntDeclaration.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple zero integer variable declaration

# Output:
# #empty#

# Program:

begin
  int x = 0
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
zeroIntDeclaration.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =0
7		STR r4, [sp]
8		ADD sp, sp, #4
9		LDR r0, =0
10		POP {pc}
11		.ltorg
12	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/variables/_VarNames.wacc
-- Test: _VarNames.wacc

-- Uploaded file: 
---------------------------------------------------------------
# variable can have _ in their names

# Output:
# #empty#

# Exit:
# 19

# Program:

begin
  int an_underscore = 19 ;
  exit an_underscore
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
_VarNames.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		SUB sp, sp, #4
6		LDR r4, =19
7		STR r4, [sp]
8		LDR r4, [sp]
9		MOV r0, r4
10		BL exit
11		ADD sp, sp, #4
12		LDR r0, =0
13		POP {pc}
14		.ltorg
15	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/fibonacciFullIt.wacc
-- Test: fibonacciFullIt.wacc

-- Uploaded file: 
---------------------------------------------------------------
# iteratively calculate the given fibonacci number

# Output:
# This program calculates the nth fibonacci number iteratively.
# Please enter n (should not be too large): #input#
# The input n is #output#
# The nth fibonacci number is #output#

# Program:

begin
  println "This program calculates the nth fibonacci number iteratively." ;
  print "Please enter n (should not be too large): " ;
  int n = 0;
  read n ;
  print "The input n is " ;
  println n ;
  print "The nth fibonacci number is " ;
  int f0 = 0 ;
  int f1 = 1 ;
  int save = 0;
  while n > 0 do
    save = f0 ;
    f0 = f1 ;
    f1 = save + f1 ;
    n = n - 1
  done ;
  println f0
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
fibonacciFullIt.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 61
4		.ascii	"This program calculates the nth fibonacci number iteratively."
5	msg_1:
6		.word 42
7		.ascii	"Please enter n (should not be too large): "
8	msg_2:
9		.word 15
10		.ascii	"The input n is "
11	msg_3:
12		.word 28
13		.ascii	"The nth fibonacci number is "
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 1
19		.ascii	"\0"
20	msg_6:
21		.word 3
22		.ascii	"%d\0"
23	msg_7:
24		.word 3
25		.ascii	"%d\0"
26	msg_8:
27		.word 82
28		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
29	
30	.text
31	
32	.global main
33	main:
34		PUSH {lr}
35		SUB sp, sp, #16
36		LDR r4, =msg_0
37		MOV r0, r4
38		BL p_print_string
39		BL p_print_ln
40		LDR r4, =msg_1
41		MOV r0, r4
42		BL p_print_string
43		LDR r4, =0
44		STR r4, [sp, #12]
45		ADD r4, sp, #12
46		MOV r0, r4
47		BL p_read_int
48		LDR r4, =msg_2
49		MOV r0, r4
50		BL p_print_string
51		LDR r4, [sp, #12]
52		MOV r0, r4
53		BL p_print_int
54		BL p_print_ln
55		LDR r4, =msg_3
56		MOV r0, r4
57		BL p_print_string
58		LDR r4, =0
59		STR r4, [sp, #8]
60		LDR r4, =1
61		STR r4, [sp, #4]
62		LDR r4, =0
63		STR r4, [sp]
64		B L0
65	L1:
66		LDR r4, [sp, #8]
67		STR r4, [sp]
68		LDR r4, [sp, #4]
69		STR r4, [sp, #8]
70		LDR r4, [sp]
71		LDR r5, [sp, #4]
72		ADDS r4, r4, r5
73		BLVS p_throw_overflow_error
74		STR r4, [sp, #4]
75		LDR r4, [sp, #12]
76		LDR r5, =1
77		SUBS r4, r4, r5
78		BLVS p_throw_overflow_error
79		STR r4, [sp, #12]
80	L0:
81		LDR r4, [sp, #12]
82		LDR r5, =0
83		CMP r4, r5
84		MOVGT r4, #1
85		MOVLE r4, #0
86		CMP r4, #1
87		BEQ L1
88		LDR r4, [sp, #8]
89		MOV r0, r4
90		BL p_print_int
91		BL p_print_ln
92		ADD sp, sp, #16
93		LDR r0, =0
94		POP {pc}
95		.ltorg
96	p_print_string:
97		PUSH {lr}
98		LDR r1, [r0]
99		ADD r2, r0, #4
100		LDR r0, =msg_4
101		ADD r0, r0, #4
102		BL printf
103		MOV r0, #0
104		BL fflush
105		POP {pc}
106	p_print_ln:
107		PUSH {lr}
108		LDR r0, =msg_5
109		ADD r0, r0, #4
110		BL puts
111		MOV r0, #0
112		BL fflush
113		POP {pc}
114	p_read_int:
115		PUSH {lr}
116		MOV r1, r0
117		LDR r0, =msg_6
118		ADD r0, r0, #4
119		BL scanf
120		POP {pc}
121	p_print_int:
122		PUSH {lr}
123		MOV r1, r0
124		LDR r0, =msg_7
125		ADD r0, r0, #4
126		BL printf
127		MOV r0, #0
128		BL fflush
129		POP {pc}
130	p_throw_overflow_error:
131		LDR r0, =msg_8
132		BL p_throw_runtime_error
133	p_throw_runtime_error:
134		BL p_print_string
135		MOV r0, #-1
136		BL exit
137	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/fibonacciIterative.wacc
-- Test: fibonacciIterative.wacc

-- Uploaded file: 
---------------------------------------------------------------
# iterative calculation of the first 20 fibonacci numbers

# Output:
# The first 20 fibonacci numbers are:
# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, ...

# Program:

begin
  int i = 0 ;
  int f0 = 0 ;
  int f1 = 1 ;
  int save = 0;
  println "The first 20 fibonacci numbers are:" ;
  while i < 20 do
    print f0 ;
    print ", " ;
    save = f0 ;
    f0 = f1 ;
    f1 = save + f1 ;
    i = i + 1
  done ;
  println "..."
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
fibonacciIterative.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 35
4		.ascii	"The first 20 fibonacci numbers are:"
5	msg_1:
6		.word 2
7		.ascii	", "
8	msg_2:
9		.word 3
10		.ascii	"..."
11	msg_3:
12		.word 5
13		.ascii	"%.*s\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 82
22		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
23	
24	.text
25	
26	.global main
27	main:
28		PUSH {lr}
29		SUB sp, sp, #16
30		LDR r4, =0
31		STR r4, [sp, #12]
32		LDR r4, =0
33		STR r4, [sp, #8]
34		LDR r4, =1
35		STR r4, [sp, #4]
36		LDR r4, =0
37		STR r4, [sp]
38		LDR r4, =msg_0
39		MOV r0, r4
40		BL p_print_string
41		BL p_print_ln
42		B L0
43	L1:
44		LDR r4, [sp, #8]
45		MOV r0, r4
46		BL p_print_int
47		LDR r4, =msg_1
48		MOV r0, r4
49		BL p_print_string
50		LDR r4, [sp, #8]
51		STR r4, [sp]
52		LDR r4, [sp, #4]
53		STR r4, [sp, #8]
54		LDR r4, [sp]
55		LDR r5, [sp, #4]
56		ADDS r4, r4, r5
57		BLVS p_throw_overflow_error
58		STR r4, [sp, #4]
59		LDR r4, [sp, #12]
60		LDR r5, =1
61		ADDS r4, r4, r5
62		BLVS p_throw_overflow_error
63		STR r4, [sp, #12]
64	L0:
65		LDR r4, [sp, #12]
66		LDR r5, =20
67		CMP r4, r5
68		MOVLT r4, #1
69		MOVGE r4, #0
70		CMP r4, #1
71		BEQ L1
72		LDR r4, =msg_2
73		MOV r0, r4
74		BL p_print_string
75		BL p_print_ln
76		ADD sp, sp, #16
77		LDR r0, =0
78		POP {pc}
79		.ltorg
80	p_print_string:
81		PUSH {lr}
82		LDR r1, [r0]
83		ADD r2, r0, #4
84		LDR r0, =msg_3
85		ADD r0, r0, #4
86		BL printf
87		MOV r0, #0
88		BL fflush
89		POP {pc}
90	p_print_ln:
91		PUSH {lr}
92		LDR r0, =msg_4
93		ADD r0, r0, #4
94		BL puts
95		MOV r0, #0
96		BL fflush
97		POP {pc}
98	p_print_int:
99		PUSH {lr}
100		MOV r1, r0
101		LDR r0, =msg_5
102		ADD r0, r0, #4
103		BL printf
104		MOV r0, #0
105		BL fflush
106		POP {pc}
107	p_throw_overflow_error:
108		LDR r0, =msg_6
109		BL p_throw_runtime_error
110	p_throw_runtime_error:
111		BL p_print_string
112		MOV r0, #-1
113		BL exit
114	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/loopCharCondition.wacc
-- Test: loopCharCondition.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Use a character as a loop condition. Enter the loop once only, then exit the loop.

# Output:
# Change c
# Should print "Change c" once before.

# Program:

begin
	char c = '\0' ;
	while c == '\0' do
		c = 'a' ;
		println "Change c"
	done ;
	println "Should print \"Change c\" once before."
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
loopCharCondition.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 8
4		.ascii	"Change c"
5	msg_1:
6		.word 36
7		.ascii	"Should print \"Change c\" once before."
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #1
21		MOV r4, #0
22		STRB r4, [sp]
23		B L0
24	L1:
25		MOV r4, #'a'
26		STRB r4, [sp]
27		LDR r4, =msg_0
28		MOV r0, r4
29		BL p_print_string
30		BL p_print_ln
31	L0:
32		LDRSB r4, [sp]
33		MOV r5, #0
34		CMP r4, r5
35		MOVEQ r4, #1
36		MOVNE r4, #0
37		CMP r4, #1
38		BEQ L1
39		LDR r4, =msg_1
40		MOV r0, r4
41		BL p_print_string
42		BL p_print_ln
43		ADD sp, sp, #1
44		LDR r0, =0
45		POP {pc}
46		.ltorg
47	p_print_string:
48		PUSH {lr}
49		LDR r1, [r0]
50		ADD r2, r0, #4
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL printf
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_print_ln:
58		PUSH {lr}
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL puts
62		MOV r0, #0
63		BL fflush
64		POP {pc}
65	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/loopIntCondition.wacc
-- Test: loopIntCondition.wacc

-- Uploaded file: 
---------------------------------------------------------------
# Use a integer as a loop condition. Enter the loop once only, then exit the loop.

# Output:
# Change n
# Should print "Change n" once before.

# Program:

begin
	int n = 0 ;
	while n != 1 do
		n = 1 ;
		println "Change n"
	done ;
	println "Should print \"Change n\" once before."
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
loopIntCondition.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 8
4		.ascii	"Change n"
5	msg_1:
6		.word 36
7		.ascii	"Should print \"Change n\" once before."
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #4
21		LDR r4, =0
22		STR r4, [sp]
23		B L0
24	L1:
25		LDR r4, =1
26		STR r4, [sp]
27		LDR r4, =msg_0
28		MOV r0, r4
29		BL p_print_string
30		BL p_print_ln
31	L0:
32		LDR r4, [sp]
33		LDR r5, =1
34		CMP r4, r5
35		MOVNE r4, #1
36		MOVEQ r4, #0
37		CMP r4, #1
38		BEQ L1
39		LDR r4, =msg_1
40		MOV r0, r4
41		BL p_print_string
42		BL p_print_ln
43		ADD sp, sp, #4
44		LDR r0, =0
45		POP {pc}
46		.ltorg
47	p_print_string:
48		PUSH {lr}
49		LDR r1, [r0]
50		ADD r2, r0, #4
51		LDR r0, =msg_2
52		ADD r0, r0, #4
53		BL printf
54		MOV r0, #0
55		BL fflush
56		POP {pc}
57	p_print_ln:
58		PUSH {lr}
59		LDR r0, =msg_3
60		ADD r0, r0, #4
61		BL puts
62		MOV r0, #0
63		BL fflush
64		POP {pc}
65	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/max.wacc
-- Test: max.wacc

-- Uploaded file: 
---------------------------------------------------------------
# find the max of two numbers

# Output:
# max value = 17

# Program:

begin
  int i = 0 ;
  int x = 10 ;
  int y = 17 ;
  while (y > 0 || x > 0) do
    x = x - 1 ;
    y = y - 1 ;
    i = i + 1
  done ;
  print "max value = ";
  println i
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
max.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 12
4		.ascii	"max value = "
5	msg_1:
6		.word 82
7		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #12
24		LDR r4, =0
25		STR r4, [sp, #8]
26		LDR r4, =10
27		STR r4, [sp, #4]
28		LDR r4, =17
29		STR r4, [sp]
30		B L0
31	L1:
32		LDR r4, [sp, #4]
33		LDR r5, =1
34		SUBS r4, r4, r5
35		BLVS p_throw_overflow_error
36		STR r4, [sp, #4]
37		LDR r4, [sp]
38		LDR r5, =1
39		SUBS r4, r4, r5
40		BLVS p_throw_overflow_error
41		STR r4, [sp]
42		LDR r4, [sp, #8]
43		LDR r5, =1
44		ADDS r4, r4, r5
45		BLVS p_throw_overflow_error
46		STR r4, [sp, #8]
47	L0:
48		LDR r4, [sp]
49		LDR r5, =0
50		CMP r4, r5
51		MOVGT r4, #1
52		MOVLE r4, #0
53		LDR r5, [sp, #4]
54		LDR r6, =0
55		CMP r5, r6
56		MOVGT r5, #1
57		MOVLE r5, #0
58		ORR r4, r4, r5
59		CMP r4, #1
60		BEQ L1
61		LDR r4, =msg_0
62		MOV r0, r4
63		BL p_print_string
64		LDR r4, [sp, #8]
65		MOV r0, r4
66		BL p_print_int
67		BL p_print_ln
68		ADD sp, sp, #12
69		LDR r0, =0
70		POP {pc}
71		.ltorg
72	p_throw_overflow_error:
73		LDR r0, =msg_1
74		BL p_throw_runtime_error
75	p_print_string:
76		PUSH {lr}
77		LDR r1, [r0]
78		ADD r2, r0, #4
79		LDR r0, =msg_2
80		ADD r0, r0, #4
81		BL printf
82		MOV r0, #0
83		BL fflush
84		POP {pc}
85	p_print_int:
86		PUSH {lr}
87		MOV r1, r0
88		LDR r0, =msg_3
89		ADD r0, r0, #4
90		BL printf
91		MOV r0, #0
92		BL fflush
93		POP {pc}
94	p_print_ln:
95		PUSH {lr}
96		LDR r0, =msg_4
97		ADD r0, r0, #4
98		BL puts
99		MOV r0, #0
100		BL fflush
101		POP {pc}
102	p_throw_runtime_error:
103		BL p_print_string
104		MOV r0, #-1
105		BL exit
106	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/min.wacc
-- Test: min.wacc

-- Uploaded file: 
---------------------------------------------------------------
# find the min of two numbers

# Output:
# min value = 10

# Program:

begin
  int i = 0 ;
  int x = 10 ;
  int y = 17 ;
  while y > 0 && x > 0 do
    x = x - 1 ;
    y = y - 1 ;
    i = i + 1
  done ;
  print "min value = " ;
  println i
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
min.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 12
4		.ascii	"min value = "
5	msg_1:
6		.word 82
7		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 1
16		.ascii	"\0"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #12
24		LDR r4, =0
25		STR r4, [sp, #8]
26		LDR r4, =10
27		STR r4, [sp, #4]
28		LDR r4, =17
29		STR r4, [sp]
30		B L0
31	L1:
32		LDR r4, [sp, #4]
33		LDR r5, =1
34		SUBS r4, r4, r5
35		BLVS p_throw_overflow_error
36		STR r4, [sp, #4]
37		LDR r4, [sp]
38		LDR r5, =1
39		SUBS r4, r4, r5
40		BLVS p_throw_overflow_error
41		STR r4, [sp]
42		LDR r4, [sp, #8]
43		LDR r5, =1
44		ADDS r4, r4, r5
45		BLVS p_throw_overflow_error
46		STR r4, [sp, #8]
47	L0:
48		LDR r4, [sp]
49		LDR r5, =0
50		CMP r4, r5
51		MOVGT r4, #1
52		MOVLE r4, #0
53		LDR r5, [sp, #4]
54		LDR r6, =0
55		CMP r5, r6
56		MOVGT r5, #1
57		MOVLE r5, #0
58		AND r4, r4, r5
59		CMP r4, #1
60		BEQ L1
61		LDR r4, =msg_0
62		MOV r0, r4
63		BL p_print_string
64		LDR r4, [sp, #8]
65		MOV r0, r4
66		BL p_print_int
67		BL p_print_ln
68		ADD sp, sp, #12
69		LDR r0, =0
70		POP {pc}
71		.ltorg
72	p_throw_overflow_error:
73		LDR r0, =msg_1
74		BL p_throw_runtime_error
75	p_print_string:
76		PUSH {lr}
77		LDR r1, [r0]
78		ADD r2, r0, #4
79		LDR r0, =msg_2
80		ADD r0, r0, #4
81		BL printf
82		MOV r0, #0
83		BL fflush
84		POP {pc}
85	p_print_int:
86		PUSH {lr}
87		MOV r1, r0
88		LDR r0, =msg_3
89		ADD r0, r0, #4
90		BL printf
91		MOV r0, #0
92		BL fflush
93		POP {pc}
94	p_print_ln:
95		PUSH {lr}
96		LDR r0, =msg_4
97		ADD r0, r0, #4
98		BL puts
99		MOV r0, #0
100		BL fflush
101		POP {pc}
102	p_throw_runtime_error:
103		BL p_print_string
104		MOV r0, #-1
105		BL exit
106	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/rmStyleAdd.wacc
-- Test: rmStyleAdd.wacc

-- Uploaded file: 
---------------------------------------------------------------
# register machine style addition

# Output:
# initial value of x: 3
# (+)(+)(+)(+)(+)(+)(+)
# final value of x: 10

# Program:

begin
  int x = 3 ;
  int y = 7 ;
  print "initial value of x: " ;
  println x ;
  while y > 0 do
    print "(+)" ;
    x = x + 1 ;
    y = y - 1
  done ;
  println "" ;
  print "final value of x: " ;
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
rmStyleAdd.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 20
4		.ascii	"initial value of x: "
5	msg_1:
6		.word 3
7		.ascii	"(+)"
8	msg_2:
9		.word 0
10		.ascii	""
11	msg_3:
12		.word 18
13		.ascii	"final value of x: "
14	msg_4:
15		.word 5
16		.ascii	"%.*s\0"
17	msg_5:
18		.word 3
19		.ascii	"%d\0"
20	msg_6:
21		.word 1
22		.ascii	"\0"
23	msg_7:
24		.word 82
25		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
26	
27	.text
28	
29	.global main
30	main:
31		PUSH {lr}
32		SUB sp, sp, #8
33		LDR r4, =3
34		STR r4, [sp, #4]
35		LDR r4, =7
36		STR r4, [sp]
37		LDR r4, =msg_0
38		MOV r0, r4
39		BL p_print_string
40		LDR r4, [sp, #4]
41		MOV r0, r4
42		BL p_print_int
43		BL p_print_ln
44		B L0
45	L1:
46		LDR r4, =msg_1
47		MOV r0, r4
48		BL p_print_string
49		LDR r4, [sp, #4]
50		LDR r5, =1
51		ADDS r4, r4, r5
52		BLVS p_throw_overflow_error
53		STR r4, [sp, #4]
54		LDR r4, [sp]
55		LDR r5, =1
56		SUBS r4, r4, r5
57		BLVS p_throw_overflow_error
58		STR r4, [sp]
59	L0:
60		LDR r4, [sp]
61		LDR r5, =0
62		CMP r4, r5
63		MOVGT r4, #1
64		MOVLE r4, #0
65		CMP r4, #1
66		BEQ L1
67		LDR r4, =msg_2
68		MOV r0, r4
69		BL p_print_string
70		BL p_print_ln
71		LDR r4, =msg_3
72		MOV r0, r4
73		BL p_print_string
74		LDR r4, [sp, #4]
75		MOV r0, r4
76		BL p_print_int
77		BL p_print_ln
78		ADD sp, sp, #8
79		LDR r0, =0
80		POP {pc}
81		.ltorg
82	p_print_string:
83		PUSH {lr}
84		LDR r1, [r0]
85		ADD r2, r0, #4
86		LDR r0, =msg_4
87		ADD r0, r0, #4
88		BL printf
89		MOV r0, #0
90		BL fflush
91		POP {pc}
92	p_print_int:
93		PUSH {lr}
94		MOV r1, r0
95		LDR r0, =msg_5
96		ADD r0, r0, #4
97		BL printf
98		MOV r0, #0
99		BL fflush
100		POP {pc}
101	p_print_ln:
102		PUSH {lr}
103		LDR r0, =msg_6
104		ADD r0, r0, #4
105		BL puts
106		MOV r0, #0
107		BL fflush
108		POP {pc}
109	p_throw_overflow_error:
110		LDR r0, =msg_7
111		BL p_throw_runtime_error
112	p_throw_runtime_error:
113		BL p_print_string
114		MOV r0, #-1
115		BL exit
116	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/rmStyleAddIO.wacc
-- Test: rmStyleAddIO.wacc

-- Uploaded file: 
---------------------------------------------------------------
# register machine style addition

# Output:
# Enter the first number: #input# Enter the second number: #input# Initial value of x: #output#
# #output#
# final value of x: #output

# Program:

begin
  int x = 0 ;
  int y = 0 ;
  print "Enter the first number: " ;
  read x ;
  print "Enter the second number: " ;
  read y ;
  print "Initial value of x: " ;
  println x ;
  while y > 0 do
    print "(+)" ;
    x = x + 1 ;
    y = y - 1
  done ;
  println "" ;
  print "final value of x: " ;
  println x
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
rmStyleAddIO.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 24
4		.ascii	"Enter the first number: "
5	msg_1:
6		.word 25
7		.ascii	"Enter the second number: "
8	msg_2:
9		.word 20
10		.ascii	"Initial value of x: "
11	msg_3:
12		.word 3
13		.ascii	"(+)"
14	msg_4:
15		.word 0
16		.ascii	""
17	msg_5:
18		.word 18
19		.ascii	"final value of x: "
20	msg_6:
21		.word 5
22		.ascii	"%.*s\0"
23	msg_7:
24		.word 3
25		.ascii	"%d\0"
26	msg_8:
27		.word 3
28		.ascii	"%d\0"
29	msg_9:
30		.word 1
31		.ascii	"\0"
32	msg_10:
33		.word 82
34		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
35	
36	.text
37	
38	.global main
39	main:
40		PUSH {lr}
41		SUB sp, sp, #8
42		LDR r4, =0
43		STR r4, [sp, #4]
44		LDR r4, =0
45		STR r4, [sp]
46		LDR r4, =msg_0
47		MOV r0, r4
48		BL p_print_string
49		ADD r4, sp, #4
50		MOV r0, r4
51		BL p_read_int
52		LDR r4, =msg_1
53		MOV r0, r4
54		BL p_print_string
55		ADD r4, sp, #0
56		MOV r0, r4
57		BL p_read_int
58		LDR r4, =msg_2
59		MOV r0, r4
60		BL p_print_string
61		LDR r4, [sp, #4]
62		MOV r0, r4
63		BL p_print_int
64		BL p_print_ln
65		B L0
66	L1:
67		LDR r4, =msg_3
68		MOV r0, r4
69		BL p_print_string
70		LDR r4, [sp, #4]
71		LDR r5, =1
72		ADDS r4, r4, r5
73		BLVS p_throw_overflow_error
74		STR r4, [sp, #4]
75		LDR r4, [sp]
76		LDR r5, =1
77		SUBS r4, r4, r5
78		BLVS p_throw_overflow_error
79		STR r4, [sp]
80	L0:
81		LDR r4, [sp]
82		LDR r5, =0
83		CMP r4, r5
84		MOVGT r4, #1
85		MOVLE r4, #0
86		CMP r4, #1
87		BEQ L1
88		LDR r4, =msg_4
89		MOV r0, r4
90		BL p_print_string
91		BL p_print_ln
92		LDR r4, =msg_5
93		MOV r0, r4
94		BL p_print_string
95		LDR r4, [sp, #4]
96		MOV r0, r4
97		BL p_print_int
98		BL p_print_ln
99		ADD sp, sp, #8
100		LDR r0, =0
101		POP {pc}
102		.ltorg
103	p_print_string:
104		PUSH {lr}
105		LDR r1, [r0]
106		ADD r2, r0, #4
107		LDR r0, =msg_6
108		ADD r0, r0, #4
109		BL printf
110		MOV r0, #0
111		BL fflush
112		POP {pc}
113	p_read_int:
114		PUSH {lr}
115		MOV r1, r0
116		LDR r0, =msg_7
117		ADD r0, r0, #4
118		BL scanf
119		POP {pc}
120	p_print_int:
121		PUSH {lr}
122		MOV r1, r0
123		LDR r0, =msg_8
124		ADD r0, r0, #4
125		BL printf
126		MOV r0, #0
127		BL fflush
128		POP {pc}
129	p_print_ln:
130		PUSH {lr}
131		LDR r0, =msg_9
132		ADD r0, r0, #4
133		BL puts
134		MOV r0, #0
135		BL fflush
136		POP {pc}
137	p_throw_overflow_error:
138		LDR r0, =msg_10
139		BL p_throw_runtime_error
140	p_throw_runtime_error:
141		BL p_print_string
142		MOV r0, #-1
143		BL exit
144	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/whileBasic.wacc
-- Test: whileBasic.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple while loop

# Output:
# #empty#

# Program:

begin
  while false do
    skip
  done
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
whileBasic.s contents are:
===========================================================
0	.text
1	
2	.global main
3	main:
4		PUSH {lr}
5		B L0
6	L1:
7	L0:
8		MOV r4, #0
9		CMP r4, #1
10		BEQ L1
11		LDR r0, =0
12		POP {pc}
13		.ltorg
14	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/whileBoolFlip.wacc
-- Test: whileBoolFlip.wacc

-- Uploaded file: 
---------------------------------------------------------------
# while loop flips bool to terminate

# Output:
# flip b!
# end of loop

# Program:

begin
  bool b = true ;
  while b do
    println "flip b!" ;
    b = !b 
  done ;
  println "end of loop"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
whileBoolFlip.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 7
4		.ascii	"flip b!"
5	msg_1:
6		.word 11
7		.ascii	"end of loop"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		SUB sp, sp, #1
21		MOV r4, #1
22		STRB r4, [sp]
23		B L0
24	L1:
25		LDR r4, =msg_0
26		MOV r0, r4
27		BL p_print_string
28		BL p_print_ln
29		LDRSB r4, [sp]
30		EOR r4, r4, #1
31		STRB r4, [sp]
32	L0:
33		LDRSB r4, [sp]
34		CMP r4, #1
35		BEQ L1
36		LDR r4, =msg_1
37		MOV r0, r4
38		BL p_print_string
39		BL p_print_ln
40		ADD sp, sp, #1
41		LDR r0, =0
42		POP {pc}
43		.ltorg
44	p_print_string:
45		PUSH {lr}
46		LDR r1, [r0]
47		ADD r2, r0, #4
48		LDR r0, =msg_2
49		ADD r0, r0, #4
50		BL printf
51		MOV r0, #0
52		BL fflush
53		POP {pc}
54	p_print_ln:
55		PUSH {lr}
56		LDR r0, =msg_3
57		ADD r0, r0, #4
58		BL puts
59		MOV r0, #0
60		BL fflush
61		POP {pc}
62	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/whileCount.wacc
-- Test: whileCount.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple counting while loop

# Output:
# Can you count to 10?
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 10

# Program:

begin
  int i = 1 ;
  println "Can you count to 10?" ;
  while i <= 10 do
    println i ;
    i = i + 1
  done
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
whileCount.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 20
4		.ascii	"Can you count to 10?"
5	msg_1:
6		.word 5
7		.ascii	"%.*s\0"
8	msg_2:
9		.word 1
10		.ascii	"\0"
11	msg_3:
12		.word 3
13		.ascii	"%d\0"
14	msg_4:
15		.word 82
16		.ascii	"OverflowError: the result is too small/large to store in a 4-byte signed-integer.\n"
17	
18	.text
19	
20	.global main
21	main:
22		PUSH {lr}
23		SUB sp, sp, #4
24		LDR r4, =1
25		STR r4, [sp]
26		LDR r4, =msg_0
27		MOV r0, r4
28		BL p_print_string
29		BL p_print_ln
30		B L0
31	L1:
32		LDR r4, [sp]
33		MOV r0, r4
34		BL p_print_int
35		BL p_print_ln
36		LDR r4, [sp]
37		LDR r5, =1
38		ADDS r4, r4, r5
39		BLVS p_throw_overflow_error
40		STR r4, [sp]
41	L0:
42		LDR r4, [sp]
43		LDR r5, =10
44		CMP r4, r5
45		MOVLE r4, #1
46		MOVGT r4, #0
47		CMP r4, #1
48		BEQ L1
49		ADD sp, sp, #4
50		LDR r0, =0
51		POP {pc}
52		.ltorg
53	p_print_string:
54		PUSH {lr}
55		LDR r1, [r0]
56		ADD r2, r0, #4
57		LDR r0, =msg_1
58		ADD r0, r0, #4
59		BL printf
60		MOV r0, #0
61		BL fflush
62		POP {pc}
63	p_print_ln:
64		PUSH {lr}
65		LDR r0, =msg_2
66		ADD r0, r0, #4
67		BL puts
68		MOV r0, #0
69		BL fflush
70		POP {pc}
71	p_print_int:
72		PUSH {lr}
73		MOV r1, r0
74		LDR r0, =msg_3
75		ADD r0, r0, #4
76		BL printf
77		MOV r0, #0
78		BL fflush
79		POP {pc}
80	p_throw_overflow_error:
81		LDR r0, =msg_4
82		BL p_throw_runtime_error
83	p_throw_runtime_error:
84		BL p_print_string
85		MOV r0, #-1
86		BL exit
87	
===========================================================
-- Finished

calling the reference compiler on testcases/valid/while/whileFalse.wacc
-- Test: whileFalse.wacc

-- Uploaded file: 
---------------------------------------------------------------
# simple unentered while loop

# Output:
# end of loop

# Program:

begin
  while false do
    println "looping..."
  done ;
  println "end of loop"
end
---------------------------------------------------------------

-- Compiler Output:
-- Compiling...
-- Printing Assembly...
whileFalse.s contents are:
===========================================================
0	.data
1	
2	msg_0:
3		.word 10
4		.ascii	"looping..."
5	msg_1:
6		.word 11
7		.ascii	"end of loop"
8	msg_2:
9		.word 5
10		.ascii	"%.*s\0"
11	msg_3:
12		.word 1
13		.ascii	"\0"
14	
15	.text
16	
17	.global main
18	main:
19		PUSH {lr}
20		B L0
21	L1:
22		LDR r4, =msg_0
23		MOV r0, r4
24		BL p_print_string
25		BL p_print_ln
26	L0:
27		MOV r4, #0
28		CMP r4, #1
29		BEQ L1
30		LDR r4, =msg_1
31		MOV r0, r4
32		BL p_print_string
33		BL p_print_ln
34		LDR r0, =0
35		POP {pc}
36		.ltorg
37	p_print_string:
38		PUSH {lr}
39		LDR r1, [r0]
40		ADD r2, r0, #4
41		LDR r0, =msg_2
42		ADD r0, r0, #4
43		BL printf
44		MOV r0, #0
45		BL fflush
46		POP {pc}
47	p_print_ln:
48		PUSH {lr}
49		LDR r0, =msg_3
50		ADD r0, r0, #4
51		BL puts
52		MOV r0, #0
53		BL fflush
54		POP {pc}
55	
===========================================================
-- Finished

